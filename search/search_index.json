{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p><code>pymmcore-plus</code> aims to extend pymmcore (python bindings for the C++ micro-manager core) with a number of features designed to facilitate working with Micro-manager in pure python/C environments.</p> <ul> <li> <p><code>pymmcore-plus</code> itself is a superset of   <code>pymmcore</code> (python bindings   for Micro-manager's C++ <code>CMMCore</code>). <code>pymmcore_plus.CMMCorePlus</code> (the main object in this library)   aims to be a drop-in replacement for <code>pymmcore.CMMCore</code>, while adding a number   of additional features including:</p> <ul> <li>A multi-dimensional acquisition engine   implemented in pure python. (The existing acquisition engines in   Micro-manager are written in Java and Clojure).</li> <li>More flexible event connections and callback handling.</li> <li>Extended convenience APIs for working with core (which would be hard or   impossible to implement in the <code>pymmcore</code> SWIG wrapper).</li> <li>More pythonic APIs for various pymmcore objects (e.g. <code>pymmcore_plus.Device</code>,   <code>pymmcore_plus.Configuration</code>) and constants.</li> </ul> </li> <li> <p><code>pymmcore-widgets</code> is a     Qt-based widget library built on     <code>pymmcore-plus</code> that provides GUI elements for     most of the device and acquisition functionality of <code>pymmcore</code>.  It     allows users to build their own custom GUIs for Micro-manager.</p> </li> <li><code>napari-micromanager</code>     is a plugin for the napari image viewer that composes     <code>pymmcore-plus</code> and <code>pymmcore-widgets</code> to provide a full GUI for     Micro-manager that is integrated with the napari viewer.</li> </ul> <p>How is pymmcore-plus different than Pycro-Manager?</p> <p>A common question about <code>pymmcore-plus</code> and related libraries is how it differs from Pycro-Manager, another python library written by Henry Pinkard for working with Micro-manager.</p> <p>The two projects are not mutually exclusive! They aim to support different use cases</p> <p>The primary difference is that Pycro-Manager controls Micro-manager via a ZMQ-based connection to a remote Java process in which the Micro-manager GUI is running (or a headless Java process if the GUI is not running). The Java process in turn communicates with the C++ core driving the hardware.</p> <p><code>pymmcore-plus</code> aims to remove the need for a Java process by communicating directly with the C++ core (via the <code>pymmcore</code> library), and re-implementing any necessary event-based or GUI-based functionality in pure python or C.</p> <p>A major advantage of Pycro-Manager is that you get the entire Java-based micro-manager ecosystem, including the GUI and plugins. A potential disadvantage (depending on your needs), is that it requires a Java runtime environment and cross-process communication.</p> <p>If you are looking to control a microscope via python without any need for Java or interprocess communication, <code>pymmcore(-plus)</code> may help. Note however, that you will be sacrificing the MMStudio GUI! See <code>pymmcore-widgets</code> and <code>napari-micromanager</code> for ongoing efforts to re-implement GUI components in python.</p> <p></p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#install","title":"Install","text":"<p>Install with <code>pip</code> or <code>conda</code>:</p> <pre><code>pip install pymmcore-plus\n\n# OR, to include the `mmcore` command line tool\npip install \"pymmcore-plus[cli]\"\n\n# OR\nconda install -c conda-forge pymmcore-plus\n</code></pre> <p>You will also need the micro-manager device adapters on your system. To get them quickly, assuming you have installed with <code>pymmcore-plus[cli]</code>, you can run:</p> <pre><code>mmcore install\n</code></pre> <p>See install for more details.</p>"},{"location":"#usage","title":"Usage","text":"<p>The main object is <code>pymmcore_plus.CMMCorePlus</code>, which is an enhanced subclass of <code>pymmcore.CMMCore</code>:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\n# instantiate as you would pymmcore.CMMCore\nmmc = CMMCorePlus()\n# OR: use the global singleton\n# mmc = CMMCorePlus.instance()\n\n# without arguments, this will load the demo config\nmmc.loadSystemConfiguration()\n</code></pre> <p>See the <code>CMMCorePlus</code> API documentation for details on the additional features of <code>CMMCorePlus</code>.</p> <p><code>CMMCorePlus.instance</code></p> <p>Creating/accessing a <code>CMMCorePlus</code> object using <code>CMMCorePlus.instance()</code> is a convenient way to access the same core instance from multiple places in your code. All widgets in <code>pymmcore-widgets</code> also use <code>CMMCorePlus.instance()</code> by default, so any widgets you use will automatically connect to the same core instance without any additional configuration.</p> <p>Attempts are made to make it thread-safe.  But please open an issue if you find any problems.</p> <p>While you can easily use <code>pymmcore-plus</code> from a script or IPython/Jupyter you can also use it in combination with the napari based gui napari-micromanager. See using with napari-micromanager for an example of how to use them together.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to <code>pymmcore-plus</code> and related libraries.  Please see contributing for more information.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for thinking of a way to help improve this library! Remember that contributions come in all shapes and sizes beyond writing bug fixes. Contributing to documentation, opening new issues for bugs, asking for clarification on things you find unclear, and requesting new features, are all super valuable contributions.</p>"},{"location":"contributing/#contributing-code","title":"Contributing Code","text":"<p>All development for this library happens in the pymmcore-plus/pymmcore-plus  repo on GitHub. We recommend you work with a Conda environment (or an alternative virtual environment like <code>venv</code>).</p> <p>The below instructions also use Mamba which is a very fast implementation of <code>conda</code>.</p> <pre><code>git clone &lt;your fork&gt;\ncd pymmcore-plus\nmamba create -n pymm-dev -c conda-forge python\nconda activate pymm-dev\npip install -e \".[testing,docs]\"\npip install pre-commit\npre-commit install\n</code></pre> <p>The <code>-e .</code> flag installs <code>pymmcore_plus</code>in \"editable\" mode and <code>[testing,docs]</code> installs the optional dependencies you need for developing <code>pymmcore-plus</code>.</p> <p>Note</p> <p><code>pymmcore-plus</code> is developed using the github flow. Using Git/GitHub can confusing , so if you're new to Git, you may find it helpful to use a program like GitHub Desktop and to follow a guide.</p> <p>Also feel free to ask for help/advice on the relevant GitHub issue.</p>"},{"location":"contributing/#contributing-documentation","title":"Contributing Documentation","text":"<p>Our documentation is built with mkdocs from the files in the <code>docs</code> folder.  To build docs locally:</p> <pre><code># install docs dependencies\npip install -e \".[docs]\"\n\n# build docs and serve locally\nmkdocs serve\n</code></pre> <p>The docs should be live at http://127.0.0.1:8000 and will update automatically as you edit and save them.</p>"},{"location":"contributing/#developing-on-apple-silicon","title":"Developing on Apple Silicon","text":"<p>To build a native version of the DemoCamera for local testing on apple silicon, you can run the following command (you must have homebrew installed)</p> <pre><code>mmcore build-dev\n</code></pre> <p>This will download the micro-manager repo, build it, and drop the DemoCamera and Utilities devices into a folder in your pymmcore-plus install folder (by default <code>~/Library/Application Support/pymmcore-plus/mm</code>).  This path is on the default search path so you should be good to go.  You can confirm by running:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\ncore.loadSystemConfiguration()\ncore.snap()\n</code></pre>"},{"location":"install/","title":"Install","text":""},{"location":"install/#installing-pymmcore-plus","title":"Installing pymmcore-plus","text":"<p><code>pymmcore-plus</code> can be installed with pip:</p> <pre><code>pip install pymmcore-plus\n\n# or, add the [cli] extra if you wish to use the `mmcore` command line tool:\n\npip install \"pymmcore-plus[cli]\"\n</code></pre> <p>... as well as conda:</p> <pre><code>conda install -c conda-forge pymmcore-plus\n</code></pre>"},{"location":"install/#installing-micro-manager-device-adapters","title":"Installing Micro-Manager Device Adapters","text":"<p>Just like underlying the <code>pymmcore</code> that this library, <code>pymmcore-plus</code> relies on the device adapters and C++ core provided by mmCoreAndDevices. There are two ways to do this:</p> <ol> <li> <p>Use the <code>mmcore</code> command line tool</p> <p>If you've installed with <code>pip install \"pymmcore-plus[cli]\"</code>, this library provides a quick way to install the latest version of micro-manager:</p> <pre><code>mmcore install\n</code></pre> <p>This will download the latest release of micro-manager and place it in the pymmcore-plus folder. If you would like to modify the location of the installation, or the release of micro-manager to install, you can use the <code>--dest</code> and <code>--release</code> flags respectively.</p> <p>For more information, run:</p> <pre><code>mmcore install --help\n</code></pre> </li> <li> <p>Download manually from micro-manager.org</p> <p>Go to the micro-manager downloads page and download the latest release for your Operating System.</p> </li> </ol> <p>Critical</p> <p>The device interface version MUST match between pymmcore and the Micro-Manager device adapters.</p> <p>The device interface version of a given pymmcore version is the fourth part in the version number, and can also be with the following command:</p> <pre><code>python -c \"print(__import__('pymmcore').CMMCore().getAPIVersionInfo())\"\n</code></pre> <p>The device interface version of a given Micro-Manager installation can be viewed in Help &gt; About Micro-Manager.  Or you can look at the <code>MMDevice.h</code> file for the corresponding date, roughly here</p> <p>Tip</p> <p>By default, <code>pymmcore-plus</code> will look for a <code>Micro-Manager</code> folder in the default install location. On Windows this is <code>C:\\Program Files\\</code>, on macOS it is <code>/Applications/</code> and on Linux it is <code>/usr/local/lib/</code>. To override these default device adapter search path, set the <code>MICROMANAGER_PATH</code> environment variable.</p> <p>To see which micro-manager installation <code>pymmcore-plus</code> is using, you can run:</p> <pre><code>mmcore find\n</code></pre> <p>or... if you didn't install with the <code>cli</code> extra:</p> <pre><code>python -c \"from pymmcore_plus import find_micromanager; print(find_micromanager())\"\n</code></pre>"},{"location":"install/#on-linux","title":"On Linux","text":"<p>On a linux based system the easiest approach is to just install the C++ core of micromanager, mmCoreAndDevices. To do that follow the build instructions in the micro-manager repo.</p>"},{"location":"api/cmmcoreplus/","title":"CMMCorePlus","text":"<p>The main object in <code>pymmcore_plus</code> is the <code>pymmcore_plus.CMMCorePlus</code> class. <code>CMMCorePlus</code> is a subclass of <code>pymmcore.CMMCore</code> with additional functionality, and some overrides for the sake of convenience or fixed behavior.</p>"},{"location":"api/cmmcoreplus/#cmmcoreplus-api-summary","title":"CMMCorePlus API summary","text":"<p>This table presents all methods available in the <code>CMMCorePlus</code> class, and indicates which methods are unique to <code>CMMCorePlus</code> () and which methods are overridden from <code>CMMCore</code> ().  Below the table, the signatures of all methods are presented, broken into a <code>CMMCorePlus</code> section and a <code>CMMCore</code> section (depending on whether the method is implemented in <code>CMMCorePlus</code> or not).</p> <p> This method is overridden by <code>CMMCorePlus</code>. This method only exists in <code>CMMCorePlus</code>. This method is deprecated. </p> Method Description <code>addGalvoPolygonVertex</code> Add a vertex to a galvo polygon. <code>addSearchPath</code> Add a list of paths to the legacy device adapter search path list. <code>assignImageSynchro</code> Add device to the image-synchro list. <code>canSequenceEvents</code> Check whether two <code>useq.MDAEvent</code> are sequenceable by this core instance. <code>channelGroup_pattern</code> The regex pattern used to identify channel groups. <code>clearCircularBuffer</code> Removes all images from the circular buffer. <code>clearROI</code> Set the region of interest of the current camera to the full frame. <code>debugLogEnabled</code> Indicates if logging of debug messages is enabled <code>defineConfig</code> Defines a configuration. <code>defineConfigGroup</code> Creates an empty configuration group. <code>definePixelSizeConfig</code> Defines an empty pixel size entry. <code>definePropertyBlock</code> Defines a reference for the collection of property-value pairs. <code>defineStateLabel</code> Defines a label for the specific state. <code>deleteConfig</code> Delete <code>configName</code> from <code>groupName</code>. <code>deleteConfigGroup</code> Deletes an entire configuration <code>group</code>. <code>deleteGalvoPolygons</code> Remove all added polygons <code>deletePixelSizeConfig</code> Delete the pixel size configuration for the given <code>resolutionID</code>. <code>describe</code> Print information table with the current configuration. <code>detectDevice</code> Tries to communicate to a device through a given serial port. <code>deviceBusy</code> Checks the busy status of the specific device. <code>deviceTypeBusy</code> Checks the busy status for all devices of the specific type. <code>displaySLMImage</code> Display the waiting image on the SLM. <code>enableContinuousFocus</code> Enables or disables the operation of the continuous focusing hardware device. <code>enableDebugLog</code> Enable or disable logging of debug messages. <code>enableStderrLog</code> Enables or disables log message display on the standard console. <code>events</code> Signaler for core events. <code>fixImage</code> Fix img shape/dtype based on <code>self.getNumberOfComponents()</code>. <code>fullFocus</code> Performs focus acquisition and lock for the one-shot focusing device. <code>getAPIVersionInfo</code> Returns the module and device interface versions. <code>getAdapterObject</code> Return an <code>Adapter</code> object bound to library_name on this core. <code>getAllowedPropertyValues</code> Returns all valid values for the specified property. <code>getAutoFocusDevice</code> Returns the label of the currently selected auto-focus device. <code>getAutoFocusOffset</code> Measures offset for the one-shot focusing device. <code>getAutoShutter</code> Returns the current setting of the auto-shutter option. <code>getAvailableConfigGroups</code> Returns the names of all defined configuration groups <code>getAvailableConfigs</code> Returns all defined configuration names in a given group <code>getAvailableDeviceDescriptions</code> Get descriptions for available devices from the specified library. <code>getAvailableDeviceTypes</code> Get type information for available devices from the specified library. <code>getAvailableDevices</code> Get available devices from the specified device library. <code>getAvailablePixelSizeConfigs</code> Returns all defined resolution preset names <code>getAvailablePropertyBlocks</code> Returns all defined property block identifiers. <code>getBufferFreeCapacity</code> Returns the number of images that can be added to the buffer without <code>getBufferTotalCapacity</code> Returns the total number of images that can be stored in the buffer <code>getBytesPerPixel</code> How many bytes for each pixel. <code>getCameraChannelName</code> Returns the name of the requested channel as known by the default camera <code>getCameraChannelNames</code> Convenience method to call <code>getCameraChannelName</code> for all camera channels. <code>getCameraDevice</code> Returns the label of the currently selected camera device. <code>getChannelGroup</code> Returns the group determining the channel selection. <code>getCircularBufferMemoryFootprint</code> Returns the size of the Circular Buffer in MB <code>getConfigData</code> Return the configuration object for a given <code>configGroup</code> and <code>configName</code>. <code>getConfigGroupObject</code> Return a <code>ConfigGroup</code> object bound to group_name on this core. <code>getConfigGroupState</code> Return the state of the devices included in the specified <code>group</code>. <code>getConfigGroupStateFromCache</code> Return the state of the system cache, for the devices in the specified group. <code>getConfigState</code> Return state of devices included in the specified configuration. <code>getCoreErrorText</code> Returns a pre-defined error test with the given error code <code>getCurrentConfig</code> Returns the current configuration for a given group. <code>getCurrentConfigFromCache</code> Returns the configuration for a given group based on the data in the cache. <code>getCurrentFocusScore</code> Returns the focus score from the default focusing device measured at the <code>getCurrentPixelSizeConfig</code> <code>getData</code> Returns the collection of property-value pairs defined for the current state. <code>getDeviceAdapterNames</code> Return the names of discoverable device adapters. <code>getDeviceAdapterSearchPaths</code> Return the current device adapter search paths. <code>getDeviceDelayMs</code> Reports action delay in milliseconds for the specific device. <code>getDeviceDescription</code> Returns description text for a given device label. \"Description\" is determined <code>getDeviceLibraries</code> Returns the list of device adapters available in the default search path(s). <code>getDeviceLibrary</code> Returns device library (aka module, device adapter) name. <code>getDeviceName</code> Returns device name for a given device label. <code>getDeviceObject</code> Return a <code>Device</code> object bound to device_label on this core. <code>getDevicePropertyNames</code> Returns all property names supported by the device. <code>getDeviceSchema</code> Return JSON-schema describing device <code>device_label</code> and its properties. <code>getDeviceType</code> Return device type for a given device. <code>getExposure</code> <code>getExposureSequenceMaxLength</code> Gets the maximum length of a camera's exposure sequence. <code>getFocusDevice</code> Returns the label of the currently selected focus device. <code>getFocusDirection</code> Get the focus direction of a stage. <code>getGalvoChannel</code> Get the name of the active galvo channel (for a multi-laser galvo device). <code>getGalvoDevice</code> Returns the label of the currently selected Galvo device. <code>getGalvoPosition</code> <code>getGalvoXMinimum</code> Get the Galvo x minimum <code>getGalvoXRange</code> Get the Galvo x range <code>getGalvoYMinimum</code> Get the Galvo y minimum <code>getGalvoYRange</code> Get the Galvo y range <code>getHostName</code> return current computer name. <code>getImage</code> Return the internal image buffer. <code>getImageBitDepth</code> How many bits of dynamic range are to be expected from the camera. <code>getImageBufferSize</code> Returns the size of the internal image buffer. <code>getImageHeight</code> Vertical dimension of the image buffer in pixels. <code>getImageProcessorDevice</code> Returns the label of the currently selected image processor device. <code>getImageWidth</code> Horizontal dimension of the image buffer in pixels. <code>getInstalledDeviceDescription</code> Returns <code>GetInstalledPeripheralDescription</code> from the specified <code>hubLabel</code> device. <code>getInstalledDevices</code> Performs auto-detection and loading of child devices that are attached to a <code>getLastFocusScore</code> Returns the latest focus score from the focusing device. <code>getLastImage</code> Gets the last image from the circular buffer. <code>getLastImageAndMD</code> Return last image from the circular buffer along with metadata. <code>getLastImageMD</code> <code>getLoadedDevices</code> Returns an array of labels for currently loaded devices. <code>getLoadedDevicesOfType</code> Returns an array of labels for currently loaded devices of specific type. <code>getLoadedPeripheralDevices</code> Return labels of all loaded peripherals of <code>hubLabel</code> device. <code>getMACAddresses</code> Retrieve vector of MAC addresses for the Ethernet cards in the current computer. <code>getMagnificationFactor</code> Returns the product of all Magnifiers in the system or 1.0 when none is found. <code>getMultiROI</code> Get multiple ROIs from the current camera device. <code>getNBeforeLastImageAndMD</code> Return image taken <code>n</code> images ago along with associated metadata. <code>getNBeforeLastImageMD</code> Returns a pointer to the pixels of the image that was inserted n images ago. <code>getNumberOfCameraChannels</code> Returns the number of simultaneous channels the default camera is returning. <code>getNumberOfComponents</code> Returns the number of components the default camera is returning. <code>getNumberOfStates</code> Returns the total number of available positions (states). <code>getOrGuessChannelGroup</code> Get the channelGroup or find a likely set of candidates. <code>getParentLabel</code> Returns parent device. <code>getPixelSizeAffine</code> <code>getPixelSizeAffineByID</code> Returns the Affine Transform to related camera pixels with stage movement for <code>getPixelSizeConfigData</code> Return the configuration object for a given pixel size preset <code>configName</code>. <code>getPixelSizeUm</code> <code>getPixelSizeUmByID</code> Returns the pixel size in um for the requested pixel size group <code>getPosition</code> <code>getPrimaryLogFile</code> Return the name of the primary Core log file. <code>getProperty</code> Returns the property value for the specified device. <code>getPropertyBlockData</code> Returns the collection of property-value pairs defined in this block. <code>getPropertyFromCache</code> Returns the cached property value for the specified device. <code>getPropertyLowerLimit</code> Returns the property lower limit value, if the property has limits - 0 <code>getPropertyObject</code> Return a DeviceProperty object bound to a device/property on this core. <code>getPropertySequenceMaxLength</code> Queries device property for the maximum number of events that can be put <code>getPropertyType</code> Return the intrinsic property type for a given device and property. <code>getPropertyUpperLimit</code> Returns the property upper limit value, if the property has limits - 0 <code>getROI</code> <code>getRemainingImageCount</code> Returns number ofimages available in the Circular Buffer <code>getSLMBytesPerPixel</code> Returns the number of bytes per SLM pixel <code>getSLMDevice</code> Returns the label of the currently selected SLM device. <code>getSLMExposure</code> Returns the exposure time that will be used by the SLM for illumination <code>getSLMHeight</code> Returns the height (in \"pixels\") of the SLM <code>getSLMNumberOfComponents</code> Returns the number of components (usually these depict colors) of the SLM. <code>getSLMSequenceMaxLength</code> For SLMs that support sequences, returns the maximum length of the sequence <code>getSLMWidth</code> Returns the width (in \"pixels\") of the SLM <code>getSerialPortAnswer</code> Continuously read from the serial port until the terminating sequence is <code>getShutterDevice</code> Returns the label of the currently selected shutter device. <code>getShutterOpen</code> <code>getStageSequenceMaxLength</code> Gets the maximum length of a stage's position sequence. <code>getState</code> Returns the current state (position) on the specific device. <code>getStateFromLabel</code> Obtain the state for a given label. <code>getStateLabel</code> Returns the current state as the label (string). <code>getStateLabelData</code> Returns the collection of property-value pairs defined for the specific <code>getStateLabels</code> Return labels for all states <code>getSystemState</code> Return the entire system state. <code>getSystemStateCache</code> Return the entire system state from cache. <code>getTaggedImage</code> Return getImage as named tuple with metadata. <code>getTags</code> Return a dict of metadata tags for the state of the core. <code>getTimeoutMs</code> Get the timeout for all wait commands. <code>getUserId</code> Displays current user name. <code>getVersionInfo</code> Displays core version. <code>getXPosition</code> <code>getXYPosition</code> <code>getXYStageDevice</code> Returns the label of the currently selected XYStage device. <code>getXYStageSequenceMaxLength</code> Gets the maximum length of an XY stage's position sequence. <code>getYPosition</code> <code>getZPosition</code> Obtains the current position of the Z axis of the Z stage in microns. <code>guessObjectiveDevices</code> Find any loaded devices that are likely to be an Objective/Nosepiece. <code>hasProperty</code> Checks if device has a property with a specified name. <code>hasPropertyLimits</code> Queries device if the specific property has limits. <code>home</code> Perform a hardware homing operation for an XY or focus/Z stage. <code>incrementalFocus</code> Performs incremental focus for the one-shot focusing device. <code>initializeAllDevices</code> Calls Initialize() method for each loaded device. <code>initializeCircularBuffer</code> Initialize circular buffer based on the current camera settings. <code>initializeDevice</code> Initializes specific device. <code>instance</code> Return the global singleton instance of <code>CMMCorePlus</code>. <code>isBufferOverflowed</code> Indicates whether the circular buffer is overflowed <code>isConfigDefined</code> Checks if the configuration already exists within a group. <code>isContinuousFocusDrive</code> Check if a stage has continuous focusing capability. <code>isContinuousFocusEnabled</code> Checks if the continuous focusing hardware device is ON or OFF. <code>isContinuousFocusLocked</code> Returns the lock-in status of the continuous focusing device. <code>isExposureSequenceable</code> Queries camera if exposure can be used in a sequence <code>isGroupDefined</code> Checks if the group already exists. <code>isMultiROIEnabled</code> Queries the camera to determine if multiple ROIs are currently set. <code>isMultiROISupported</code> Queries the camera to determine if it supports multiple ROIs. <code>isPixelSizeConfigDefined</code> Checks if the Pixel Size Resolution already exists <code>isPropertyPreInit</code> Tells us whether the property must be defined prior to initialization. <code>isPropertyReadOnly</code> Tells us whether the property can be modified. <code>isPropertySequenceable</code> Queries device if the specified property can be used in a sequence <code>isSequenceRunning</code> <code>isStageLinearSequenceable</code> Queries if the stage can be used in a linear sequence. <code>isStageSequenceable</code> Queries stage if it can be used in a sequence <code>isXYStageSequenceable</code> Queries XY stage if it can be used in a sequence <code>iterConfigGroups</code> Iterate <code>ConfigGroup</code> objects for all configs. <code>iterDeviceAdapters</code> Iterate over all available device adapters. <code>iterDevices</code> Iterate over currently loaded devices. <code>iterProperties</code> Iterate over currently loaded (device_label, property_name) pairs. <code>loadDevice</code> Load a device from the plugin library. <code>loadExposureSequence</code> Transfer a sequence of exposure times to the camera. <code>loadGalvoPolygons</code> Load a set of galvo polygons to the device <code>loadPropertySequence</code> Transfer a sequence of events/states/whatever to the device. <code>loadSLMSequence</code> Load a sequence of images into the SLM <code>loadStageSequence</code> Transfer a sequence of events/states/whatever to the device. <code>loadSystemConfiguration</code> Load a system config file conforming to the MM <code>.cfg</code> format. <code>loadSystemState</code> Loads the system configuration from the text file conforming to the <code>loadXYStageSequence</code> Transfer a sequence of stage positions to the xy stage. <code>logMessage</code> <code>mda</code> Return the <code>MDARunner</code> for this <code>CMMCorePlus</code> instance. <code>noop</code> A static method that does nothing. <code>objective_device_pattern</code> Pattern used to guess objective device labels. <code>pointGalvoAndFire</code> Set the Galvo to an x,y position and fire the laser for a predetermined duration. <code>popNextImage</code> Gets and removes the next image from the circular buffer. <code>popNextImageAndMD</code> Gets and removes the next image (and metadata) from the circular buffer. <code>popNextImageMD</code> <code>popNextTaggedImage</code> Return popNextImageAndMD as named tuple with metadata. <code>prepareSequenceAcquisition</code> Prepare the camera for the sequence acquisition to save the time in the <code>readFromSerialPort</code> Reads the contents of the Rx buffer. <code>registerCallback</code> Register a callback (listener class). <code>register_mda_engine</code> Set the MDA Engine to be used on <code>run_mda</code>. <code>removeImageSynchro</code> Removes device from the image-synchro list. <code>removeImageSynchroAll</code> Clears the image synchro device list. <code>renameConfig</code> Renames a configuration within a specified group. <code>renameConfigGroup</code> Renames a configuration group. <code>renamePixelSizeConfig</code> Renames a pixel size configuration. <code>reset</code> Unloads all devices from the core, clears all configuration data and property <code>runGalvoPolygons</code> Run a loop of galvo polygons <code>runGalvoSequence</code> Run a sequence of galvo positions <code>run_mda</code> Run a sequence of useq.MDAEvent on a new thread. <code>saveSystemConfiguration</code> Saves the current system configuration to a text file. <code>saveSystemState</code> Saves the current system state to a text file of the MM specific format. <code>setAdapterOrigin</code> <code>setAdapterOriginXY</code> <code>setAutoFocusDevice</code> Sets the current auto-focus device. <code>setAutoFocusOffset</code> Applies offset the one-shot focusing device. <code>setAutoShutter</code> Set shutter to automatically open and close when an image is acquired. <code>setCameraDevice</code> Sets the current camera device. <code>setChannelGroup</code> Specifies the group determining the channel selection. <code>setCircularBufferMemoryFootprint</code> Reserve memory for the circular buffer. <code>setConfig</code> Applies a configuration to a group. <code>setContext</code> Set core properties in a context restoring the initial values on exit. <code>setDeviceAdapterSearchPaths</code> Set the device adapter search paths. <code>setDeviceDelayMs</code> Overrides the built-in value for the action delay. <code>setExposure</code> <code>setFocusDevice</code> Set the current Focus Device and emit a <code>propertyChanged</code> signal. <code>setFocusDirection</code> Set the focus direction of a stage. <code>setGalvoDevice</code> Sets the current galvo device. <code>setGalvoIlluminationState</code> Set the galvo's illumination state to on or off <code>setGalvoPolygonRepetitions</code> Set the number of times to loop galvo polygons <code>setGalvoPosition</code> Set the Galvo to an x,y position. <code>setGalvoSpotInterval</code> Set the SpotInterval for the specified galvo device. <code>setImageProcessorDevice</code> Sets the current image processor device. <code>setMultiROI</code> Set multiple ROIs for the current camera device. <code>setOrigin</code> <code>setOriginX</code> <code>setOriginXY</code> <code>setOriginY</code> <code>setParentLabel</code> Sets parent device label <code>setPixelSizeAffine</code> Sets the raw affine transform for the specific pixel size configuration. <code>setPixelSizeConfig</code> Applies a Pixel Size Configuration. <code>setPixelSizeUm</code> Set pixel size in microns for the specified <code>resolutionID</code>. <code>setPosition</code> Set position of the stage in microns. <code>setPrimaryLogFile</code> <code>setProperty</code> Set property named <code>propName</code> on device <code>label</code> to <code>propValue</code>. <code>setROI</code> Set the camera Region of Interest (ROI). <code>setRelativePosition</code> <code>setRelativeXYPosition</code> <code>setRelativeXYZPosition</code> Sets the relative XYZ position in microns. <code>setSLMDevice</code> Sets the current slm device. <code>setSLMExposure</code> For SLM devices with build-in light source (such as projectors), <code>setSLMImage</code> Write a 32-bit color image to the SLM. <code>setSLMPixelsTo</code> <code>setSerialPortCommand</code> Send string to the serial device and return an answer. <code>setSerialProperties</code> Sets all com port properties in a single call. <code>setShutterDevice</code> the current shutter device. <code>setShutterOpen</code> Open or close the currently selected or <code>shutterLabel</code> shutter. <code>setStageLinearSequence</code> Loads a linear sequence (defined by stepsize and nr. of steps) into the device. <code>setState</code> Set state (by position) on <code>stateDeviceLabel</code>, with reliable event emission. <code>setStateLabel</code> Set state (by label) on <code>stateDeviceLabel</code>, with reliable event emission. <code>setSystemState</code> Sets all properties contained in the Configuration object. <code>setTimeoutMs</code> Sets the timeout for all wait commands. <code>setXYPosition</code> Sets the position of the XY stage in microns. <code>setXYStageDevice</code> Sets the current XY device. <code>setZPosition</code> Set the position of the current focus device in microns. <code>sleep</code> Waits (blocks the calling thread) for specified time in milliseconds. <code>snap</code> Snap and return an image. <code>snapImage</code> Acquires a single image with current settings. <code>startContinuousSequenceAcquisition</code> Start a ContinuousSequenceAcquisition. <code>startExposureSequence</code> Starts an ongoing sequence of triggered exposures in a camera. <code>startPropertySequence</code> Starts an ongoing sequence of triggered events in a property of a device. <code>startSLMSequence</code> Starts the sequence previously uploaded to the SLM <code>startSecondaryLogFile</code> <code>startSequenceAcquisition</code> Starts streaming camera sequence acquisition. <code>startStageSequence</code> Starts an ongoing sequence of triggered events in a stage. <code>startXYStageSequence</code> Starts an ongoing sequence of triggered events in an XY stage. <code>state</code> Return <code>StateDict</code> with commonly accessed state values. <code>stderrLogEnabled</code> Indicates whether logging output goes to stdErr <code>stop</code> Stop the XY or focus/Z stage motors <code>stopExposureSequence</code> Stops an ongoing sequence of triggered exposures in a camera. <code>stopPropertySequence</code> Stops an ongoing sequence of triggered events in a property of a device. <code>stopSLMSequence</code> Stops the SLM sequence if previously started <code>stopSecondaryLogFile</code> Stop capturing logging output into an additional file. <code>stopSequenceAcquisition</code> Stops streaming camera sequence acquisition. <code>stopStageSequence</code> Stops an ongoing sequence of triggered events in a stage. <code>stopXYStageSequence</code> Stops an ongoing sequence of triggered events in an XY stage. <code>supportsDeviceDetection</code> Return whether or not the device supports automatic device detection (i.e. <code>systemBusy</code> Checks the busy status of the entire system. <code>this</code> <code>thisown</code> <code>unloadAllDevices</code> Unload all devices from the core and reset all configuration data. <code>unloadDevice</code> Unloads the device from the core and adjusts all configuration data. <code>unloadLibrary</code> Forcefully unload a library. <code>updateCoreProperties</code> Updates CoreProperties (currently all Core properties are devices types) with <code>updateSystemStateCache</code> Updates the state of the entire hardware. <code>usesDeviceDelay</code> Signals if the device will use the delay setting or not. <code>waitForConfig</code> Blocks until all devices included in the configuration become ready. <code>waitForDevice</code> Waits (blocks the calling thread) until the specified device becomes non-busy. <code>waitForDeviceType</code> Blocks until all devices of the specific type become ready (not-busy). <code>waitForImageSynchro</code> Wait for the slowest device in the ImageSynchro list. <code>waitForSystem</code> Blocks until all devices in the system become ready (not-busy). <code>writeToSerialPort</code> Sends an array of characters to the serial port and returns immediately. <p>Info</p> <p>The <code>pymmcore.CMMCore</code> methods below are available as inherited methods, but are not reimplemented in the <code>CMMCorePlus</code> subclass.  They are documented here for completeness.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.CMMCorePlus","title":"<code>pymmcore_plus.CMMCorePlus</code>","text":"<p>Wrapper for CMMCore with extended functionality.</p> <p>Parameters:</p> Name Type Description Default <code>mm_path</code> <code>str | None, optional</code> <p>Path to the Micro-Manager installation. If <code>None</code> (default), will use the return value of <code>pymmcore_plus.find_micromanager</code>.</p> <code>None</code> <code>adapter_paths</code> <code>Sequence[str], optional</code> <p>Paths to search for device adapters, by default ()</p> <code>()</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.canSequenceEvents","title":"<code>canSequenceEvents(e1: MDAEvent, e2: MDAEvent, cur_length: int = -1) -&gt; bool</code>","text":"<p>Check whether two <code>useq.MDAEvent</code> are sequenceable by this core instance.</p> <p>Micro-manager calls hardware triggering \"sequencing\".  Two events can be sequenced if all device properties that are changing between the first and second event support sequencing.</p> <p>If <code>cur_length</code> is provided, it is used to determine if the sequence is \"full\" (i.e. the sequence is already at the maximum length) as determined by the <code>...SequenceMaxLength()</code> method corresponding to the device property.</p> <p>See: https://micro-manager.org/Hardware-based_Synchronization_in_Micro-Manager</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Parameters:</p> Name Type Description Default <code>e1</code> <code>MDAEvent</code> <p>The first event.</p> required <code>e2</code> <code>MDAEvent</code> <p>The second event.</p> required <code>cur_length</code> <code>int</code> <p>The current length of the sequence.  Used when checking <code>.get&lt;...&gt;SequenceMaxLength</code> for a given property. If the current length is greater than the max length, the events cannot be sequenced. By default -1, which means the current length is not checked.</p> <code>-1</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the events can be sequenced, False otherwise.</p> <p>Examples:</p> <p>Note</p> <p>The results here will depend on the current state of the core and devices.</p> <pre><code>&gt;&gt;&gt; from useq import MDAEvent\n&gt;&gt;&gt; core = CMMCorePlus.instance()\n&gt;&gt;&gt; core.loadSystemConfiguration()\n&gt;&gt;&gt; core.canSequenceEvents(MDAEvent(), MDAEvent())\nTrue\n&gt;&gt;&gt; core.canSequenceEvents(MDAEvent(x_pos=1), MDAEvent(x_pos=2))\nFalse\n&gt;&gt;&gt; core.canSequenceEvents(\n...     MDAEvent(channel={'config': 'DAPI'}),\n...     MDAEvent(channel={'config': 'FITC'})\n... )\nFalse\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.channelGroup_pattern","title":"<code>channelGroup_pattern() -&gt; Pattern</code>  <code>property</code> <code>writable</code>","text":"<p>The regex pattern used to identify channel groups.</p> <p> *This property is new in <code>CMMCorePlus</code>.</p> <p>It is the regex used by <code>getOrGuessChannelGroup</code> to find a config group likely to be a channel group in <code>getAvailableConfigGroups</code> if <code>getChannelGroup</code> returns <code>None</code>.</p> <p>By default:</p> <pre><code>re.compile(\"(chan{1,2}(el)?|filt(er)?)s?\", re.IGNORECASE)\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.defineConfig","title":"<code>defineConfig(groupName: str, configName: str, deviceLabel: str | None = None, propName: str | None = None, value: str | None = None) -&gt; None</code>","text":"<p>Defines a configuration.</p> <p>Why Override? To emit a <code>configDefined</code> event.  Also, if <code>groupName</code> is not a defined group, then <code>defineConfigGroup(groupName)</code> is called.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.definePixelSizeConfig","title":"<code>definePixelSizeConfig(*args: str, **kwargs: str) -&gt; None</code>","text":"<p>Defines an empty pixel size entry.</p> <p>Why Override? To emit a <code>pixelSizeChanged</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.deleteConfig","title":"<code>deleteConfig(groupName: str, configName: str, deviceLabel: str | None = None, propName: str | None = None) -&gt; None</code>","text":"<p>Delete <code>configName</code> from <code>groupName</code>.</p> <p>Why Override? To emit a <code>configDeleted</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.deleteConfigGroup","title":"<code>deleteConfigGroup(group: str) -&gt; None</code>","text":"<p>Deletes an entire configuration <code>group</code>.</p> <p>Why Override? To emit a <code>configGroupDeleted</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.deletePixelSizeConfig","title":"<code>deletePixelSizeConfig(resolutionID: str) -&gt; None</code>","text":"<p>Delete the pixel size configuration for the given <code>resolutionID</code>.</p> <p>Why Override? To emit a <code>pixelSizeChanged</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.describe","title":"<code>describe(sort: str | None = None) -&gt; None</code>","text":"<p>Print information table with the current configuration.</p> <p>Intended to provide a quick overview of the microscope configuration during interactive terminal usage.</p> <p> This method is new in <code>CMMCorePlus</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.detectDevice","title":"<code>detectDevice(deviceLabel: str) -&gt; DeviceDetectionStatus</code>","text":"<p>Tries to communicate to a device through a given serial port.</p> <p>Used to automate discovery of correct serial port. Also configures the serial port correctly.</p> <p>Why Override? The returned <code>pymmcore_plus.DeviceDetectionStatus</code> enum is more interpretable than the raw <code>int</code> returned by <code>pymmcore</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.events","title":"<code>events() -&gt; PCoreSignaler</code>  <code>property</code>","text":"<p>Signaler for core events.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This attribute allows connecting callbacks to various events that occur within the core. See <code>pymmcore_plus.core.events.PCoreSignaler</code> documentation for details of the available signals, and how to connect to them.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.fixImage","title":"<code>fixImage(img: np.ndarray, ncomponents: int | None = None) -&gt; np.ndarray</code>","text":"<p>Fix img shape/dtype based on <code>self.getNumberOfComponents()</code>.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>convert images with n_components &gt; 1 to a shape (w, h, num_components) and dtype <code>img.dtype.itemsize//ncomp</code></p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.ndarray</code> <p>input image</p> required <code>ncomponents</code> <code>int, optional</code> <p>number of components in the image, by default <code>self.getNumberOfComponents()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>output image (possibly new shape and dtype)</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getAdapterObject","title":"<code>getAdapterObject(library_name: str) -&gt; DeviceAdapter</code>","text":"<p>Return an <code>Adapter</code> object bound to library_name on this core.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p><code>Adapter</code> objects are a convenient object oriented way to interact with device adapters. They allow you to call any method on <code>CMMCore</code> that normally requires a <code>library_name</code> as the first argument as an argument-free method on the <code>Adapter</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getCameraChannelNames","title":"<code>getCameraChannelNames() -&gt; tuple[str, ...]</code>","text":"<p>Convenience method to call <code>getCameraChannelName</code> for all camera channels.</p> <p> This method is new in <code>CMMCorePlus</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigData","title":"<code>getConfigData(configGroup: str, configName: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the configuration object for a given <code>configGroup</code> and <code>configName</code>.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigGroupObject","title":"<code>getConfigGroupObject(group_name: str, allow_missing: bool = False) -&gt; ConfigGroup</code>","text":"<p>Return a <code>ConfigGroup</code> object bound to group_name on this core.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p><code>ConfigGroup</code> objects are a convenient object oriented way to interact with configuration groups (i.e. groups of Configuration Presets in Micro-Manager). They allow you to call any method on <code>CMMCore</code> that normally requires a <code>groupName</code> as the first argument as an argument-free method on the <code>ConfigGroup</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>Configuration group name to get a config group object for.</p> required <code>allow_missing</code> <code>bool</code> <p>If <code>False</code> and the <code>ConfigGroup</code> does not exist, a <code>KeyError</code> will be raised. By default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ConfigGroup</code> <p><code>ConfigGroup</code> object bound to <code>group_name</code> on this core.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigGroupState","title":"<code>getConfigGroupState(group: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the state of the devices included in the specified <code>group</code>.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigGroupStateFromCache","title":"<code>getConfigGroupStateFromCache(group: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the state of the system cache, for the devices in the specified group.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getConfigState","title":"<code>getConfigState(group: str, config: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return state of devices included in the specified configuration.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getDeviceObject","title":"<code>getDeviceObject(device_label: str) -&gt; Device</code>","text":"<p>Return a <code>Device</code> object bound to device_label on this core.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p><code>Device</code> objects are a convenient object oriented way to interact with devices. They allow you to call any method on <code>CMMCore</code> that normally requires a <code>deviceLabel</code> as the first argument as an argument-free method on the <code>Device</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>device_label</code> <code>str</code> <p>Device label to get a device object for.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; cam = core.getDeviceObject(\"DemoCamera\")\n&gt;&gt;&gt; cam.isLoaded()\nFalse\n&gt;&gt;&gt; cam.load(\"DemoCamera\", \"DCam\")\n&gt;&gt;&gt; cam.isLoaded()\nTrue\n&gt;&gt;&gt; cam.initialize()\n</code></pre> <p>get the device schema</p> <pre><code>&gt;&gt;&gt; cam.schema()\n{\n    'title': 'DCam',\n    'description': 'Demo camera',\n    'type': 'object',\n    'properties': {\n        'HubID': {'type': 'string', 'readOnly': True, 'default': ''},\n        'MaximumExposureMs': {'type': 'number', 'preInit': True},\n        'TransposeCorrection': {'type': 'boolean'},\n        'TransposeMirrorX': {'type': 'boolean'},\n        'TransposeMirrorY': {'type': 'boolean'},\n        'TransposeXY': {'type': 'boolean'}\n    }\n}\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getDeviceSchema","title":"<code>getDeviceSchema(device_label: str) -&gt; DeviceSchema</code>","text":"<p>Return JSON-schema describing device <code>device_label</code> and its properties.</p> <p> This method is new in <code>CMMCorePlus</code>. It provides a convenient way to get all of the information about a device in a single call.</p> <p>Returns:</p> Type Description <code>DeviceSchema</code> <p>JSON-schema describing device <code>device_label</code> and its properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; core.loadDevice(\"DemoCamera\", \"DemoCamera\", \"DCam\")\n&gt;&gt;&gt; core.getDeviceSchema(\"DemoCamera\")\n{\n    'title': 'DCam',\n    'description': 'Demo camera',\n    'type': 'object',\n    'properties': {\n        'HubID': {'type': 'string', 'readOnly': True, 'default': ''},\n        'MaximumExposureMs': {'type': 'number', 'preInit': True},\n        'TransposeCorrection': {'type': 'boolean'},\n        'TransposeMirrorX': {'type': 'boolean'},\n        'TransposeMirrorY': {'type': 'boolean'},\n        'TransposeXY': {'type': 'boolean'}\n    }\n}\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getDeviceType","title":"<code>getDeviceType(label: str) -&gt; DeviceType</code>","text":"<p>Return device type for a given device.</p> <p>Why Override? The returned <code>pymmcore_plus.Device</code> enum is more interpretable than the raw <code>int</code> returned by <code>pymmcore</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getImage","title":"<code>getImage(numChannel: int | None = None, *, fix: bool = True) -&gt; np.ndarray</code>","text":"<p>Return the internal image buffer.</p> <p>Why Override? To fix the shape of images with n_components &gt; 1 (like RGB images)</p> <p>Parameters:</p> Name Type Description Default <code>numChannel</code> <code>int, optional</code> <p>The camera channel to get the image from.  If None, (the default), then Multi-Channel cameras will return the content of the first channel.</p> <code>None</code> <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getLastImageAndMD","title":"<code>getLastImageAndMD(channel: int | None = None, slice: int | None = None, *, fix: bool = True) -&gt; tuple[np.ndarray, Metadata]</code>","text":"<p>Return last image from the circular buffer along with metadata.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This is a convenience method that is very similar to <code>getLastImageMD</code>, except that it doesn't require instantiating a <code>MetaData</code> object first. It returns a tuple containing the image and a <code>pymmcore_plus.Metadata</code> object.</p> <p>It also adds a <code>fix</code> parameter, which reshapes multi-component images (like RGB images) to (w, h, n_components) using <code>fixImage</code> by default.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int, optional</code> <p>Channel index, by default None</p> <code>None</code> <code>slice</code> <code>int, optional</code> <p>Slice index, by default None</p> <code>None</code> <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[np.ndarray, Metadata]</code> <p>Image and metadata</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getMultiROI","title":"<code>getMultiROI(*_: Any) -&gt; tuple[list[int], list[int], list[int], list[int]]</code>","text":"<p>Get multiple ROIs from the current camera device.</p> <p>Will fail if the camera does not support multiple ROIs. Will return empty vectors if multiple ROIs are not currently being used.</p> <p>Why Override? So that the user doesn't need to pass in four empty pymmcore.UnsignedVector() objects.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getNBeforeLastImageAndMD","title":"<code>getNBeforeLastImageAndMD(n: int, *, fix: bool = True) -&gt; tuple[np.ndarray, Metadata]</code>","text":"<p>Return image taken <code>n</code> images ago along with associated metadata.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This is a convenience method that is very similar to <code>getNBeforeLastImageMD</code>, except that it doesn't require instantiating a <code>MetaData</code> object first. It returns a tuple containing the image and a <code>pymmcore_plus.Metadata</code> object.</p> <p>It also adds a <code>fix</code> parameter, which reshapes multi-component images (like RGB images) to (w, h, n_components) using <code>fixImage</code> by default.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of images ago to retrieve. 0 is the last image, 1 is the image before that, etc.</p> required <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getOrGuessChannelGroup","title":"<code>getOrGuessChannelGroup() -&gt; list[str]</code>","text":"<p>Get the channelGroup or find a likely set of candidates.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>If the group is not defined via <code>.getChannelGroup</code> then likely candidates will be found by searching for config groups with names that match this object's <code>channelGroup_pattern</code> property. This is a settable property with a default value of:</p> <pre><code>reg = re.compile(\"(chan{1,2}(el)?|filt(er)?)s?\", re.IGNORECASE)\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getPixelSizeConfigData","title":"<code>getPixelSizeConfigData(configName: str, *, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the configuration object for a given pixel size preset <code>configName</code>.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getPropertyObject","title":"<code>getPropertyObject(device_label: str, property_name: str) -&gt; DeviceProperty</code>","text":"<p>Return a DeviceProperty object bound to a device/property on this core.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p><code>DeviceProperty</code> objects are a convenient object oriented way to interact with a specific device properties. They allow you to call any method on <code>CMMCore</code> that normally requires a <code>deviceLabel</code> and <code>propertyName</code> as the first two arguments as an argument-free method on the <code>DeviceProperty</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>device_label</code> <code>str</code> <p>Device label to get a property object for.</p> required <code>property_name</code> <code>str</code> <p>Property name to get a property object for.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; core.loadDevice(\"DemoCamera\", \"DemoCamera\", \"DCam\")\n&gt;&gt;&gt; core.initializeDevice(\"DemoCamera\")\n&gt;&gt;&gt; core.setCameraDevice(\"DemoCamera\")\n&gt;&gt;&gt; exposure = core.getPropertyObject(\"DemoCamera\", \"Exposure\")\n&gt;&gt;&gt; exposure.type()\n&lt;PropertyType.Float: 2&gt;\n&gt;&gt;&gt; exposure.upperLimit()\n10000.0\n</code></pre> <p>get/set property values easily:</p> <pre><code>&gt;&gt;&gt; exposure.value\n10.0\n&gt;&gt;&gt; exposure.value = 5.0\n&gt;&gt;&gt; exposure.value\n5.0\n&gt;&gt;&gt; core.getExposure()  # changes reflected in core\n5.0\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getPropertyType","title":"<code>getPropertyType(label: str, propName: str) -&gt; PropertyType</code>","text":"<p>Return the intrinsic property type for a given device and property.</p> <p>Why Override? The returned <code>pymmcore_plus.PropertyType</code> enum is more interpretable than the raw <code>int</code> returned by <code>pymmcore</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getSystemState","title":"<code>getSystemState(*, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the entire system state.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getSystemStateCache","title":"<code>getSystemStateCache(*, native: bool = False) -&gt; Configuration | pymmcore.Configuration</code>","text":"<p>Return the entire system state from cache.</p> <p>Why Override? The <code>pymmcore_plus.Configuration</code> object returned when <code>native=False</code> (the default) provides a nicer <code>Mapping</code> interface. Pass <code>native=True</code> to get the original <code>pymmcore.Configuration</code> object.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getTaggedImage","title":"<code>getTaggedImage(channel_index: int = 0) -&gt; TaggedImage</code>","text":"<p>Return getImage as named tuple with metadata.</p> <p> This method is new in <code>CMMCorePlus</code>. It returns an object similar to MMCoreJ.getTaggedImage().</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getTags","title":"<code>getTags(meta: Metadata | None = None, channel_index: int | None = None) -&gt; dict[str, Any]</code>","text":"<p>Return a dict of metadata tags for the state of the core.</p> <p>NOTE: this function is pretty slow, and is potentially called on every frame of an acquisition. It would be nice to determine what is absolutely necessary, and possible allow the user to specify what they want to include.</p> <p> This method is new in <code>CMMCorePlus</code>. It returns only the <code>.tags</code> attribute of what you would get with <code>getTaggedImage()</code> or <code>popNextTaggedImage()</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.getZPosition","title":"<code>getZPosition() -&gt; float</code>","text":"<p>Obtains the current position of the Z axis of the Z stage in microns.</p> <p> This method is new in <code>CMMCorePlus</code>: added to complement <code>getXPosition</code> and <code>getYPosition</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.guessObjectiveDevices","title":"<code>guessObjectiveDevices() -&gt; list[str]</code>","text":"<p>Find any loaded devices that are likely to be an Objective/Nosepiece.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Likely matches are loaded StateDevices with names that match this object's <code>objective_device_pattern</code> property. This is a settable property with a default value of::</p> <pre><code>re.compile(\"(.+)?(nosepiece|obj(ective)?)(turret)?s?\", re.IGNORECASE)\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.instance","title":"<code>instance() -&gt; CMMCorePlus</code>  <code>classmethod</code>","text":"<p>Return the global singleton instance of <code>CMMCorePlus</code>.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>In many cases, a single instance of <code>CMMCorePlus</code> is all that will be created in a given session.  This class method provides a convenient way to access that instance.</p> <p>Tip</p> <p>Creating/accessing a <code>CMMCorePlus</code> object using <code>CMMCorePlus.instance()</code> is a convenient way to access the same core instance from multiple places in your code. All widgets in <code>pymmcore-widgets</code> also use <code>CMMCorePlus.instance()</code> by default, so any widgets you use will automatically connect to the same core instance without any additional configuration.</p> <p>Attempts are made to make it thread-safe.  But please open an issue if you find any problems.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.iterConfigGroups","title":"<code>iterConfigGroups() -&gt; Iterator[ConfigGroup]</code>","text":"<p>Iterate <code>ConfigGroup</code> objects for all configs.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Yields:</p> Type Description <code>ConfigGroup</code> <p><code>ConfigGroup</code> objects</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.iterDeviceAdapters","title":"<code>iterDeviceAdapters(adapter_pattern: str | re.Pattern | None = None, *, as_object: bool = True) -&gt; Iterator[DeviceAdapter] | Iterator[str]</code>","text":"<p>Iterate over all available device adapters.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>It offers a convenient way to iterate over available device adaptor libraries, optionally filtering adapter library name. It can also yield <code>Adapter</code> objects if <code>as_object</code> is <code>True</code> (the default)</p> <p>Parameters:</p> Name Type Description Default <code>adapter_pattern</code> <code>str | None</code> <p>Device adapter name or pattern to filter by, by default all device adapters will be yielded.</p> <code>None</code> <code>as_object</code> <code>bool, optional</code> <p>If <code>True</code>, <code>Adapter</code> objects will be yielded instead of library name strings. By default True</p> <code>True</code> <p>Yields:</p> Type Description <code>Device | str</code> <p><code>Device</code> objects (if <code>as_object==True</code>) or device label strings.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.iterDevices","title":"<code>iterDevices(device_type: int | Iterable[int] | None = None, device_label: str | re.Pattern | None = None, device_adapter: str | re.Pattern | None = None, *, as_object: bool = True) -&gt; Iterator[Device] | Iterator[str]</code>","text":"<p>Iterate over currently loaded devices.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>It offers a convenient way to iterate over loaded devices, optionally filtering by <code>DeviceType</code> and/or device label. It can also yield <code>Device</code> objects if <code>as_object</code> is <code>True</code> (the default).</p> <p>Parameters:</p> Name Type Description Default <code>device_type</code> <code>DeviceType | None</code> <p>DeviceType to filter by, by default all device types will be yielded.</p> <code>None</code> <code>device_label</code> <code>str | None</code> <p>Device label to filter by, by default all device labels will be yielded.</p> <code>None</code> <code>device_adapter</code> <code>str | None</code> <p>Device adapter library to filter by, by default devices from all libraries will be yielded.</p> <code>None</code> <code>as_object</code> <code>bool, optional</code> <p>If <code>True</code>, <code>Device</code> objects will be yielded instead of device label strings. By default True</p> <code>True</code> <p>Yields:</p> Type Description <code>Device | str</code> <p><code>Device</code> objects (if <code>as_object==True</code>) or device label strings.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.iterProperties","title":"<code>iterProperties(property_type: int | Iterable[int] | None = None, property_name_pattern: str | re.Pattern | None = None, *, device_type: int | Iterable[int] | None = None, device_label: str | re.Pattern | None = None, has_limits: bool | None = None, is_read_only: bool | None = None, is_sequenceable: bool | None = None, as_object: bool = True) -&gt; Iterator[DeviceProperty] | Iterator[tuple[str, str]]</code>","text":"<p>Iterate over currently loaded (device_label, property_name) pairs.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>It offers a convenient way to iterate over loaded devices, optionally filtering by <code>DeviceType</code> and/or device label. It can also yields <code>DeviceProperty</code> objects if <code>as_object</code> is <code>True</code> (the default).</p> <p>Parameters:</p> Name Type Description Default <code>property_type</code> <code>int | Sequence[int] | None</code> <p>PropertyType (or types) to filter by, by default all property types will be yielded.</p> <code>None</code> <code>property_name_pattern</code> <code>str | re.Pattern | None</code> <p>Property name to filter by, by default all property names will be yielded. May be a compiled regular expression or a string, in which case it will be compiled with <code>re.IGNORECASE</code>.</p> <code>None</code> <code>device_type</code> <code>DeviceType | None</code> <p>DeviceType to filter by, by default all device types will be yielded.</p> <code>None</code> <code>device_label</code> <code>str | None</code> <p>Device label to filter by, by default all device labels will be yielded.</p> <code>None</code> <code>has_limits</code> <code>bool | None</code> <p>If provided, only properties with <code>hasPropertyLimits</code> matching this value will be yielded.</p> <code>None</code> <code>is_read_only</code> <code>bool | None</code> <p>If provided, only properties with <code>isPropertyReadOnly</code> matching this value will be yielded.</p> <code>None</code> <code>is_sequenceable</code> <code>bool | None</code> <p>If provided only properties with <code>isPropertySequenceable</code> matching this value will be yielded.</p> <code>None</code> <code>as_object</code> <code>bool, optional</code> <p>If <code>True</code>, <code>DeviceProperty</code> objects will be yielded instead of <code>(device_label, property_name)</code> tuples. By default True</p> <code>True</code> <p>Yields:</p> Type Description <code>DeviceProperty | tuple[str, str]</code> <p><code>DeviceProperty</code> objects (if <code>as_object==True</code>) or 2-tuples of (device_name, property_name)</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.loadDevice","title":"<code>loadDevice(label: str, moduleName: str, deviceName: str) -&gt; None</code>","text":"<p>Load a device from the plugin library.</p> <p>Why Override? To add much better error messages in the case of failure.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Name to be assigned to the device during this core session.</p> required <code>moduleName</code> <code>str</code> <p>The name of the device adapter module (short name, not full file name). See <code>pymmcore.CMMCore.getDeviceAdapterNames</code> for a list of valid module names.</p> required <code>deviceName</code> <code>str</code> <p>the name of the device. The name must correspond to one of the names recognized by the specific plugin library. See <code>pymmcore.CMMCore.getAvailableDevices</code> for a list of valid device names.</p> required"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.loadSystemConfiguration","title":"<code>loadSystemConfiguration(fileName: str | Path = 'MMConfig_demo.cfg') -&gt; None</code>","text":"<p>Load a system config file conforming to the MM <code>.cfg</code> format.</p> <p>https://micro-manager.org/Micro-Manager_Configuration_Guide#configuration-file-syntax</p> <p>For relative paths, the current working directory is first checked, then the then device adapter path is checked.</p> <p>Why Override? This method overrides the default implementation to A) allow loading the <code>MMConfig_demo.cfg</code> file by default, B) to provide more flexible path declarations and C) better error messages when the file cannot be found.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.mda","title":"<code>mda() -&gt; MDARunner</code>  <code>property</code>","text":"<p>Return the <code>MDARunner</code> for this <code>CMMCorePlus</code> instance.</p> <p> This method is new in <code>CMMCorePlus</code>.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.objective_device_pattern","title":"<code>objective_device_pattern() -&gt; Pattern</code>  <code>property</code> <code>writable</code>","text":"<p>Pattern used to guess objective device labels.</p> <p> *This property is new in <code>CMMCorePlus</code>.</p> <p>It is the regex used by <code>guessObjectiveDevices</code> to find any devices that are likely to be objective devices.</p> <p>By default:</p> <pre><code>re.compile(\"(.+)?(nosepiece|obj(ective)?)(turret)?s?\", re.IGNORECASE)\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.popNextImage","title":"<code>popNextImage(*, fix: bool = True) -&gt; np.ndarray</code>","text":"<p>Gets and removes the next image from the circular buffer.</p> <p>Why Override? to add the <code>fix</code> parameter, which reshapes multi-component images (like RGB images) to (w, h, n_components) using <code>fixImage</code> by default.</p> <p>Parameters:</p> Name Type Description Default <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.popNextImageAndMD","title":"<code>popNextImageAndMD(channel: int | None = None, slice: int | None = None, *, fix: bool = True) -&gt; tuple[np.ndarray, Metadata]</code>","text":"<p>Gets and removes the next image (and metadata) from the circular buffer.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This is a convenience method that is very similar to <code>popNextImageMD</code>, except that it doesn't require instantiating a <code>MetaData</code> object first. It returns a tuple containing the image and a <code>pymmcore_plus.Metadata</code> object.</p> <p>It also adds a <code>fix</code> parameter, which reshapes multi-component images (like RGB images) to (w, h, n_components) using <code>fixImage</code> by default.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int, optional</code> <p>Channel index, by default None</p> <code>None</code> <code>slice</code> <code>int, optional</code> <p>Slice index, by default None</p> <code>None</code> <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[np.ndarray, Metadata]</code> <p>Image and metadata</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.popNextTaggedImage","title":"<code>popNextTaggedImage(channel_index: int = 0) -&gt; TaggedImage</code>","text":"<p>Return popNextImageAndMD as named tuple with metadata.</p> <p> This method is new in <code>CMMCorePlus</code>. It returns an object similar to MMCoreJ.popNextTaggedImage().</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.register_mda_engine","title":"<code>register_mda_engine(engine: PMDAEngine) -&gt; None</code>","text":"<p>Set the MDA Engine to be used on <code>run_mda</code>.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This will unregister the previous engine and emit an <code>mdaEngineRegistered</code> signal. The current Engine must not be running an MDA in order to register a new engine.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>PMDAEngine</code> <p>Any object conforming to the PMDAEngine protocol.</p> required"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.run_mda","title":"<code>run_mda(events: Iterable[MDAEvent], block: bool = False) -&gt; Thread</code>","text":"<p>Run a sequence of useq.MDAEvent on a new thread.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>The currently registered MDAEngine (<code>core.mda.engine</code>) will be responsible for executing the acquisition.</p> <p>After starting the sequence you can pause or cancel with the mda with the mda object's <code>toggle_pause</code> and <code>cancel</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>Iterable[useq.MDAEvent]</code> <p>An iterable of useq.MDAEvent to execute.  This may be an instance of useq.MDASequence, or any other iterable of useq.MDAEvent.</p> required <code>block</code> <code>bool, optional</code> <p>If True, block until the sequence is complete, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Thread</code> <p>The thread the sequence is running on.  Use <code>thread.join()</code> to block until done, or <code>thread.is_alive()</code> to check if the sequence is complete.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.saveSystemConfiguration","title":"<code>saveSystemConfiguration(filename: str) -&gt; None</code>","text":"<p>Saves the current system configuration to a text file.</p> <p>Why Override? To also save pixel size configurations.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setAutoShutter","title":"<code>setAutoShutter(state: bool) -&gt; None</code>","text":"<p>Set shutter to automatically open and close when an image is acquired.</p> <p>Why Override? To emit an <code>autoShutterSet</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setChannelGroup","title":"<code>setChannelGroup(channelGroup: str) -&gt; None</code>","text":"<p>Specifies the group determining the channel selection.</p> <p>...and send a channelGroupChanged signal.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setConfig","title":"<code>setConfig(groupName: str, configName: str) -&gt; None</code>","text":"<p>Applies a configuration to a group.</p> <p>Why Override? The native <code>onConfigGroupChanged</code> callback is not always called whenever <code>CMMCore.setConfig</code> has been called. We override here to emit a <code>configSet</code> event whenever <code>setConfig</code> is called. See https://github.com/micro-manager/mmCoreAndDevices/issues/25 for details.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setContext","title":"<code>setContext(**kwargs: Any) -&gt; Iterator[None]</code>","text":"<p>Set core properties in a context restoring the initial values on exit.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments may be any <code>Name</code> for which <code>get&lt;Name&gt;</code> and <code>set&lt;Name&gt;</code> methods exist.  For example, <code>setContext(exposure=10)</code> will call <code>setExposure(10)</code> when entering the context and <code>setExposure(&lt;initial&gt;)</code> when exiting the context.</p> <code>{}</code> <p>Examples:</p> <pre><code>core = CMMCorePlus.instance()\n\nwith core.setContext(autoShutter=False):\n    assert not core.getAutoShutter()\n    # do other stuff\n    ...\n\n# autoShutter is restored to its original value when the context exits\nassert core.getAutoShutter()\n</code></pre>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setDeviceAdapterSearchPaths","title":"<code>setDeviceAdapterSearchPaths(paths: Sequence[str]) -&gt; None</code>","text":"<p>Set the device adapter search paths.</p> <p>Why Override?  In cases where MM device adapters use dynamically loaded libraries, the device adapter search paths must also be added to the <code>PATH</code> environment variable (e.g. https://github.com/micro-manager/pymmcore/issues/28). This method overrides the default implementation to ensure that the <code>PATH</code> environment variable is updated when the device adapter search paths are changed.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setFocusDevice","title":"<code>setFocusDevice(focusLabel: str) -&gt; None</code>","text":"<p>Set the current Focus Device and emit a <code>propertyChanged</code> signal.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setPixelSizeUm","title":"<code>setPixelSizeUm(resolutionID: str, pixSize: float) -&gt; None</code>","text":"<p>Set pixel size in microns for the specified <code>resolutionID</code>.</p> <p>Why Override? To emit a <code>pixelSizeChanged</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setPosition","title":"<code>setPosition(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Set position of the stage in microns.</p> <p>Why Override? To add a lock to prevent concurrent calls across threads.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setProperty","title":"<code>setProperty(label: str, propName: str, propValue: bool | float | int | str) -&gt; None</code>","text":"<p>Set property named <code>propName</code> on device <code>label</code> to <code>propValue</code>.</p> <p>Why Override?  In <code>MMCore</code>, the calling of the <code>onPropertyChanged</code> callback is left to the underlying device adapter, which means it is not always called.  This method overrides the default implementation to ensure that <code>events.propertyChanged</code> is always emitted when <code>setProperty</code> has been called and the property Value has actually changed.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setROI","title":"<code>setROI(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Set the camera Region of Interest (ROI).</p> <p>Why Override? To emit a <code>roiSet</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setRelativeXYZPosition","title":"<code>setRelativeXYZPosition(dx: float = 0, dy: float = 0, dz: float = 0) -&gt; None</code>","text":"<p>Sets the relative XYZ position in microns.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>This is a convenience method that calls <code>setXYPosition</code> and <code>setZPosition</code> with the current position as the starting point.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>float, optional</code> <p>The relative change in X position, by default 0</p> <code>0</code> <code>dy</code> <code>float, optional</code> <p>The relative change in Y position, by default 0</p> <code>0</code> <code>dz</code> <code>float, optional</code> <p>The relative change in Z position, by default 0</p> <code>0</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setShutterOpen","title":"<code>setShutterOpen(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Open or close the currently selected or <code>shutterLabel</code> shutter.</p> <p>Why Override? To emit a <code>propertyChanged</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setState","title":"<code>setState(stateDeviceLabel: str, state: int) -&gt; None</code>","text":"<p>Set state (by position) on <code>stateDeviceLabel</code>, with reliable event emission.</p> <p>Why Override?  In <code>MMCore</code>, the calling of the <code>onPropertyChanged</code> callback is left to the underlying device adapter, which means it is not always called.  This method overrides the default implementation to ensure that <code>events.propertyChanged</code> is always emitted when <code>setProperty</code> has been called and the property Value has actually changed.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setStateLabel","title":"<code>setStateLabel(stateDeviceLabel: str, stateLabel: str) -&gt; None</code>","text":"<p>Set state (by label) on <code>stateDeviceLabel</code>, with reliable event emission.</p> <p>Why Override?  In <code>MMCore</code>, the calling of the <code>onPropertyChanged</code> callback is left to the underlying device adapter, which means it is not always called.  This method overrides the default implementation to ensure that <code>events.propertyChanged</code> is always emitted when <code>setProperty</code> has been called and the property Value has actually changed.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setXYPosition","title":"<code>setXYPosition(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Sets the position of the XY stage in microns.</p> <p>Why Override? To add a lock to prevent concurrent calls across threads.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.setZPosition","title":"<code>setZPosition(val: float) -&gt; None</code>","text":"<p>Set the position of the current focus device in microns.</p> <p> This method is new in <code>CMMCorePlus</code>: added to complement <code>setXYPosition</code></p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.snap","title":"<code>snap(numChannel: int | None = None, *, fix: bool = True) -&gt; np.ndarray</code>","text":"<p>Snap and return an image.</p> <p> This method is new in <code>CMMCorePlus</code>.</p> <p>Convenience for calling <code>self.snapImage()</code> followed by returning the value of <code>self.getImage()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>numChannel</code> <code>int, optional</code> <p>The camera channel to get the image from.  If None, (the default), then Multi-Channel cameras will return the content of the first channel.</p> <code>None</code> <code>fix</code> <code>bool, default</code> <p>If <code>True</code> (the default), then images with n_components &gt; 1 (like RGB images) will be reshaped to (w, h, n_components) using <code>fixImage</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>img</code> <code>np.ndarray</code>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.snapImage","title":"<code>snapImage() -&gt; None</code>","text":"<p>Acquires a single image with current settings.</p> <p>Why Override? To add a lock to prevent concurrent calls across threads.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.startContinuousSequenceAcquisition","title":"<code>startContinuousSequenceAcquisition(intervalMs: float = 0) -&gt; None</code>","text":"<p>Start a ContinuousSequenceAcquisition.</p> <p>Why Override? To emit a <code>startContinuousSequenceAcquisition</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.startSequenceAcquisition","title":"<code>startSequenceAcquisition(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Starts streaming camera sequence acquisition.</p> <p>This command does not block the calling thread for the duration of the acquisition.</p> <p>Why Override? To emit a <code>startSequenceAcquisition</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.state","title":"<code>state(exclude: Iterable[str] = ()) -&gt; StateDict</code>","text":"<p>Return <code>StateDict</code> with commonly accessed state values.</p> <p> This method is new in <code>CMMCorePlus</code>. It is a bit faster than <code>getSystemState</code>.</p> <p>Parameters:</p> Name Type Description Default <code>exclude</code> <code>Iterable[str]</code> <p>List of properties to exclude when gathering state (may speed things up). See <code>StateDict</code> for a list of keys that can be excluded.</p> <code>()</code> <p>Returns:</p> Type Description <code>StateDict</code> <p>A dictionary of commonly accessed state values.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.stopSequenceAcquisition","title":"<code>stopSequenceAcquisition(cameraLabel: str | None = None) -&gt; None</code>","text":"<p>Stops streaming camera sequence acquisition.</p> <p>(for a specified camera if <code>cameraLabel</code> is provided.)</p> <p>Why Override? To emit a <code>stopSequenceAcquisition</code> event.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.CMMCorePlus.unloadAllDevices","title":"<code>unloadAllDevices() -&gt; None</code>","text":"<p>Unload all devices from the core and reset all configuration data.</p> <p>Why Override? To add logging.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore","title":"<code>pymmcore.CMMCore</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.addGalvoPolygonVertex","title":"<code>addGalvoPolygonVertex(galvoLabel: str, polygonIndex: int, x: float, y: float) -&gt; None</code>","text":"<p>Add a vertex to a galvo polygon.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.addSearchPath","title":"<code>addSearchPath(path: str) -&gt; None</code>","text":"<p>Add a list of paths to the legacy device adapter search path list.</p> <p>Do not use in new code. This adds to a global (static) fallback list that is only searched when a device adapter is not located in any of the directories set by setDeviceAdapterSearchPaths(). The list is initially empty.</p> <p>Deprecated</p> <p>Use the non-static <code>setDeviceAdapterSearchPaths()</code> instead.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.assignImageSynchro","title":"<code>assignImageSynchro(deviceLabel: str) -&gt; None</code>","text":"<p>Add device to the image-synchro list.</p> <p>Deprecated</p> <p>ImageSynchro will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.clearCircularBuffer","title":"<code>clearCircularBuffer() -&gt; None</code>","text":"<p>Removes all images from the circular buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.clearROI","title":"<code>clearROI() -&gt; None</code>","text":"<p>Set the region of interest of the current camera to the full frame.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.debugLogEnabled","title":"<code>debugLogEnabled() -&gt; bool</code>","text":"<p>Indicates if logging of debug messages is enabled</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.defineConfigGroup","title":"<code>defineConfigGroup(groupName: str) -&gt; None</code>","text":"<p>Creates an empty configuration group.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.definePropertyBlock","title":"<code>definePropertyBlock(blockName: str, propertyName: str, propertyValue: str) -&gt; None</code>","text":"<p>Defines a reference for the collection of property-value pairs.</p> <p>Deprecated</p> <p>Property blocks will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.defineStateLabel","title":"<code>defineStateLabel(stateDeviceLabel: str, state: int, stateLabel: str) -&gt; None</code>","text":"<p>Defines a label for the specific state.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.deleteGalvoPolygons","title":"<code>deleteGalvoPolygons(galvoLabel: str) -&gt; None</code>","text":"<p>Remove all added polygons</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.deviceBusy","title":"<code>deviceBusy(label: str) -&gt; bool</code>","text":"<p>Checks the busy status of the specific device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.deviceTypeBusy","title":"<code>deviceTypeBusy(devType: DeviceType) -&gt; bool</code>","text":"<p>Checks the busy status for all devices of the specific type.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.displaySLMImage","title":"<code>displaySLMImage(slmLabel: str) -&gt; None</code>","text":"<p>Display the waiting image on the SLM.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.enableContinuousFocus","title":"<code>enableContinuousFocus(enable: bool) -&gt; None</code>","text":"<p>Enables or disables the operation of the continuous focusing hardware device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.enableDebugLog","title":"<code>enableDebugLog(enable: bool) -&gt; None</code>","text":"<p>Enable or disable logging of debug messages.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.enableStderrLog","title":"<code>enableStderrLog(enable: bool) -&gt; None</code>","text":"<p>Enables or disables log message display on the standard console.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.fullFocus","title":"<code>fullFocus() -&gt; None</code>","text":"<p>Performs focus acquisition and lock for the one-shot focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAPIVersionInfo","title":"<code>getAPIVersionInfo() -&gt; str</code>","text":"<p>Returns the module and device interface versions.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAllowedPropertyValues","title":"<code>getAllowedPropertyValues(label: str, propName: str) -&gt; Tuple[str, ...]</code>","text":"<p>Returns all valid values for the specified property.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAutoFocusDevice","title":"<code>getAutoFocusDevice() -&gt; str</code>","text":"<p>Returns the label of the currently selected auto-focus device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAutoFocusOffset","title":"<code>getAutoFocusOffset() -&gt; float</code>","text":"<p>Measures offset for the one-shot focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAutoShutter","title":"<code>getAutoShutter() -&gt; bool</code>","text":"<p>Returns the current setting of the auto-shutter option.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableConfigGroups","title":"<code>getAvailableConfigGroups() -&gt; Tuple[str, ...]</code>","text":"<p>Returns the names of all defined configuration groups</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableConfigs","title":"<code>getAvailableConfigs(configGroup: str) -&gt; Tuple[str, ...]</code>","text":"<p>Returns all defined configuration names in a given group</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableDeviceDescriptions","title":"<code>getAvailableDeviceDescriptions(library: str) -&gt; Tuple[str, ...]</code>","text":"<p>Get descriptions for available devices from the specified library.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableDeviceTypes","title":"<code>getAvailableDeviceTypes(library: str) -&gt; Tuple[int, ...]</code>","text":"<p>Get type information for available devices from the specified library.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailableDevices","title":"<code>getAvailableDevices(library: str) -&gt; Tuple[str, ...]</code>","text":"<p>Get available devices from the specified device library.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailablePixelSizeConfigs","title":"<code>getAvailablePixelSizeConfigs() -&gt; Tuple[str, ...]</code>","text":"<p>Returns all defined resolution preset names</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getAvailablePropertyBlocks","title":"<code>getAvailablePropertyBlocks() -&gt; Tuple[str, ...]</code>","text":"<p>Returns all defined property block identifiers.</p> <p>Deprecated</p> <p>Property blocks will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getBufferFreeCapacity","title":"<code>getBufferFreeCapacity() -&gt; int</code>","text":"<p>Returns the number of images that can be added to the buffer without overflowing.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getBufferTotalCapacity","title":"<code>getBufferTotalCapacity() -&gt; int</code>","text":"<p>Returns the total number of images that can be stored in the buffer</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getBytesPerPixel","title":"<code>getBytesPerPixel() -&gt; int</code>","text":"<p>How many bytes for each pixel.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCameraChannelName","title":"<code>getCameraChannelName(channelNr: int) -&gt; str</code>","text":"<p>Returns the name of the requested channel as known by the default camera</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCameraDevice","title":"<code>getCameraDevice() -&gt; str</code>","text":"<p>Returns the label of the currently selected camera device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getChannelGroup","title":"<code>getChannelGroup() -&gt; str</code>","text":"<p>Returns the group determining the channel selection.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCircularBufferMemoryFootprint","title":"<code>getCircularBufferMemoryFootprint() -&gt; int</code>","text":"<p>Returns the size of the Circular Buffer in MB</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCoreErrorText","title":"<code>getCoreErrorText(code: int) -&gt; str</code>","text":"<p>Returns a pre-defined error test with the given error code</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCurrentConfig","title":"<code>getCurrentConfig(groupName: str) -&gt; str</code>","text":"<p>Returns the current configuration for a given group.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCurrentConfigFromCache","title":"<code>getCurrentConfigFromCache(groupName: str) -&gt; str</code>","text":"<p>Returns the configuration for a given group based on the data in the cache.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getCurrentFocusScore","title":"<code>getCurrentFocusScore() -&gt; float</code>","text":"<p>Returns the focus score from the default focusing device measured at the current Z position.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getData","title":"<code>getData(stateDeviceLabel: str) -&gt; PropertyBlock</code>","text":"<p>Returns the collection of property-value pairs defined for the current state.</p> <p>Deprecated</p> <p>Property blocks will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceAdapterNames","title":"<code>getDeviceAdapterNames() -&gt; Tuple[str, ...]</code>","text":"<p>Return the names of discoverable device adapters.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceAdapterSearchPaths","title":"<code>getDeviceAdapterSearchPaths() -&gt; Tuple[str, ...]</code>","text":"<p>Return the current device adapter search paths.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceDelayMs","title":"<code>getDeviceDelayMs(label: str) -&gt; float</code>","text":"<p>Reports action delay in milliseconds for the specific device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceDescription","title":"<code>getDeviceDescription(label: str) -&gt; str</code>","text":"<p>Returns description text for a given device label. \"Description\" is determined by the library and is immutable.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceLibraries","title":"<code>getDeviceLibraries() -&gt; Tuple[str]</code>","text":"<p>Returns the list of device adapters available in the default search path(s).</p> <p>Do not use in new code. For backward compatibility only.</p> <p>Deprecated</p> <p>Use the non-static <code>getDeviceAdapterNames()</code> instead.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceLibrary","title":"<code>getDeviceLibrary(label: str) -&gt; str</code>","text":"<p>Returns device library (aka module, device adapter) name.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDeviceName","title":"<code>getDeviceName(label: str) -&gt; str</code>","text":"<p>Returns device name for a given device label.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getDevicePropertyNames","title":"<code>getDevicePropertyNames(label: str) -&gt; Tuple[str, ...]</code>","text":"<p>Returns all property names supported by the device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getExposureSequenceMaxLength","title":"<code>getExposureSequenceMaxLength(cameraLabel: str) -&gt; int</code>","text":"<p>Gets the maximum length of a camera's exposure sequence.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getFocusDevice","title":"<code>getFocusDevice() -&gt; str</code>","text":"<p>Returns the label of the currently selected focus device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getFocusDirection","title":"<code>getFocusDirection(stageLabel: str) -&gt; FocusDirection</code>","text":"<p>Get the focus direction of a stage.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoChannel","title":"<code>getGalvoChannel(galvoLabel: str) -&gt; str</code>","text":"<p>Get the name of the active galvo channel (for a multi-laser galvo device).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoDevice","title":"<code>getGalvoDevice() -&gt; str</code>","text":"<p>Returns the label of the currently selected Galvo device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoXMinimum","title":"<code>getGalvoXMinimum(galvoLabel: str) -&gt; float</code>","text":"<p>Get the Galvo x minimum</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoXRange","title":"<code>getGalvoXRange(galvoLabel: str) -&gt; float</code>","text":"<p>Get the Galvo x range</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoYMinimum","title":"<code>getGalvoYMinimum(galvoLabel: str) -&gt; float</code>","text":"<p>Get the Galvo y minimum</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getGalvoYRange","title":"<code>getGalvoYRange(galvoLabel: str) -&gt; float</code>","text":"<p>Get the Galvo y range</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getHostName","title":"<code>getHostName() -&gt; str</code>","text":"<p>return current computer name.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageBitDepth","title":"<code>getImageBitDepth() -&gt; int</code>","text":"<p>How many bits of dynamic range are to be expected from the camera.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageBufferSize","title":"<code>getImageBufferSize() -&gt; int</code>","text":"<p>Returns the size of the internal image buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageHeight","title":"<code>getImageHeight() -&gt; int</code>","text":"<p>Vertical dimension of the image buffer in pixels.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageProcessorDevice","title":"<code>getImageProcessorDevice() -&gt; str</code>","text":"<p>Returns the label of the currently selected image processor device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getImageWidth","title":"<code>getImageWidth() -&gt; int</code>","text":"<p>Horizontal dimension of the image buffer in pixels.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getInstalledDeviceDescription","title":"<code>getInstalledDeviceDescription(hubLabel: str, peripheralLabel: str) -&gt; str</code>","text":"<p>Returns <code>GetInstalledPeripheralDescription</code> from the specified <code>hubLabel</code> device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getInstalledDevices","title":"<code>getInstalledDevices(hubLabel: str) -&gt; Tuple[str, ...]</code>","text":"<p>Performs auto-detection and loading of child devices that are attached to a Hub device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLastFocusScore","title":"<code>getLastFocusScore() -&gt; float</code>","text":"<p>Returns the latest focus score from the focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLastImage","title":"<code>getLastImage() -&gt; np.ndarray</code>","text":"<p>Gets the last image from the circular buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLoadedDevices","title":"<code>getLoadedDevices() -&gt; Tuple[str, ...]</code>","text":"<p>Returns an array of labels for currently loaded devices.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLoadedDevicesOfType","title":"<code>getLoadedDevicesOfType(devType: DeviceType) -&gt; Tuple[str, ...]</code>","text":"<p>Returns an array of labels for currently loaded devices of specific type.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getLoadedPeripheralDevices","title":"<code>getLoadedPeripheralDevices(hubLabel: str) -&gt; Tuple[str, ...]</code>","text":"<p>Return labels of all loaded peripherals of <code>hubLabel</code> device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getMACAddresses","title":"<code>getMACAddresses() -&gt; Tuple[str, ...]</code>","text":"<p>Retrieve vector of MAC addresses for the Ethernet cards in the current computer.</p> <p>formatted as <code>xx-xx-xx-xx-xx-xx</code></p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getMagnificationFactor","title":"<code>getMagnificationFactor() -&gt; float</code>","text":"<p>Returns the product of all Magnifiers in the system or 1.0 when none is found. This is used internally by GetPixelSizeUm</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getNBeforeLastImageMD","title":"<code>getNBeforeLastImageMD(n: int, md: Metadata) -&gt; np.ndarray</code>","text":"<p>Returns a pointer to the pixels of the image that was inserted n images ago. Also provides all metadata associated with that image</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getNumberOfCameraChannels","title":"<code>getNumberOfCameraChannels() -&gt; int</code>","text":"<p>Returns the number of simultaneous channels the default camera is returning.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getNumberOfComponents","title":"<code>getNumberOfComponents() -&gt; int</code>","text":"<p>Returns the number of components the default camera is returning.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getNumberOfStates","title":"<code>getNumberOfStates(stateDeviceLabel: str) -&gt; int</code>","text":"<p>Returns the total number of available positions (states).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getParentLabel","title":"<code>getParentLabel(peripheralLabel: str) -&gt; str</code>","text":"<p>Returns parent device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPixelSizeAffineByID","title":"<code>getPixelSizeAffineByID(resolutionID: str) -&gt; Tuple[float, ...]</code>","text":"<p>Returns the Affine Transform to related camera pixels with stage movement for the requested pixel size group. The raw affine transform without correction for binning and magnification will be returned.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPixelSizeUmByID","title":"<code>getPixelSizeUmByID(resolutionID: str) -&gt; float</code>","text":"<p>Returns the pixel size in um for the requested pixel size group</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPrimaryLogFile","title":"<code>getPrimaryLogFile() -&gt; str</code>","text":"<p>Return the name of the primary Core log file.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getProperty","title":"<code>getProperty(label: str, propName: str) -&gt; str</code>","text":"<p>Returns the property value for the specified device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertyBlockData","title":"<code>getPropertyBlockData(blockName: str) -&gt; PropertyBlock</code>","text":"<p>Returns the collection of property-value pairs defined in this block.</p> <p>Deprecated</p> <p>Property blocks will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertyFromCache","title":"<code>getPropertyFromCache(deviceLabel: str, propName: str) -&gt; str</code>","text":"<p>Returns the cached property value for the specified device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertyLowerLimit","title":"<code>getPropertyLowerLimit(label: str, propName: str) -&gt; float</code>","text":"<p>Returns the property lower limit value, if the property has limits - 0 otherwise.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertySequenceMaxLength","title":"<code>getPropertySequenceMaxLength(label: str, propName: str) -&gt; int</code>","text":"<p>Queries device property for the maximum number of events that can be put in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getPropertyUpperLimit","title":"<code>getPropertyUpperLimit(label: str, propName: str) -&gt; float</code>","text":"<p>Returns the property upper limit value, if the property has limits - 0 otherwise.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getRemainingImageCount","title":"<code>getRemainingImageCount() -&gt; int</code>","text":"<p>Returns number ofimages available in the Circular Buffer</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMBytesPerPixel","title":"<code>getSLMBytesPerPixel(slmLabel: str) -&gt; int</code>","text":"<p>Returns the number of bytes per SLM pixel</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMDevice","title":"<code>getSLMDevice() -&gt; str</code>","text":"<p>Returns the label of the currently selected SLM device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMExposure","title":"<code>getSLMExposure(slmLabel: str) -&gt; float</code>","text":"<p>Returns the exposure time that will be used by the SLM for illumination</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMHeight","title":"<code>getSLMHeight(slmLabel: str) -&gt; int</code>","text":"<p>Returns the height (in \"pixels\") of the SLM</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMNumberOfComponents","title":"<code>getSLMNumberOfComponents(slmLabel: str) -&gt; int</code>","text":"<p>Returns the number of components (usually these depict colors) of the SLM.</p> <p>For instance, an RGB projector will return 3, but a grey scale SLM returns 1</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMSequenceMaxLength","title":"<code>getSLMSequenceMaxLength(slmLabel: str) -&gt; int</code>","text":"<p>For SLMs that support sequences, returns the maximum length of the sequence that can be uploaded to the device</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSLMWidth","title":"<code>getSLMWidth(slmLabel: str) -&gt; int</code>","text":"<p>Returns the width (in \"pixels\") of the SLM</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getSerialPortAnswer","title":"<code>getSerialPortAnswer(portLabel: str, term: str) -&gt; str</code>","text":"<p>Continuously read from the serial port until the terminating sequence is encountered.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getShutterDevice","title":"<code>getShutterDevice() -&gt; str</code>","text":"<p>Returns the label of the currently selected shutter device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStageSequenceMaxLength","title":"<code>getStageSequenceMaxLength(stageLabel: str) -&gt; int</code>","text":"<p>Gets the maximum length of a stage's position sequence.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getState","title":"<code>getState(stateDeviceLabel: str) -&gt; int</code>","text":"<p>Returns the current state (position) on the specific device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStateFromLabel","title":"<code>getStateFromLabel(stateDeviceLabel: str, stateLabel: str) -&gt; int</code>","text":"<p>Obtain the state for a given label.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStateLabel","title":"<code>getStateLabel(stateDeviceLabel: str) -&gt; str</code>","text":"<p>Returns the current state as the label (string).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStateLabelData","title":"<code>getStateLabelData(stateDeviceLabel: str, stateLabel: str) -&gt; PropertyBlock</code>","text":"<p>Returns the collection of property-value pairs defined for the specific device and state label.</p> <p>Deprecated</p> <p>Property blocks will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getStateLabels","title":"<code>getStateLabels(stateDeviceLabel: str) -&gt; Tuple[str, ...]</code>","text":"<p>Return labels for all states</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getTimeoutMs","title":"<code>getTimeoutMs() -&gt; int</code>","text":"<p>Get the timeout for all wait commands.</p> <p>(Default is 5000 ms)</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getUserId","title":"<code>getUserId() -&gt; str</code>","text":"<p>Displays current user name.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getVersionInfo","title":"<code>getVersionInfo() -&gt; str</code>","text":"<p>Displays core version.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getXYStageDevice","title":"<code>getXYStageDevice() -&gt; str</code>","text":"<p>Returns the label of the currently selected XYStage device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.getXYStageSequenceMaxLength","title":"<code>getXYStageSequenceMaxLength(xyStageLabel: str) -&gt; int</code>","text":"<p>Gets the maximum length of an XY stage's position sequence.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.hasProperty","title":"<code>hasProperty(label: str, propName: str) -&gt; bool</code>","text":"<p>Checks if device has a property with a specified name.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.hasPropertyLimits","title":"<code>hasPropertyLimits(label: str, propName: str) -&gt; bool</code>","text":"<p>Queries device if the specific property has limits.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.home","title":"<code>home(xyOrZStageLabel: str) -&gt; None</code>","text":"<p>Perform a hardware homing operation for an XY or focus/Z stage.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.incrementalFocus","title":"<code>incrementalFocus() -&gt; None</code>","text":"<p>Performs incremental focus for the one-shot focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.initializeAllDevices","title":"<code>initializeAllDevices() -&gt; None</code>","text":"<p>Calls Initialize() method for each loaded device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.initializeCircularBuffer","title":"<code>initializeCircularBuffer() -&gt; None</code>","text":"<p>Initialize circular buffer based on the current camera settings.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.initializeDevice","title":"<code>initializeDevice(label: str) -&gt; None</code>","text":"<p>Initializes specific device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isBufferOverflowed","title":"<code>isBufferOverflowed() -&gt; bool</code>","text":"<p>Indicates whether the circular buffer is overflowed</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isConfigDefined","title":"<code>isConfigDefined(groupName: str, configName: str) -&gt; bool</code>","text":"<p>Checks if the configuration already exists within a group.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isContinuousFocusDrive","title":"<code>isContinuousFocusDrive(stageLabel: str) -&gt; bool</code>","text":"<p>Check if a stage has continuous focusing capability.</p> <p>(positions can be set while continuous focus runs).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isContinuousFocusEnabled","title":"<code>isContinuousFocusEnabled() -&gt; bool</code>","text":"<p>Checks if the continuous focusing hardware device is ON or OFF.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isContinuousFocusLocked","title":"<code>isContinuousFocusLocked() -&gt; bool</code>","text":"<p>Returns the lock-in status of the continuous focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isExposureSequenceable","title":"<code>isExposureSequenceable(cameraLabel: str) -&gt; bool</code>","text":"<p>Queries camera if exposure can be used in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isGroupDefined","title":"<code>isGroupDefined(groupName: str) -&gt; bool</code>","text":"<p>Checks if the group already exists.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isMultiROIEnabled","title":"<code>isMultiROIEnabled() -&gt; bool</code>","text":"<p>Queries the camera to determine if multiple ROIs are currently set.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isMultiROISupported","title":"<code>isMultiROISupported() -&gt; bool</code>","text":"<p>Queries the camera to determine if it supports multiple ROIs.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPixelSizeConfigDefined","title":"<code>isPixelSizeConfigDefined(resolutionID: str) -&gt; bool</code>","text":"<p>Checks if the Pixel Size Resolution already exists</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPropertyPreInit","title":"<code>isPropertyPreInit(label: str, propName: str) -&gt; bool</code>","text":"<p>Tells us whether the property must be defined prior to initialization.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPropertyReadOnly","title":"<code>isPropertyReadOnly(label: str, propName: str) -&gt; bool</code>","text":"<p>Tells us whether the property can be modified.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isPropertySequenceable","title":"<code>isPropertySequenceable(label: str, propName: str) -&gt; bool</code>","text":"<p>Queries device if the specified property can be used in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isStageLinearSequenceable","title":"<code>isStageLinearSequenceable(stageLabel: str) -&gt; bool</code>","text":"<p>Queries if the stage can be used in a linear sequence.</p> <p>A linear sequence is defined by a stepsize and number of slices</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isStageSequenceable","title":"<code>isStageSequenceable(stageLabel: str) -&gt; bool</code>","text":"<p>Queries stage if it can be used in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.isXYStageSequenceable","title":"<code>isXYStageSequenceable(xyStageLabel: str) -&gt; bool</code>","text":"<p>Queries XY stage if it can be used in a sequence</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadExposureSequence","title":"<code>loadExposureSequence(cameraLabel: str, exposureSequence_ms: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of exposure times to the camera.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadGalvoPolygons","title":"<code>loadGalvoPolygons(galvoLabel: str) -&gt; None</code>","text":"<p>Load a set of galvo polygons to the device</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadPropertySequence","title":"<code>loadPropertySequence(label: str, propName: str, eventSequence: Sequence[str]) -&gt; None</code>","text":"<p>Transfer a sequence of events/states/whatever to the device.</p> <p>This should only be called for device-properties that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadSLMSequence","title":"<code>loadSLMSequence(slmLabel: str, imageSequence: List[bytes]) -&gt; None</code>","text":"<p>Load a sequence of images into the SLM</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadStageSequence","title":"<code>loadStageSequence(stageLabel: str, positionSequence: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of events/states/whatever to the device.</p> <p>This should only be called for device-properties that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadSystemState","title":"<code>loadSystemState(fileName: str) -&gt; None</code>","text":"<p>Loads the system configuration from the text file conforming to the MM specific format.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.loadXYStageSequence","title":"<code>loadXYStageSequence(xyStageLabel: str, xSequence: Sequence[float], ySequence: Sequence[float]) -&gt; None</code>","text":"<p>Transfer a sequence of stage positions to the xy stage.</p> <p>xSequence and ySequence must have the same length. This should only be called for XY stages that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.noop","title":"<code>noop() -&gt; None</code>","text":"<p>A static method that does nothing.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.pointGalvoAndFire","title":"<code>pointGalvoAndFire(galvoLabel: str, x: float, y: float, pulseTime_us: float) -&gt; None</code>","text":"<p>Set the Galvo to an x,y position and fire the laser for a predetermined duration.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.prepareSequenceAcquisition","title":"<code>prepareSequenceAcquisition(cameraLabel: str) -&gt; None</code>","text":"<p>Prepare the camera for the sequence acquisition to save the time in the</p> <p>StartSequenceAcqusition() call which is supposed to come next.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.readFromSerialPort","title":"<code>readFromSerialPort(portLabel: str) -&gt; List[str]</code>","text":"<p>Reads the contents of the Rx buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.registerCallback","title":"<code>registerCallback(cb: MMEventCallback) -&gt; None</code>","text":"<p>Register a callback (listener class).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.removeImageSynchro","title":"<code>removeImageSynchro(deviceLabel: str) -&gt; None</code>","text":"<p>Removes device from the image-synchro list.</p> <p>Deprecated</p> <p>ImageSynchro will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.removeImageSynchroAll","title":"<code>removeImageSynchroAll() -&gt; None</code>","text":"<p>Clears the image synchro device list.</p> <p>Deprecated</p> <p>ImageSynchro will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.renameConfig","title":"<code>renameConfig(groupName: str, oldConfigName: str, newConfigName: str) -&gt; None</code>","text":"<p>Renames a configuration within a specified group.</p> <p>The command will fail if the configuration was not previously defined.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.renameConfigGroup","title":"<code>renameConfigGroup(oldGroupName: str, newGroupName: str) -&gt; None</code>","text":"<p>Renames a configuration group.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.renamePixelSizeConfig","title":"<code>renamePixelSizeConfig(oldConfigName: str, newConfigName: str) -&gt; None</code>","text":"<p>Renames a pixel size configuration.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Unloads all devices from the core, clears all configuration data and property blocks.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.runGalvoPolygons","title":"<code>runGalvoPolygons(galvoLabel: str) -&gt; None</code>","text":"<p>Run a loop of galvo polygons</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.runGalvoSequence","title":"<code>runGalvoSequence(galvoLabel: str) -&gt; None</code>","text":"<p>Run a sequence of galvo positions</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.saveSystemState","title":"<code>saveSystemState(fileName: str) -&gt; None</code>","text":"<p>Saves the current system state to a text file of the MM specific format.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setAutoFocusDevice","title":"<code>setAutoFocusDevice(focusLabel: str) -&gt; None</code>","text":"<p>Sets the current auto-focus device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setAutoFocusOffset","title":"<code>setAutoFocusOffset(offset: float) -&gt; None</code>","text":"<p>Applies offset the one-shot focusing device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setCameraDevice","title":"<code>setCameraDevice(cameraLabel: str) -&gt; None</code>","text":"<p>Sets the current camera device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setCircularBufferMemoryFootprint","title":"<code>setCircularBufferMemoryFootprint(sizeMB: int) -&gt; None</code>","text":"<p>Reserve memory for the circular buffer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setDeviceAdapterSearchPaths","title":"<code>setDeviceAdapterSearchPaths(paths: Sequence[str]) -&gt; None</code>","text":"<p>Set the device adapter search paths.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setDeviceDelayMs","title":"<code>setDeviceDelayMs(label: str, delayMs: float) -&gt; None</code>","text":"<p>Overrides the built-in value for the action delay.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setFocusDirection","title":"<code>setFocusDirection(stageLabel: str, sign: int) -&gt; None</code>","text":"<p>Set the focus direction of a stage.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoDevice","title":"<code>setGalvoDevice(galvoLabel: str) -&gt; None</code>","text":"<p>Sets the current galvo device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoIlluminationState","title":"<code>setGalvoIlluminationState(galvoLabel: str, on: bool) -&gt; None</code>","text":"<p>Set the galvo's illumination state to on or off</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoPolygonRepetitions","title":"<code>setGalvoPolygonRepetitions(galvoLabel: str, repetitions: int) -&gt; None</code>","text":"<p>Set the number of times to loop galvo polygons</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoPosition","title":"<code>setGalvoPosition(galvoLabel: str, x: float, y: float) -&gt; None</code>","text":"<p>Set the Galvo to an x,y position.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setGalvoSpotInterval","title":"<code>setGalvoSpotInterval(galvoLabel: str, pulseTime_us: float) -&gt; None</code>","text":"<p>Set the SpotInterval for the specified galvo device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setImageProcessorDevice","title":"<code>setImageProcessorDevice(procLabel: str) -&gt; None</code>","text":"<p>Sets the current image processor device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setMultiROI","title":"<code>setMultiROI(xs: Sequence[int], ys: Sequence[int], widths: Sequence[int], heights: Sequence[int]) -&gt; None</code>","text":"<p>Set multiple ROIs for the current camera device.</p> <p>Will fail if the camera does not support multiple ROIs, any widths or heights are non-positive, or if the vectors do not all have the same length.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setParentLabel","title":"<code>setParentLabel(deviceLabel: str, parentHubLabel: str) -&gt; None</code>","text":"<p>Sets parent device label</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPixelSizeAffine","title":"<code>setPixelSizeAffine(resolutionID: str, affine: Sequence[float]) -&gt; None</code>","text":"<p>Sets the raw affine transform for the specific pixel size configuration.</p> <p>The affine transform consists of the first two rows of a 3x3 matrix, the third row is alsways assumed to be 0.0 0.0 1.0.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setPixelSizeConfig","title":"<code>setPixelSizeConfig(resolutionID: str) -&gt; None</code>","text":"<p>Applies a Pixel Size Configuration.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSLMDevice","title":"<code>setSLMDevice(slmLabel: str) -&gt; None</code>","text":"<p>Sets the current slm device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSLMExposure","title":"<code>setSLMExposure(slmLabel: str, exposure_ms: float) -&gt; None</code>","text":"<p>For SLM devices with build-in light source (such as projectors),</p> <p>this will set the exposure time, but not (yet) start the illumination</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSLMImage","title":"<code>setSLMImage(slmLabel: str, pixels: Any) -&gt; None</code>","text":"<p>Write a 32-bit color image to the SLM.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSerialPortCommand","title":"<code>setSerialPortCommand(portLabel: str, command: str, term: str) -&gt; None</code>","text":"<p>Send string to the serial device and return an answer.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSerialProperties","title":"<code>setSerialProperties(portName: str, answerTimeout: str, baudRate: str, delayBetweenCharsMs: str, handshaking: str, parity: str, stopBits: str) -&gt; None</code>","text":"<p>Sets all com port properties in a single call.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setShutterDevice","title":"<code>setShutterDevice(shutterLabel: str) -&gt; None</code>","text":"<p>the current shutter device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setStageLinearSequence","title":"<code>setStageLinearSequence(stageLabel: str, dZ_um: float, nSlices: int) -&gt; None</code>","text":"<p>Loads a linear sequence (defined by stepsize and nr. of steps) into the device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setSystemState","title":"<code>setSystemState(conf: Configuration) -&gt; None</code>","text":"<p>Sets all properties contained in the Configuration object.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setTimeoutMs","title":"<code>setTimeoutMs(timeoutMs: int) -&gt; None</code>","text":"<p>Sets the timeout for all wait commands.</p> <p>(Default is 5000 ms)</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.setXYStageDevice","title":"<code>setXYStageDevice(xyStageLabel: str) -&gt; None</code>","text":"<p>Sets the current XY device.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.sleep","title":"<code>sleep(intervalMs: float) -&gt; None</code>","text":"<p>Waits (blocks the calling thread) for specified time in milliseconds.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startExposureSequence","title":"<code>startExposureSequence(cameraLabel: str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered exposures in a camera.</p> <p>This should only be called for cameras where exposure time is sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startPropertySequence","title":"<code>startPropertySequence(label: str, propName: str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered events in a property of a device.</p> <p>This should only be called for device-properties that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startSLMSequence","title":"<code>startSLMSequence(slmLabel: str) -&gt; None</code>","text":"<p>Starts the sequence previously uploaded to the SLM</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startStageSequence","title":"<code>startStageSequence(stageLabel: str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered events in a stage.</p> <p>This should only be called for stages</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.startXYStageSequence","title":"<code>startXYStageSequence(xyStageLabel: str) -&gt; None</code>","text":"<p>Starts an ongoing sequence of triggered events in an XY stage.</p> <p>This should only be called for stages</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stderrLogEnabled","title":"<code>stderrLogEnabled() -&gt; bool</code>","text":"<p>Indicates whether logging output goes to stdErr</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stop","title":"<code>stop(xyOrZStageLabel: str) -&gt; None</code>","text":"<p>Stop the XY or focus/Z stage motors</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopExposureSequence","title":"<code>stopExposureSequence(cameraLabel: str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered exposures in a camera.</p> <p>This should only be called for cameras where exposure time is sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopPropertySequence","title":"<code>stopPropertySequence(label: str, propName: str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered events in a property of a device.</p> <p>This should only be called for device-properties that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopSLMSequence","title":"<code>stopSLMSequence(slmLabel: str) -&gt; None</code>","text":"<p>Stops the SLM sequence if previously started</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopSecondaryLogFile","title":"<code>stopSecondaryLogFile(handle: int) -&gt; None</code>","text":"<p>Stop capturing logging output into an additional file.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopStageSequence","title":"<code>stopStageSequence(stageLabel: str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered events in a stage.</p> <p>This should only be called for stages that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.stopXYStageSequence","title":"<code>stopXYStageSequence(xyStageLabel: str) -&gt; None</code>","text":"<p>Stops an ongoing sequence of triggered events in an XY stage.</p> <p>This should only be called for stages that are sequenceable</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.supportsDeviceDetection","title":"<code>supportsDeviceDetection(deviceLabel: str) -&gt; bool</code>","text":"<p>Return whether or not the device supports automatic device detection (i.e.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.systemBusy","title":"<code>systemBusy() -&gt; bool</code>","text":"<p>Checks the busy status of the entire system.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.unloadDevice","title":"<code>unloadDevice(label: str) -&gt; None</code>","text":"<p>Unloads the device from the core and adjusts all configuration data.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.unloadLibrary","title":"<code>unloadLibrary(moduleName: str) -&gt; None</code>","text":"<p>Forcefully unload a library.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.updateCoreProperties","title":"<code>updateCoreProperties() -&gt; None</code>","text":"<p>Updates CoreProperties (currently all Core properties are devices types) with the loaded hardware.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.updateSystemStateCache","title":"<code>updateSystemStateCache() -&gt; None</code>","text":"<p>Updates the state of the entire hardware.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.usesDeviceDelay","title":"<code>usesDeviceDelay(label: str) -&gt; bool</code>","text":"<p>Signals if the device will use the delay setting or not.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForConfig","title":"<code>waitForConfig(group: str, configName: str) -&gt; None</code>","text":"<p>Blocks until all devices included in the configuration become ready.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForDevice","title":"<code>waitForDevice(label: str) -&gt; None</code>","text":"<p>Waits (blocks the calling thread) until the specified device becomes non-busy.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForDeviceType","title":"<code>waitForDeviceType(devType: DeviceType) -&gt; None</code>","text":"<p>Blocks until all devices of the specific type become ready (not-busy).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForImageSynchro","title":"<code>waitForImageSynchro() -&gt; None</code>","text":"<p>Wait for the slowest device in the ImageSynchro list.</p> <p>Deprecated</p> <p>will not be supported in the future.</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.waitForSystem","title":"<code>waitForSystem() -&gt; None</code>","text":"<p>Blocks until all devices in the system become ready (not-busy).</p>"},{"location":"api/cmmcoreplus/#pymmcore.CMMCore.writeToSerialPort","title":"<code>writeToSerialPort(portLabel: str, data: bytes) -&gt; None</code>","text":"<p>Sends an array of characters to the serial port and returns immediately.</p>"},{"location":"api/cmmcoreplus/#typeddicts","title":"TypedDicts","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict","title":"<code>pymmcore_plus.core._mmcore_plus.StateDict</code>","text":"<p>Dictionary of state values for a device.</p> <p>This object should only be imported inside a <code>TYPE_CHECKING</code> block.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.AutoFocusDevice","title":"<code>AutoFocusDevice: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.BytesPerPixel","title":"<code>BytesPerPixel: int</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.CameraChannelNames","title":"<code>CameraChannelNames: tuple[str, ...]</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.CameraDevice","title":"<code>CameraDevice: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.Datetime","title":"<code>Datetime: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.Exposure","title":"<code>Exposure: float</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.FocusDevice","title":"<code>FocusDevice: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.GalvoDevice","title":"<code>GalvoDevice: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.ImageBitDepth","title":"<code>ImageBitDepth: int</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.ImageHeight","title":"<code>ImageHeight: int</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.ImageProcessorDevice","title":"<code>ImageProcessorDevice: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.ImageWidth","title":"<code>ImageWidth: int</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.PixelSizeUm","title":"<code>PixelSizeUm: float</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.SLMDevice","title":"<code>SLMDevice: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.ShutterDevice","title":"<code>ShutterDevice: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.XYPosition","title":"<code>XYPosition: tuple[float, float]</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.XYStageDevice","title":"<code>XYStageDevice: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.StateDict.ZPosition","title":"<code>ZPosition: float</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema","title":"<code>pymmcore_plus.core._mmcore_plus.DeviceSchema</code>","text":"<p>JSON schema <code>dict</code> describing a device.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema.description","title":"<code>description: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema.properties","title":"<code>properties: dict[str, PropertySchema]</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema.title","title":"<code>title: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.DeviceSchema.type","title":"<code>type: str</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema","title":"<code>pymmcore_plus.core._mmcore_plus.PropertySchema</code>","text":"<p>JSON schema <code>dict</code> describing a device property.</p>"},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.default","title":"<code>default: Any</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.enum","title":"<code>enum: list</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.maximum","title":"<code>maximum: float</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.minimum","title":"<code>minimum: float</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.preInit","title":"<code>preInit: bool</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.readOnly","title":"<code>readOnly: bool</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.sequenceMaxLength","title":"<code>sequenceMaxLength: int</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.sequenceable","title":"<code>sequenceable: bool</code>  <code>class-attribute</code>","text":""},{"location":"api/cmmcoreplus/#pymmcore_plus.core._mmcore_plus.PropertySchema.type","title":"<code>type: str</code>  <code>class-attribute</code>","text":""},{"location":"api/configuration/","title":"Configuration &amp; Groups","text":"<p>Configuring a microscope with micro-manager entails storing and retrieving a number of device parameters settings.  In general, a single setting comprises a device name, a property name, and a value.  A Configuration object represents a collection of individual settings; that is, it represents a number of device parameters all in a specific state, such as would be used to prepare the microscope to image a specific channel, like \"DAPI\", or \"FITC\".</p> <p>A Configuration Group is, in turn, a collection of <code>Configuration</code> objects; for example, all of the <code>Configuration</code> objects that represent different \"Channel\" settings.</p> <p>Conceptually, Configurations and Groups are organized like this:</p> <pre><code>ConfigGroupA:\nConfiguration1:\ndeviceA:\npropertyA: 'value_a'\npropertyB: 'value_b'\ndeviceB:\npropertyC: 'value_c'\n...\nConfiguration2:\ndeviceA:\npropertyA: 'value_d'\npropertyB: 'value_e'\ndeviceB:\npropertyC: 'value_f'\n...\n...\nConfigGroupB:\nConfiguration1:\ndeviceC:\npropertyA: 'value_g'\n...\n...\n</code></pre>"},{"location":"api/configuration/#pymmcore-plus-objects","title":"<code>pymmcore-plus</code> Objects","text":"<p>MMCore and pymmcore's configuration object implements a basic mutable mapping interface, but with custom method names like <code>addSetting</code>, <code>getSetting</code>, and <code>deleteSetting</code> methods).</p> <p><code>pymmcore-plus</code> provides a <code>Configuration</code> subclass that implements a <code>MutableMapping</code> interface, allowing dict-like access to the configuration, where the keys are 2-tuples of <code>(deviceLabel, propertyLabel)</code> and the values are the property values. (Note, however, that iterating of a <code>Configuration</code> object behaves like iterating over a list of 3-tuples <code>(deviceLabel, propertyLabel, value)</code>, not a dict.)</p> <p><code>pymmcore-plus</code> also offers a <code>ConfigGroup</code> object, which is a <code>MutableMapping</code> where the keys are Configuration Preset names and the values are <code>Configuration</code> objects.</p>"},{"location":"api/configuration/#pymmcore_plus.Configuration","title":"<code>pymmcore_plus.Configuration</code>","text":"<p>Encapsulation of configuration information.</p> <p>This is the type of object returned by default (provided <code>native==False</code>) by: <code>getConfigData][pymmcore_plus.CMMCorePlus.getConfigData], [</code>getPixelSizeConfigData <code>getSystemState][pymmcore_plus.CMMCorePlus.getSystemState] [</code>getSystemStateCache <code>getConfigState][pymmcore_plus.CMMCorePlus.getConfigState] [</code>getConfigGroupState `getConfigGroupStateFromCache</p> <p>This class is a subclass of <code>pymmcore.Configuration</code> that implements an <code>collections.abc.MutableSequence</code> (i.e. it behaves like a Python list). It also behaves much like a <code>collections.abc.MutableMapping</code>, where the keys are 2-tuples of (deviceLabel, propertyLabel) and the values are the property values.</p> <p>Note that the \"order\" of this collection is not well-defined, so while you can index with an integer, you should not rely on the order of the items in the collection.  <code>__getitem__/__setitem__/__delitem__</code> all accept a 2-tuple of <code>(deviceLabel, propertyLabel)</code>.</p> <p>It adds a few convenience methods:</p> <p>Tip</p> <p>All of the methods in <code>pymmcore_plus.CMMCorePlus</code> that would have returned a <code>pymmcore.Configuration</code> in <code>pymmcore</code> (e.g. <code>getConfigData</code>, <code>getConfigState</code>, etc...). have been reimplemented to return a <code>pymmcore_plus.Configuration</code> object. This object has the same API as <code>pymmcore.Configuration</code>, but you can request a \"native\" (unenhanced) <code>pymmcore</code> object by passing <code>native=True</code> to the method.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.append","title":"<code>append(setting: pymmcore.PropertySetting | DevPropValueTuple) -&gt; None</code>","text":"<p>Add a setting to the configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.create","title":"<code>create(*args: Any, **kwargs: Any) -&gt; Configuration</code>  <code>classmethod</code>","text":"<p>More flexible init to create a <code>Configuration</code>.</p> <p>Can create from: 1. A dict of dicts (outer key is device, inner key is prop) 2. A sequence of 3-tuple 3. kwargs: where the key is the device, and the value is a {prop: value} map</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.dict","title":"<code>dict() -&gt; dict[str, dict[str, str]]</code>","text":"<p>Return config as a nested dict {Device: {Property: Value}}.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.extend","title":"<code>extend(other: pymmcore.Configuration | Iterable[pymmcore.PropertySetting | DevPropValueTuple]) -&gt; None</code>","text":"<p>Add all settings from another Configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.from_configuration","title":"<code>from_configuration(config: pymmcore.Configuration) -&gt; Configuration</code>  <code>classmethod</code>","text":"<p>Create Configuration (Plus) from pymmcore.Configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.html","title":"<code>html() -&gt; str</code>","text":"<p>Return config representation as HTML.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config.Configuration.remove","title":"<code>remove(key: DevPropTuple) -&gt; None</code>","text":"<p>Remove setting for <code>(devLabel, propLabel)</code> from the configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.ConfigGroup","title":"<code>pymmcore_plus.ConfigGroup</code>","text":"<p>Convenience object for dealing with a set of related Configuration objects.</p> <p>This object behaves as a <code>collections.abc.MutableMapping</code> of <code>str</code> (configuration group name) to <code>Configuration</code> objects.</p> <p>It is object type returned by <code>pymmcore_plus.CMMCorePlus.getConfigGroupObject</code>.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>The name of the configuration group to manage.  (It needn't exist yet)</p> required <code>mmcore</code> <code>CMMCorePlus</code> <p>The core object managing this config group.</p> required"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.core","title":"<code>core() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>Return the <code>CMMCorePlus</code> instance to which this Device is bound.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.create","title":"<code>create() -&gt; None</code>","text":"<p>Create this configuration group in core (as an empty group).</p> <p>If the group already exists, this is a no-op.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.delete","title":"<code>delete() -&gt; None</code>","text":"<p>Delete this entire configuration group and all presets in it.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.exists","title":"<code>exists() -&gt; bool</code>","text":"<p>Return <code>True</code> if this ConfigGroup exists in the current configuration.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.getCurrentConfig","title":"<code>getCurrentConfig(as_object: bool = False) -&gt; str | Configuration</code>","text":"<p>Returns the current configuration for a given group.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.getCurrentConfigFromCache","title":"<code>getCurrentConfigFromCache(as_object: bool = False) -&gt; str | Configuration</code>","text":"<p>Returns the current configuration for a given group from the cache.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.is_consistent","title":"<code>is_consistent() -&gt; bool</code>  <code>property</code>","text":"<p>Return <code>True</code> if all presets in this group have the same properties.</p> <p>Note that a group with 0 or 1 presets is always considered consistent.  If two or more presets are present, they must all have the same device properties. (values of course may vary.)</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.iterDeviceProperties","title":"<code>iterDeviceProperties() -&gt; Iterator[DeviceProperty]</code>","text":"<p>Iterate <code>DeviceProperty</code> for all properties in this ConfigGroup.</p> <p>Note, this only iterates over properties that are defined in the first preset of this ConfigGroup. This should be the same for all presets in this ConfigGroup, but it is not guaranteed.  Use <code>is_consistent</code> to check if all presets in this ConfigGroup have the same properties.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.name","title":"<code>name() -&gt; str</code>  <code>property</code>","text":"<p>Return the name of this ConfigGroup.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.rename","title":"<code>rename(newGroupName: str) -&gt; None</code>","text":"<p>Rename this configuration group.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.renameConfig","title":"<code>renameConfig(oldConfigName: str, newConfigName: str) -&gt; None</code>","text":"<p>Rename a configuration in this group.</p> <p>If the configuration does not exist, a KeyError is thrown.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.setConfig","title":"<code>setConfig(configName: str) -&gt; None</code>","text":"<p>Set the current configuration to <code>configName</code>.</p> <p>This actually updates the hardware state to match what is stored in the preset <code>configName</code>.</p>"},{"location":"api/configuration/#pymmcore_plus.core._config_group.ConfigGroup.wait","title":"<code>wait(configName: str | None = None) -&gt; None</code>","text":"<p>Blocks until all devices included in the configuration group ready.</p> <p>If <code>configName</code> not provided, then the first configuration in the group is used.</p>"},{"location":"api/constants/","title":"Constants","text":"<p>All of the constants in the <code>pymmcore</code> library are in the top level <code>pymmcore</code> namespace, making it a bit difficult to know what type or enumeration they refer to.</p> <p>All of these constants are reimplemened in the <code>pymmcore_plus</code> library as <code>enum.IntEnum</code> and are available in the <code>pymmcore_plus</code> namespace.</p> <p>For example, the integer corresponding to the <code>AfterLoadSequence</code> action type could be accessed as <code>pymmcore.AfterLoadSequence</code> or <code>pymmcore_plus.ActionType.AfterLoadSequence</code>.</p> <pre><code>In [1]: import pymmcore\n\nIn [2]: pymmcore.AfterLoadSequence\nOut[2]: 4\n\nIn [3]: from pymmcore_plus import ActionType\n\nIn [4]: ActionType.AfterLoadSequence\nOut[4]: &lt;ActionType.AfterLoadSequence: 4&gt;\n\nIn [5]: int(ActionType.AfterLoadSequence)\nOut[5]: 4\n</code></pre> <p>Additionally, it becomes easier to see what constants are available for each type or enumeration.</p> <pre><code>In [6]: list(ActionType)\nOut[6]:\n[\n    &lt;ActionType.NoAction: 0&gt;,\n    &lt;ActionType.BeforeGet: 1&gt;,\n    &lt;ActionType.AfterSet: 2&gt;,\n    &lt;ActionType.IsSequenceable: 3&gt;,\n    &lt;ActionType.AfterLoadSequence: 4&gt;,\n    &lt;ActionType.StartSequence: 5&gt;,\n    &lt;ActionType.StopSequence: 6&gt;\n]\n</code></pre> <p>Lastly, many of the methods that return integers in <code>pymmcore.CMMCore</code> have been re-implemented in <code>pymmcore_plus.CMMCorePlus</code> to return the appropriate enumeration.</p> <pre><code>import pymmcore\n\ncore = pymmcore.CMMCore()\n# ...  load config and devices\ncore.getDeviceType(\"Camera\")  # 2\n\n\nimport pymmcore_plus\n\ncore = pymmcore_plus.CMMCorePlus()\n# ...  load config and devices\ncore.getDeviceType(\"Camera\")  # &lt;DeviceType.CameraDevice: 2&gt;\n</code></pre>"},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType","title":"<code>ActionType</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.AfterLoadSequence","title":"<code>AfterLoadSequence = pymmcore.AfterLoadSequence</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.AfterSet","title":"<code>AfterSet = pymmcore.AfterSet</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.BeforeGet","title":"<code>BeforeGet = pymmcore.BeforeGet</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.IsSequenceable","title":"<code>IsSequenceable = pymmcore.IsSequenceable</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.NoAction","title":"<code>NoAction = pymmcore.NoAction</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.StartSequence","title":"<code>StartSequence = pymmcore.StartSequence</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.ActionType.StopSequence","title":"<code>StopSequence = pymmcore.StopSequence</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand","title":"<code>CFGCommand</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.ConfigGroup","title":"<code>ConfigGroup = pymmcore.g_CFGCommand_ConfigGroup</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.ConfigPixelSize","title":"<code>ConfigPixelSize = pymmcore.g_CFGCommand_ConfigPixelSize</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Configuration","title":"<code>Configuration = pymmcore.g_CFGCommand_Configuration</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Delay","title":"<code>Delay = pymmcore.g_CFGCommand_Delay</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Device","title":"<code>Device = pymmcore.g_CFGCommand_Device</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Equipment","title":"<code>Equipment = pymmcore.g_CFGCommand_Equipment</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.FieldDelimiters","title":"<code>FieldDelimiters = pymmcore.g_FieldDelimiters</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.FocusDirection","title":"<code>FocusDirection = pymmcore.g_CFGCommand_FocusDirection</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.ImageSynchro","title":"<code>ImageSynchro = pymmcore.g_CFGCommand_ImageSynchro</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Label","title":"<code>Label = pymmcore.g_CFGCommand_Label</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.ParentID","title":"<code>ParentID = pymmcore.g_CFGCommand_ParentID</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.PixelSizeAffine","title":"<code>PixelSizeAffine = pymmcore.g_CFGCommand_PixelSizeAffine</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.PixelSize_um","title":"<code>PixelSize_um = pymmcore.g_CFGCommand_PixelSize_um</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGCommand.Property","title":"<code>Property = pymmcore.g_CFGCommand_Property</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup","title":"<code>CFGGroup</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup.PixelSizeUm","title":"<code>PixelSizeUm = pymmcore.g_CFGGroup_PixelSizeUm</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup.System","title":"<code>System = pymmcore.g_CFGGroup_System</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup.System_Shutdown","title":"<code>System_Shutdown = pymmcore.g_CFGGroup_System_Shutdown</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.CFGGroup.System_Startup","title":"<code>System_Startup = pymmcore.g_CFGGroup_System_Startup</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus","title":"<code>DeviceDetectionStatus</code>","text":"<p>DeviceDetectionStatus from device discovery.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus.CanCommunicate","title":"<code>CanCommunicate = pymmcore.CanCommunicate</code>  <code>class-attribute</code>","text":"<p>Communication verified, parameters have been set to valid values.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus.CanNotCommunicate","title":"<code>CanNotCommunicate = pymmcore.CanNotCommunicate</code>  <code>class-attribute</code>","text":"<p>Communication attributes are valid, but the device does not respond.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus.Misconfigured","title":"<code>Misconfigured = pymmcore.Misconfigured</code>  <code>class-attribute</code>","text":"<p>Some information needed to communicate with the device is invalid.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceDetectionStatus.Unimplemented","title":"<code>Unimplemented = pymmcore.Unimplemented</code>  <code>class-attribute</code>","text":"<p>There is as yet no mechanism to programmatically detect the device.</p>"},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceNotification","title":"<code>DeviceNotification</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceNotification.Attention","title":"<code>Attention = pymmcore.Attention</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceNotification.Done","title":"<code>Done = pymmcore.Done</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceNotification.StatusChanged","title":"<code>StatusChanged = pymmcore.StatusChanged</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType","title":"<code>DeviceType</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Any","title":"<code>Any = AnyType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.AnyType","title":"<code>AnyType = pymmcore.AnyType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.AutoFocus","title":"<code>AutoFocus = AutoFocusDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.AutoFocusDevice","title":"<code>AutoFocusDevice = pymmcore.AutoFocusDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Camera","title":"<code>Camera = CameraDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.CameraDevice","title":"<code>CameraDevice = pymmcore.CameraDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Core","title":"<code>Core = CoreDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.CoreDevice","title":"<code>CoreDevice = pymmcore.CoreDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Galvo","title":"<code>Galvo = GalvoDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.GalvoDevice","title":"<code>GalvoDevice = pymmcore.GalvoDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Generic","title":"<code>Generic = GenericDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.GenericDevice","title":"<code>GenericDevice = pymmcore.GenericDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Hub","title":"<code>Hub = HubDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.HubDevice","title":"<code>HubDevice = pymmcore.HubDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.ImageProcessor","title":"<code>ImageProcessor = ImageProcessorDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.ImageProcessorDevice","title":"<code>ImageProcessorDevice = pymmcore.ImageProcessorDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Magnifier","title":"<code>Magnifier = MagnifierDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.MagnifierDevice","title":"<code>MagnifierDevice = pymmcore.MagnifierDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SLM","title":"<code>SLM = SLMDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SLMDevice","title":"<code>SLMDevice = pymmcore.SLMDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Serial","title":"<code>Serial = SerialDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SerialDevice","title":"<code>SerialDevice = pymmcore.SerialDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Shutter","title":"<code>Shutter = ShutterDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.ShutterDevice","title":"<code>ShutterDevice = pymmcore.ShutterDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SignalIO","title":"<code>SignalIO = SignalIODevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.SignalIODevice","title":"<code>SignalIODevice = pymmcore.SignalIODevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Stage","title":"<code>Stage = StageDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.StageDevice","title":"<code>StageDevice = pymmcore.StageDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.State","title":"<code>State = StateDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.StateDevice","title":"<code>StateDevice = pymmcore.StateDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.Unknown","title":"<code>Unknown = UnknownType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.UnknownType","title":"<code>UnknownType = pymmcore.UnknownType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.XYStage","title":"<code>XYStage = XYStageDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.DeviceType.XYStageDevice","title":"<code>XYStageDevice = pymmcore.XYStageDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection","title":"<code>FocusDirection</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.AwayFromSample","title":"<code>AwayFromSample = FocusDirectionAwayFromSample</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.FocusDirectionAwayFromSample","title":"<code>FocusDirectionAwayFromSample = pymmcore.FocusDirectionAwayFromSample</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.FocusDirectionTowardSample","title":"<code>FocusDirectionTowardSample = pymmcore.FocusDirectionTowardSample</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.FocusDirectionUnknown","title":"<code>FocusDirectionUnknown = pymmcore.FocusDirectionUnknown</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.TowardSample","title":"<code>TowardSample = FocusDirectionTowardSample</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.FocusDirection.Unknown","title":"<code>Unknown = FocusDirectionUnknown</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword","title":"<code>Keyword</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ActualExposure","title":"<code>ActualExposure = pymmcore.g_Keyword_ActualExposure</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ActualInterval_ms","title":"<code>ActualInterval_ms = pymmcore.g_Keyword_ActualInterval_ms</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.AnswerTimeout","title":"<code>AnswerTimeout = pymmcore.g_Keyword_AnswerTimeout</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.BaudRate","title":"<code>BaudRate = pymmcore.g_Keyword_BaudRate</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Binning","title":"<code>Binning = pymmcore.g_Keyword_Binning</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CCDTemperature","title":"<code>CCDTemperature = pymmcore.g_Keyword_CCDTemperature</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CCDTemperatureSetPoint","title":"<code>CCDTemperatureSetPoint = pymmcore.g_Keyword_CCDTemperatureSetPoint</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CameraChannelIndex","title":"<code>CameraChannelIndex = pymmcore.g_Keyword_CameraChannelIndex</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CameraChannelName","title":"<code>CameraChannelName = pymmcore.g_Keyword_CameraChannelName</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CameraID","title":"<code>CameraID = pymmcore.g_Keyword_CameraID</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CameraName","title":"<code>CameraName = pymmcore.g_Keyword_CameraName</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Channel","title":"<code>Channel = pymmcore.g_Keyword_Channel</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Closed_Position","title":"<code>Closed_Position = pymmcore.g_Keyword_Closed_Position</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ColorMode","title":"<code>ColorMode = pymmcore.g_Keyword_ColorMode</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreAutoFocus","title":"<code>CoreAutoFocus = pymmcore.g_Keyword_CoreAutoFocus</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreAutoShutter","title":"<code>CoreAutoShutter = pymmcore.g_Keyword_CoreAutoShutter</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreCamera","title":"<code>CoreCamera = pymmcore.g_Keyword_CoreCamera</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreChannelGroup","title":"<code>CoreChannelGroup = pymmcore.g_Keyword_CoreChannelGroup</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreDevice","title":"<code>CoreDevice = pymmcore.g_Keyword_CoreDevice</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreFocus","title":"<code>CoreFocus = pymmcore.g_Keyword_CoreFocus</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreGalvo","title":"<code>CoreGalvo = pymmcore.g_Keyword_CoreGalvo</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreImageProcessor","title":"<code>CoreImageProcessor = pymmcore.g_Keyword_CoreImageProcessor</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreInitialize","title":"<code>CoreInitialize = pymmcore.g_Keyword_CoreInitialize</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreSLM","title":"<code>CoreSLM = pymmcore.g_Keyword_CoreSLM</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreShutter","title":"<code>CoreShutter = pymmcore.g_Keyword_CoreShutter</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreTimeoutMs","title":"<code>CoreTimeoutMs = pymmcore.g_Keyword_CoreTimeoutMs</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.CoreXYStage","title":"<code>CoreXYStage = pymmcore.g_Keyword_CoreXYStage</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.DataBits","title":"<code>DataBits = pymmcore.g_Keyword_DataBits</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Delay","title":"<code>Delay = pymmcore.g_Keyword_Delay</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.DelayBetweenCharsMs","title":"<code>DelayBetweenCharsMs = pymmcore.g_Keyword_DelayBetweenCharsMs</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Description","title":"<code>Description = pymmcore.g_Keyword_Description</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.EMGain","title":"<code>EMGain = pymmcore.g_Keyword_EMGain</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Elapsed_Time_ms","title":"<code>Elapsed_Time_ms = pymmcore.g_Keyword_Elapsed_Time_ms</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Exposure","title":"<code>Exposure = pymmcore.g_Keyword_Exposure</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Gain","title":"<code>Gain = pymmcore.g_Keyword_Gain</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Handshaking","title":"<code>Handshaking = pymmcore.g_Keyword_Handshaking</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.HubID","title":"<code>HubID = pymmcore.g_Keyword_HubID</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Interval_ms","title":"<code>Interval_ms = pymmcore.g_Keyword_Interval_ms</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Label","title":"<code>Label = pymmcore.g_Keyword_Label</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Meatdata_Exposure","title":"<code>Meatdata_Exposure = pymmcore.g_Keyword_Meatdata_Exposure</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_ImageNumber","title":"<code>Metadata_ImageNumber = pymmcore.g_Keyword_Metadata_ImageNumber</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_ROI_X","title":"<code>Metadata_ROI_X = pymmcore.g_Keyword_Metadata_ROI_X</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_ROI_Y","title":"<code>Metadata_ROI_Y = pymmcore.g_Keyword_Metadata_ROI_Y</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_Score","title":"<code>Metadata_Score = pymmcore.g_Keyword_Metadata_Score</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Metadata_TimeInCore","title":"<code>Metadata_TimeInCore = pymmcore.g_Keyword_Metadata_TimeInCore</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Name","title":"<code>Name = pymmcore.g_Keyword_Name</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Offset","title":"<code>Offset = pymmcore.g_Keyword_Offset</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Parity","title":"<code>Parity = pymmcore.g_Keyword_Parity</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.PixelType","title":"<code>PixelType = pymmcore.g_Keyword_PixelType</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Port","title":"<code>Port = pymmcore.g_Keyword_Port</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Position","title":"<code>Position = pymmcore.g_Keyword_Position</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ReadoutMode","title":"<code>ReadoutMode = pymmcore.g_Keyword_ReadoutMode</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.ReadoutTime","title":"<code>ReadoutTime = pymmcore.g_Keyword_ReadoutTime</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Speed","title":"<code>Speed = pymmcore.g_Keyword_Speed</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.State","title":"<code>State = pymmcore.g_Keyword_State</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.StopBits","title":"<code>StopBits = pymmcore.g_Keyword_StopBits</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Transpose_Correction","title":"<code>Transpose_Correction = pymmcore.g_Keyword_Transpose_Correction</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Transpose_MirrorX","title":"<code>Transpose_MirrorX = pymmcore.g_Keyword_Transpose_MirrorX</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Transpose_MirrorY","title":"<code>Transpose_MirrorY = pymmcore.g_Keyword_Transpose_MirrorY</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Transpose_SwapXY","title":"<code>Transpose_SwapXY = pymmcore.g_Keyword_Transpose_SwapXY</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Type","title":"<code>Type = pymmcore.g_Keyword_Type</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.Keyword.Version","title":"<code>Version = pymmcore.g_Keyword_Version</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType","title":"<code>PortType</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType.HIDPort","title":"<code>HIDPort = pymmcore.HIDPort</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType.InvalidPort","title":"<code>InvalidPort = pymmcore.InvalidPort</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType.SerialPort","title":"<code>SerialPort = pymmcore.SerialPort</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PortType.USBPort","title":"<code>USBPort = pymmcore.USBPort</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType","title":"<code>PropertyType</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.Float","title":"<code>Float = pymmcore.Float</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.Integer","title":"<code>Integer = pymmcore.Integer</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.String","title":"<code>String = pymmcore.String</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.Undef","title":"<code>Undef = pymmcore.Undef</code>  <code>class-attribute</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.to_json","title":"<code>to_json() -&gt; str</code>","text":""},{"location":"api/constants/#pymmcore_plus.core._constants.PropertyType.to_python","title":"<code>to_python() -&gt; type | None</code>","text":""},{"location":"api/device/","title":"Device &amp; Property objects","text":"<p><code>pymmcore-plus</code> offers two classes that provide a more object-oriented interface to common operations and queries performed on devices and their properties.</p> <p>In the original <code>CMMCore</code> API, there are a lot of methods that accept a <code>deviceLabel</code> string as the first argument (and perhaps additional arguments) and query something about that device (e.g. <code>getDeviceLibrary</code>, <code>getDeviceType</code>, <code>waitForDevice</code>, etc...).  In <code>pymmcore-plus</code>, the <code>Device</code> class acts as a \"view\" onto a specific device, and these methods are implemented as methods (that no longer require the <code>deviceLabel</code> argument), and the <code>deviceLabel</code> is passed to the constructor.</p> <p>Similarly, there are many methods in the <code>CMMCore</code> API that require both a device label and a device property name, and modify that specific property (e.g. <code>isPropertySequenceable</code>, <code>getProperty</code>, <code>isPropertyReadOnly</code>, etc...).  Here, the <code>DeviceProperty</code> class acts as a \"view\" onto a specific device property, with an object-oriented interface to these methods.</p>"},{"location":"api/device/#pymmcore_plus.DeviceAdapter","title":"<code>pymmcore_plus.DeviceAdapter</code>","text":"<p>Convenience view onto a device-adapter library.</p> <p>This is the type of object that is returned by <code>pymmcore_plus.CMMCorePlus.getAdapterObject</code></p> <p>Parameters:</p> Name Type Description Default <code>library_name</code> <code>str</code> <p>Device this property belongs to</p> required <code>mmcore</code> <code>CMMCorePlus</code> <p>CMMCorePlus instance</p> required Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>class DeviceAdapter:\n\"\"\"Convenience view onto a device-adapter library.\n\n    This is the type of object that is returned by\n    [`pymmcore_plus.CMMCorePlus.getAdapterObject`][]\n\n    Parameters\n    ----------\n    library_name : str\n        Device this property belongs to\n    mmcore : CMMCorePlus\n        CMMCorePlus instance\n    \"\"\"\n\n    def __init__(self, library_name: str, mmcore: CMMCorePlus) -&gt; None:\n        self._name = library_name\n        self._mmc = mmcore\n        # self.propertyChanged = _DevicePropValueSignal(device_label, None, mmcore)\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Return the short name of this device adapter library.\"\"\"\n        return self._name\n\n    @property\n    def core(self) -&gt; CMMCorePlus:\n\"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n        return self._mmc\n\n    @property\n    def available_devices(self) -&gt; tuple[Device, ...]:\n\"\"\"Get available devices offered by this device adapter.\n\n        Returns\n        -------\n        tuple[Device, ...]\n            Tuple of `Device` objects, with the name, type, and description\n            of each device.  These objects also have a `load` method that can be used\n            to load the device under a given label.\n        \"\"\"\n        try:\n            devs = self._mmc.getAvailableDevices(self.name)\n        except RuntimeError:\n            return ()\n\n        types = self._mmc.getAvailableDeviceTypes(self.name)\n        descriptions = self._mmc.getAvailableDeviceDescriptions(self.name)\n        return tuple(\n            Device(\n                mmcore=self._mmc,\n                adapter_name=self.name,\n                device_name=dev_name,\n                type=DeviceType(dt),\n                description=desc,\n            )\n            for dev_name, dt, desc in zip(devs, types, descriptions)\n        )\n\n    @property\n    def loaded_devices(self) -&gt; tuple[Device, ...]:\n\"\"\"Get currently loaded devices controlled this adapter.\n\n        Returns\n        -------\n        tuple[Device, ...]\n            Tuple of loaded `Device` objects.\n        \"\"\"\n        return tuple(self._mmc.iterDevices(device_adapter=self.name))\n\n    def unload(self) -&gt; None:\n\"\"\"Forcefully unload this library.\"\"\"\n        self._mmc.unloadLibrary(self.name)\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return string representation of this adapter.\"\"\"\n        core = repr(self._mmc).strip(\"&lt;&gt;\")\n        try:\n            ndevs = str(len(self._mmc.getAvailableDevices(self.name)))\n        except Exception:\n            ndevs = \"ERR\"\n        return f\"&lt;Adapter {self.name!r} on {core}: {ndevs} devices&gt;\"\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.available_devices","title":"<code>available_devices() -&gt; tuple[Device, ...]</code>  <code>property</code>","text":"<p>Get available devices offered by this device adapter.</p> <p>Returns:</p> Type Description <code>tuple[Device, ...]</code> <p>Tuple of <code>Device</code> objects, with the name, type, and description of each device.  These objects also have a <code>load</code> method that can be used to load the device under a given label.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>@property\ndef available_devices(self) -&gt; tuple[Device, ...]:\n\"\"\"Get available devices offered by this device adapter.\n\n    Returns\n    -------\n    tuple[Device, ...]\n        Tuple of `Device` objects, with the name, type, and description\n        of each device.  These objects also have a `load` method that can be used\n        to load the device under a given label.\n    \"\"\"\n    try:\n        devs = self._mmc.getAvailableDevices(self.name)\n    except RuntimeError:\n        return ()\n\n    types = self._mmc.getAvailableDeviceTypes(self.name)\n    descriptions = self._mmc.getAvailableDeviceDescriptions(self.name)\n    return tuple(\n        Device(\n            mmcore=self._mmc,\n            adapter_name=self.name,\n            device_name=dev_name,\n            type=DeviceType(dt),\n            description=desc,\n        )\n        for dev_name, dt, desc in zip(devs, types, descriptions)\n    )\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.core","title":"<code>core() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>Return the <code>CMMCorePlus</code> instance to which this Device is bound.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>@property\ndef core(self) -&gt; CMMCorePlus:\n\"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n    return self._mmc\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.loaded_devices","title":"<code>loaded_devices() -&gt; tuple[Device, ...]</code>  <code>property</code>","text":"<p>Get currently loaded devices controlled this adapter.</p> <p>Returns:</p> Type Description <code>tuple[Device, ...]</code> <p>Tuple of loaded <code>Device</code> objects.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>@property\ndef loaded_devices(self) -&gt; tuple[Device, ...]:\n\"\"\"Get currently loaded devices controlled this adapter.\n\n    Returns\n    -------\n    tuple[Device, ...]\n        Tuple of loaded `Device` objects.\n    \"\"\"\n    return tuple(self._mmc.iterDevices(device_adapter=self.name))\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.name","title":"<code>name() -&gt; str</code>  <code>property</code>","text":"<p>Return the short name of this device adapter library.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>@property\ndef name(self) -&gt; str:\n\"\"\"Return the short name of this device adapter library.\"\"\"\n    return self._name\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._adapter.DeviceAdapter.unload","title":"<code>unload() -&gt; None</code>","text":"<p>Forcefully unload this library.</p> Source code in <code>pymmcore_plus/core/_adapter.py</code> <pre><code>def unload(self) -&gt; None:\n\"\"\"Forcefully unload this library.\"\"\"\n    self._mmc.unloadLibrary(self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.Device","title":"<code>pymmcore_plus.Device</code>","text":"<p>Convenience view onto a device.</p> <p>This is the type of object that is returned by <code>pymmcore_plus.CMMCorePlus.getDeviceObject</code></p> <p>Parameters:</p> Name Type Description Default <code>device_label</code> <code>str</code> <p>Device this property belongs to</p> <code>UNASIGNED</code> <code>mmcore</code> <code>CMMCorePlus</code> <p>CMMCorePlus instance</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; device = Device('Camera', core)\n&gt;&gt;&gt; device.isLoaded()\n&gt;&gt;&gt; device.load('NotALib', 'DCam')  # useful error\n&gt;&gt;&gt; device.load('DemoCamera', 'DCam')\n&gt;&gt;&gt; device.initialize()\n&gt;&gt;&gt; device.load('DemoCamera', 'DCam')  # no-op w/ useful warning\n&gt;&gt;&gt; device.properties  # tuple of DeviceProperty objects\n&gt;&gt;&gt; device.description()\n&gt;&gt;&gt; device.isBusy()\n&gt;&gt;&gt; device.wait()\n&gt;&gt;&gt; device.type()\n&gt;&gt;&gt; device.schema()  # JSON schema of device properties\n</code></pre> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>class Device:\n\"\"\"Convenience view onto a device.\n\n    This is the type of object that is returned by\n    [`pymmcore_plus.CMMCorePlus.getDeviceObject`][]\n\n    Parameters\n    ----------\n    device_label : str\n        Device this property belongs to\n    mmcore : CMMCorePlus\n        CMMCorePlus instance\n\n    Examples\n    --------\n    &gt;&gt;&gt; core = CMMCorePlus()\n    &gt;&gt;&gt; device = Device('Camera', core)\n    &gt;&gt;&gt; device.isLoaded()\n    &gt;&gt;&gt; device.load('NotALib', 'DCam')  # useful error\n    &gt;&gt;&gt; device.load('DemoCamera', 'DCam')\n    &gt;&gt;&gt; device.initialize()\n    &gt;&gt;&gt; device.load('DemoCamera', 'DCam')  # no-op w/ useful warning\n    &gt;&gt;&gt; device.properties  # tuple of DeviceProperty objects\n    &gt;&gt;&gt; device.description()\n    &gt;&gt;&gt; device.isBusy()\n    &gt;&gt;&gt; device.wait()\n    &gt;&gt;&gt; device.type()\n    &gt;&gt;&gt; device.schema()  # JSON schema of device properties\n    \"\"\"\n\n    UNASIGNED = \"__UNASIGNED__\"\n    propertyChanged: PSignalInstance\n\n    def __init__(\n        self,\n        device_label: str = UNASIGNED,\n        mmcore: CMMCorePlus | None = None,\n        adapter_name: str = \"\",\n        device_name: str = \"\",\n        type: DeviceType = DeviceType.UnknownType,\n        description: str = \"\",\n    ) -&gt; None:\n        if mmcore is None:\n            from ._mmcore_plus import CMMCorePlus\n\n            self._mmc = CMMCorePlus.instance()\n        else:\n            self._mmc = mmcore\n\n        self._label = device_label\n        self._adapter_name = adapter_name\n        self._device_name = device_name\n        self._type = type\n        self._description = description\n        self.propertyChanged = _DevicePropValueSignal(device_label, None, self._mmc)\n\n    @property\n    def label(self) -&gt; str:\n\"\"\"Return the assigned label of this device.\"\"\"\n        return self._label\n\n    @label.setter\n    def label(self, value: str) -&gt; None:\n        if self.isLoaded():\n            raise RuntimeError(\"Cannot change label of loaded device\")\n        self._label = value\n\n    @property\n    def core(self) -&gt; CMMCorePlus:\n\"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n        return self._mmc\n\n    def isBusy(self) -&gt; bool:\n\"\"\"Return busy status for this device.\"\"\"\n        return self._mmc.deviceBusy(self.label)\n\n    def delayMs(self) -&gt; float:\n\"\"\"Return action delay in ms for this device.\"\"\"\n        return self._mmc.getDeviceDelayMs(self.label)\n\n    def setDelayMs(self, delayMs: float) -&gt; None:\n\"\"\"Override the built-in value for the action delay.\"\"\"\n        self._mmc.setDeviceDelayMs(self.label, delayMs)\n\n    def usesDelay(self) -&gt; bool:\n\"\"\"Return `True` if the device will use the delay setting or not.\"\"\"\n        return self._mmc.usesDeviceDelay(self.label)\n\n    def description(self) -&gt; str:\n\"\"\"Return device description.\"\"\"\n        return self._description or self._mmc.getDeviceDescription(self.label)\n\n    def library(self) -&gt; str:\n\"\"\"Return device library (aka module, device adapter) name.\"\"\"\n        return self._adapter_name or self._mmc.getDeviceLibrary(self.label)\n\n    def name(self) -&gt; str:\n\"\"\"Return the device name (this is not the same as the assigned label).\"\"\"\n        return self._device_name or self._mmc.getDeviceName(self.label)\n\n    def propertyNames(self) -&gt; tuple[str, ...]:\n\"\"\"Return all property names supported by this device.\"\"\"\n        return self._mmc.getDevicePropertyNames(self.label)\n\n    @property\n    def properties(self) -&gt; tuple[DeviceProperty, ...]:\n\"\"\"Get all properties supported by device as DeviceProperty objects.\"\"\"\n        return tuple(\n            DeviceProperty(self.label, name, self._mmc) for name in self.propertyNames()\n        )\n\n    def getPropertyObject(self, property_name: str) -&gt; DeviceProperty:\n\"\"\"Return a `DeviceProperty` object bound to this device on this core.\"\"\"\n        return DeviceProperty(self.label, property_name, self._mmc)\n\n    def initialize(self) -&gt; None:\n\"\"\"Initialize device.\"\"\"\n        return self._mmc.initializeDevice(self.label)\n\n    def load(\n        self,\n        adapter_name: str = \"\",\n        device_name: str = \"\",\n        device_label: str = \"\",\n    ) -&gt; None:\n\"\"\"Load device from the plugin library.\n\n        Parameters\n        ----------\n        adapter_name : str\n            The name of the device adapter module (short name, not full file name).\n            (This is what is returned by `Device.library()`). Must be specified if\n            `adapter_name` was not provided to the `Device` constructor.\n        device_name : str\n            The name of the device. The name must correspond to one of the names\n            recognized by the specific plugin library. (This is what is returned by\n            `Device.name()`). Must be specified if `device_name` was not provided to\n            the `Device` constructor.\n        device_label : str\n            The name to assign to the device. If not specified, the device will be\n            assigned a default name: `adapter_name-device_name`, unless this Device\n            instance was initialized with a label.\n        \"\"\"\n        if not (adapter_name := adapter_name or self._adapter_name):\n            raise TypeError(\"Must specify adapter_name\")\n        if not (device_name := device_name or self._device_name):\n            raise TypeError(\"Must specify device_name\")\n        if device_label:\n            self.label = device_label\n        elif self.label == self.UNASIGNED:\n            self.label = f\"{adapter_name}-{device_name}\"\n\n        self._mmc.loadDevice(self.label, adapter_name, device_name)\n\n    def unload(self) -&gt; None:\n\"\"\"Unload device from the core and adjust all configuration data.\"\"\"\n        return self._mmc.unloadDevice(self.label)\n\n    def isLoaded(self) -&gt; bool:\n\"\"\"Return `True` if device is loaded.\"\"\"\n        return self.label in self._mmc.getLoadedDevices()\n\n    def detect(self) -&gt; DeviceDetectionStatus:\n\"\"\"Tries to communicate to device through a given serial port.\n\n        Used to automate discovery of correct serial port. Also configures the\n        serial port correctly.\n        \"\"\"\n        return self._mmc.detectDevice(self.label)\n\n    def supportsDetection(self) -&gt; bool:\n\"\"\"Return whether or not the device supports automatic device detection.\n\n        (i.e. whether or not detectDevice() may be safely called).\n        \"\"\"\n        try:\n            return self._mmc.supportsDeviceDetection(self.label)\n        except RuntimeError:\n            return False  # e.g. core devices\n\n    def type(self) -&gt; DeviceType:\n\"\"\"Return device type.\"\"\"\n        return self._type or self._mmc.getDeviceType(self.label)\n\n    def schema(self) -&gt; DeviceSchema:\n\"\"\"Return dict in JSON-schema format for properties of `device_label`.\"\"\"\n        return self._mmc.getDeviceSchema(self.label)\n\n    def wait(self) -&gt; None:\n\"\"\"Block the calling thread until device becomes non-busy.\"\"\"\n        self._mmc.waitForDevice(self.label)\n\n    def __repr__(self) -&gt; str:\n        if self.isLoaded():\n            n = len(self.propertyNames())\n            props = f'{n} {\"properties\" if n&gt;1 else \"property\"}'\n            lib = f\"({self.library()}::{self.name()}) \"\n        else:\n            props = \"NOT LOADED\"\n            lib = \"\"\n        core = repr(self._mmc).strip(\"&lt;&gt;\")\n        return f\"&lt;Device {self.label!r} {lib}on {core}: {props}&gt;\"\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.UNASIGNED","title":"<code>UNASIGNED = '__UNASIGNED__'</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._device.Device.propertyChanged","title":"<code>propertyChanged = _DevicePropValueSignal(device_label, None, self._mmc)</code>  <code>instance-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._device.Device.core","title":"<code>core() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>Return the <code>CMMCorePlus</code> instance to which this Device is bound.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>@property\ndef core(self) -&gt; CMMCorePlus:\n\"\"\"Return the `CMMCorePlus` instance to which this Device is bound.\"\"\"\n    return self._mmc\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.delayMs","title":"<code>delayMs() -&gt; float</code>","text":"<p>Return action delay in ms for this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def delayMs(self) -&gt; float:\n\"\"\"Return action delay in ms for this device.\"\"\"\n    return self._mmc.getDeviceDelayMs(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.description","title":"<code>description() -&gt; str</code>","text":"<p>Return device description.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def description(self) -&gt; str:\n\"\"\"Return device description.\"\"\"\n    return self._description or self._mmc.getDeviceDescription(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.detect","title":"<code>detect() -&gt; DeviceDetectionStatus</code>","text":"<p>Tries to communicate to device through a given serial port.</p> <p>Used to automate discovery of correct serial port. Also configures the serial port correctly.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def detect(self) -&gt; DeviceDetectionStatus:\n\"\"\"Tries to communicate to device through a given serial port.\n\n    Used to automate discovery of correct serial port. Also configures the\n    serial port correctly.\n    \"\"\"\n    return self._mmc.detectDevice(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.getPropertyObject","title":"<code>getPropertyObject(property_name: str) -&gt; DeviceProperty</code>","text":"<p>Return a <code>DeviceProperty</code> object bound to this device on this core.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def getPropertyObject(self, property_name: str) -&gt; DeviceProperty:\n\"\"\"Return a `DeviceProperty` object bound to this device on this core.\"\"\"\n    return DeviceProperty(self.label, property_name, self._mmc)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.initialize","title":"<code>initialize() -&gt; None</code>","text":"<p>Initialize device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def initialize(self) -&gt; None:\n\"\"\"Initialize device.\"\"\"\n    return self._mmc.initializeDevice(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.isBusy","title":"<code>isBusy() -&gt; bool</code>","text":"<p>Return busy status for this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def isBusy(self) -&gt; bool:\n\"\"\"Return busy status for this device.\"\"\"\n    return self._mmc.deviceBusy(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.isLoaded","title":"<code>isLoaded() -&gt; bool</code>","text":"<p>Return <code>True</code> if device is loaded.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def isLoaded(self) -&gt; bool:\n\"\"\"Return `True` if device is loaded.\"\"\"\n    return self.label in self._mmc.getLoadedDevices()\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.label","title":"<code>label() -&gt; str</code>  <code>property</code> <code>writable</code>","text":"<p>Return the assigned label of this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>@property\ndef label(self) -&gt; str:\n\"\"\"Return the assigned label of this device.\"\"\"\n    return self._label\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.library","title":"<code>library() -&gt; str</code>","text":"<p>Return device library (aka module, device adapter) name.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def library(self) -&gt; str:\n\"\"\"Return device library (aka module, device adapter) name.\"\"\"\n    return self._adapter_name or self._mmc.getDeviceLibrary(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.load","title":"<code>load(adapter_name: str = '', device_name: str = '', device_label: str = '') -&gt; None</code>","text":"<p>Load device from the plugin library.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_name</code> <code>str</code> <p>The name of the device adapter module (short name, not full file name). (This is what is returned by <code>Device.library()</code>). Must be specified if <code>adapter_name</code> was not provided to the <code>Device</code> constructor.</p> <code>''</code> <code>device_name</code> <code>str</code> <p>The name of the device. The name must correspond to one of the names recognized by the specific plugin library. (This is what is returned by <code>Device.name()</code>). Must be specified if <code>device_name</code> was not provided to the <code>Device</code> constructor.</p> <code>''</code> <code>device_label</code> <code>str</code> <p>The name to assign to the device. If not specified, the device will be assigned a default name: <code>adapter_name-device_name</code>, unless this Device instance was initialized with a label.</p> <code>''</code> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def load(\n    self,\n    adapter_name: str = \"\",\n    device_name: str = \"\",\n    device_label: str = \"\",\n) -&gt; None:\n\"\"\"Load device from the plugin library.\n\n    Parameters\n    ----------\n    adapter_name : str\n        The name of the device adapter module (short name, not full file name).\n        (This is what is returned by `Device.library()`). Must be specified if\n        `adapter_name` was not provided to the `Device` constructor.\n    device_name : str\n        The name of the device. The name must correspond to one of the names\n        recognized by the specific plugin library. (This is what is returned by\n        `Device.name()`). Must be specified if `device_name` was not provided to\n        the `Device` constructor.\n    device_label : str\n        The name to assign to the device. If not specified, the device will be\n        assigned a default name: `adapter_name-device_name`, unless this Device\n        instance was initialized with a label.\n    \"\"\"\n    if not (adapter_name := adapter_name or self._adapter_name):\n        raise TypeError(\"Must specify adapter_name\")\n    if not (device_name := device_name or self._device_name):\n        raise TypeError(\"Must specify device_name\")\n    if device_label:\n        self.label = device_label\n    elif self.label == self.UNASIGNED:\n        self.label = f\"{adapter_name}-{device_name}\"\n\n    self._mmc.loadDevice(self.label, adapter_name, device_name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.name","title":"<code>name() -&gt; str</code>","text":"<p>Return the device name (this is not the same as the assigned label).</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def name(self) -&gt; str:\n\"\"\"Return the device name (this is not the same as the assigned label).\"\"\"\n    return self._device_name or self._mmc.getDeviceName(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.properties","title":"<code>properties() -&gt; tuple[DeviceProperty, ...]</code>  <code>property</code>","text":"<p>Get all properties supported by device as DeviceProperty objects.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>@property\ndef properties(self) -&gt; tuple[DeviceProperty, ...]:\n\"\"\"Get all properties supported by device as DeviceProperty objects.\"\"\"\n    return tuple(\n        DeviceProperty(self.label, name, self._mmc) for name in self.propertyNames()\n    )\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.propertyNames","title":"<code>propertyNames() -&gt; tuple[str, ...]</code>","text":"<p>Return all property names supported by this device.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def propertyNames(self) -&gt; tuple[str, ...]:\n\"\"\"Return all property names supported by this device.\"\"\"\n    return self._mmc.getDevicePropertyNames(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.schema","title":"<code>schema() -&gt; DeviceSchema</code>","text":"<p>Return dict in JSON-schema format for properties of <code>device_label</code>.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def schema(self) -&gt; DeviceSchema:\n\"\"\"Return dict in JSON-schema format for properties of `device_label`.\"\"\"\n    return self._mmc.getDeviceSchema(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.setDelayMs","title":"<code>setDelayMs(delayMs: float) -&gt; None</code>","text":"<p>Override the built-in value for the action delay.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def setDelayMs(self, delayMs: float) -&gt; None:\n\"\"\"Override the built-in value for the action delay.\"\"\"\n    self._mmc.setDeviceDelayMs(self.label, delayMs)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.supportsDetection","title":"<code>supportsDetection() -&gt; bool</code>","text":"<p>Return whether or not the device supports automatic device detection.</p> <p>(i.e. whether or not detectDevice() may be safely called).</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def supportsDetection(self) -&gt; bool:\n\"\"\"Return whether or not the device supports automatic device detection.\n\n    (i.e. whether or not detectDevice() may be safely called).\n    \"\"\"\n    try:\n        return self._mmc.supportsDeviceDetection(self.label)\n    except RuntimeError:\n        return False  # e.g. core devices\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.type","title":"<code>type() -&gt; DeviceType</code>","text":"<p>Return device type.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def type(self) -&gt; DeviceType:\n\"\"\"Return device type.\"\"\"\n    return self._type or self._mmc.getDeviceType(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.unload","title":"<code>unload() -&gt; None</code>","text":"<p>Unload device from the core and adjust all configuration data.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def unload(self) -&gt; None:\n\"\"\"Unload device from the core and adjust all configuration data.\"\"\"\n    return self._mmc.unloadDevice(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.usesDelay","title":"<code>usesDelay() -&gt; bool</code>","text":"<p>Return <code>True</code> if the device will use the delay setting or not.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def usesDelay(self) -&gt; bool:\n\"\"\"Return `True` if the device will use the delay setting or not.\"\"\"\n    return self._mmc.usesDeviceDelay(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._device.Device.wait","title":"<code>wait() -&gt; None</code>","text":"<p>Block the calling thread until device becomes non-busy.</p> Source code in <code>pymmcore_plus/core/_device.py</code> <pre><code>def wait(self) -&gt; None:\n\"\"\"Block the calling thread until device becomes non-busy.\"\"\"\n    self._mmc.waitForDevice(self.label)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.DeviceProperty","title":"<code>pymmcore_plus.DeviceProperty</code>","text":"<p>Convenience view onto a device property.</p> <p>This is the type of object that is returned by <code>pymmcore_plus.CMMCorePlus.getPropertyObject</code></p> <p>Parameters:</p> Name Type Description Default <code>device_label</code> <code>str</code> <p>Device this property belongs to</p> required <code>property_name</code> <code>str</code> <p>Name of this property</p> required <code>mmcore</code> <code>CMMCorePlus</code> <p>CMMCorePlus instance</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; core = CMMCorePlus()\n&gt;&gt;&gt; prop = DeviceProperty('Objective', 'Label', core)\n&gt;&gt;&gt; prop.isValid()  # points to a loaded device property in core\n&gt;&gt;&gt; prop.value\n&gt;&gt;&gt; prop.value = 'Objective-2'  # setter\n&gt;&gt;&gt; prop.isReadOnly()\n&gt;&gt;&gt; prop.hasLimits()\n&gt;&gt;&gt; prop.range()\n&gt;&gt;&gt; prop.dict()  # all the info in one dict.\n</code></pre> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>class DeviceProperty:\n\"\"\"Convenience view onto a device property.\n\n    This is the type of object that is returned by\n    [`pymmcore_plus.CMMCorePlus.getPropertyObject`][]\n\n    Parameters\n    ----------\n    device_label : str\n        Device this property belongs to\n    property_name : str\n        Name of this property\n    mmcore : CMMCorePlus\n        CMMCorePlus instance\n\n    Examples\n    --------\n    &gt;&gt;&gt; core = CMMCorePlus()\n    &gt;&gt;&gt; prop = DeviceProperty('Objective', 'Label', core)\n    &gt;&gt;&gt; prop.isValid()  # points to a loaded device property in core\n    &gt;&gt;&gt; prop.value\n    &gt;&gt;&gt; prop.value = 'Objective-2'  # setter\n    &gt;&gt;&gt; prop.isReadOnly()\n    &gt;&gt;&gt; prop.hasLimits()\n    &gt;&gt;&gt; prop.range()\n    &gt;&gt;&gt; prop.dict()  # all the info in one dict.\n    \"\"\"\n\n    def __init__(\n        self, device_label: str, property_name: str, mmcore: CMMCorePlus\n    ) -&gt; None:\n        self.device = device_label\n        self.name = property_name\n        self._mmc = mmcore\n\n    @cached_property\n    def valueChanged(self) -&gt; _DevicePropValueSignal:\n        return _DevicePropValueSignal(self.device, self.name, self._mmc)\n\n    def isValid(self) -&gt; bool:\n\"\"\"Return `True` if device is loaded and has a property by this name.\"\"\"\n        return self.isLoaded() and self._mmc.hasProperty(self.device, self.name)\n\n    def isLoaded(self) -&gt; bool:\n\"\"\"Return true if the device name is loaded.\"\"\"\n        return self._mmc is not None and self.device in self._mmc.getLoadedDevices()\n\n    @property\n    def core(self) -&gt; CMMCorePlus:\n\"\"\"Return the `CMMCorePlus` instance to which this Property is bound.\"\"\"\n        return self._mmc\n\n    @property\n    def value(self) -&gt; Any:\n\"\"\"Return current property value, cast to appropriate type if applicable.\"\"\"\n        v = self._mmc.getProperty(self.device, self.name)\n        if type_ := self.type().to_python():\n            v = type_(v)\n        return v\n\n    @value.setter\n    def value(self, val: Any) -&gt; None:\n\"\"\"Set current property value.\"\"\"\n        self.setValue(val)\n\n    def fromCache(self) -&gt; Any:\n\"\"\"Return cached property value.\"\"\"\n        return self._mmc.getPropertyFromCache(self.device, self.name)\n\n    def setValue(self, val: Any) -&gt; None:\n\"\"\"Functional alternate to property setter.\"\"\"\n        if self.isReadOnly():\n            import warnings\n\n            warnings.warn(\n                f\"'{self.device}::{self.name}' is a read-only property.\", stacklevel=2\n            )\n        try:\n            self._mmc.setProperty(self.device, self.name, val)\n        except RuntimeError as e:\n            msg = str(e)\n            if allowed := self.allowedValues():\n                msg += f\". Allowed values: {allowed}\"\n            raise RuntimeError(msg) from None\n\n    def isReadOnly(self) -&gt; bool:\n\"\"\"Return `True` if property is read only.\"\"\"\n        return self._mmc.isPropertyReadOnly(self.device, self.name)\n\n    def isPreInit(self) -&gt; bool:\n\"\"\"Return `True` if property must be defined prior to initialization.\"\"\"\n        return self._mmc.isPropertyPreInit(self.device, self.name)\n\n    def hasLimits(self) -&gt; bool:\n\"\"\"Return `True` if property has limits.\"\"\"\n        return self._mmc.hasPropertyLimits(self.device, self.name)\n\n    def lowerLimit(self) -&gt; float:\n\"\"\"Return lower limit if property has limits, or 0 otherwise.\"\"\"\n        return self._mmc.getPropertyLowerLimit(self.device, self.name)\n\n    def upperLimit(self) -&gt; float:\n\"\"\"Return upper limit if property has limits, or 0 otherwise.\"\"\"\n        return self._mmc.getPropertyUpperLimit(self.device, self.name)\n\n    def range(self) -&gt; tuple[float, float]:\n\"\"\"Return (lowerLimit, upperLimit) range tuple.\"\"\"\n        return (self.lowerLimit(), self.upperLimit())\n\n    def type(self) -&gt; PropertyType:\n\"\"\"Return `PropertyType` of this property.\"\"\"\n        return self._mmc.getPropertyType(self.device, self.name)\n\n    def deviceType(self) -&gt; DeviceType:\n\"\"\"Return `DeviceType` of the device owning this property.\"\"\"\n        return self._mmc.getDeviceType(self.device)\n\n    def allowedValues(self) -&gt; tuple[str, ...]:\n\"\"\"Return allowed values for this property, if contstrained.\"\"\"\n        # https://github.com/micro-manager/mmCoreAndDevices/issues/172\n        allowed = self._mmc.getAllowedPropertyValues(self.device, self.name)\n        if not allowed and self.deviceType() is DeviceType.StateDevice:\n            if self.name == g_Keyword_State:\n                n_states = self._mmc.getNumberOfStates(self.device)\n                allowed = tuple(str(i) for i in range(n_states))\n            elif self.name == g_Keyword_Label:\n                allowed = self._mmc.getStateLabels(self.device)\n        return allowed\n\n    def isSequenceable(self) -&gt; bool:\n\"\"\"Return `True` if property can be used in a sequence.\"\"\"\n        return self._mmc.isPropertySequenceable(self.device, self.name)\n\n    def sequenceMaxLength(self) -&gt; int:\n\"\"\"Return maximum number of property events that can be put in a sequence.\"\"\"\n        return self._mmc.getPropertySequenceMaxLength(self.device, self.name)\n\n    def loadSequence(self, eventSequence: Sequence[str]) -&gt; None:\n\"\"\"Transfer a sequence of events/states/whatever to the device.\n\n        Parameters\n        ----------\n        eventSequence : Sequence[str]\n            The sequence of events/states that the device will execute in response\n            to external triggers\n        \"\"\"\n        self._mmc.loadPropertySequence(self.device, self.name, eventSequence)\n\n    def startSequence(self) -&gt; None:\n\"\"\"Start an ongoing sequence of triggered events in a property.\"\"\"\n        self._mmc.startPropertySequence(self.device, self.name)\n\n    def stopSequence(self) -&gt; None:\n\"\"\"Stop an ongoing sequence of triggered events in a property.\"\"\"\n        self._mmc.stopPropertySequence(self.device, self.name)\n\n    def dict(self) -&gt; InfoDict:\n\"\"\"Return dict of info about this Property.\n\n        Returns an [`InfoDict`][pymmcore_plus.core._property.InfoDict] with the\n        following keys: `\"valid\", \"value\", \"type\", \"device_type\", \"read_only\",\n        \"pre_init\", \"range\", \"allowed\"`.\n\n        If the device is invalid or not loaded, the `\"valid\"` key will be `False`\n        and the rest of the keys will be `None`.\n        \"\"\"\n        if self.isValid():\n            return {\n                \"valid\": True,\n                \"value\": self.value,\n                \"type\": self.type().to_json(),\n                \"device_type\": self.deviceType().name,\n                \"read_only\": self.isReadOnly(),\n                \"sequenceable\": self.isSequenceable(),\n                \"sequence_max_length\": (\n                    self.sequenceMaxLength() if self.isSequenceable() else None\n                ),\n                \"pre_init\": self.isPreInit(),\n                \"range\": self.range() if self.hasLimits() else None,\n                \"allowed_values\": self.allowedValues(),\n            }\n        else:\n            return {\n                \"valid\": False,\n                \"value\": None,\n                \"type\": None,\n                \"device_type\": None,\n                \"read_only\": None,\n                \"sequenceable\": None,\n                \"sequence_max_length\": None,\n                \"pre_init\": None,\n                \"range\": None,\n                \"allowed_values\": None,\n            }\n\n    InfoDict = InfoDict\n\n    def __repr__(self) -&gt; str:\n        v = f\"value={self.value!r}\" if self.isValid() else \"INVALID\"\n        core = repr(self._mmc).strip(\"&lt;&gt;\")\n        return f\"&lt;Property '{self.device}::{self.name}' on {core}: {v}&gt;\"\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.InfoDict","title":"<code>InfoDict = InfoDict</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.device","title":"<code>device = device_label</code>  <code>instance-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.name","title":"<code>name = property_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.allowedValues","title":"<code>allowedValues() -&gt; tuple[str, ...]</code>","text":"<p>Return allowed values for this property, if contstrained.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def allowedValues(self) -&gt; tuple[str, ...]:\n\"\"\"Return allowed values for this property, if contstrained.\"\"\"\n    # https://github.com/micro-manager/mmCoreAndDevices/issues/172\n    allowed = self._mmc.getAllowedPropertyValues(self.device, self.name)\n    if not allowed and self.deviceType() is DeviceType.StateDevice:\n        if self.name == g_Keyword_State:\n            n_states = self._mmc.getNumberOfStates(self.device)\n            allowed = tuple(str(i) for i in range(n_states))\n        elif self.name == g_Keyword_Label:\n            allowed = self._mmc.getStateLabels(self.device)\n    return allowed\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.core","title":"<code>core() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>Return the <code>CMMCorePlus</code> instance to which this Property is bound.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>@property\ndef core(self) -&gt; CMMCorePlus:\n\"\"\"Return the `CMMCorePlus` instance to which this Property is bound.\"\"\"\n    return self._mmc\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.deviceType","title":"<code>deviceType() -&gt; DeviceType</code>","text":"<p>Return <code>DeviceType</code> of the device owning this property.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def deviceType(self) -&gt; DeviceType:\n\"\"\"Return `DeviceType` of the device owning this property.\"\"\"\n    return self._mmc.getDeviceType(self.device)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.dict","title":"<code>dict() -&gt; InfoDict</code>","text":"<p>Return dict of info about this Property.</p> <p>Returns an <code>InfoDict</code> with the following keys: <code>\"valid\", \"value\", \"type\", \"device_type\", \"read_only\", \"pre_init\", \"range\", \"allowed\"</code>.</p> <p>If the device is invalid or not loaded, the <code>\"valid\"</code> key will be <code>False</code> and the rest of the keys will be <code>None</code>.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def dict(self) -&gt; InfoDict:\n\"\"\"Return dict of info about this Property.\n\n    Returns an [`InfoDict`][pymmcore_plus.core._property.InfoDict] with the\n    following keys: `\"valid\", \"value\", \"type\", \"device_type\", \"read_only\",\n    \"pre_init\", \"range\", \"allowed\"`.\n\n    If the device is invalid or not loaded, the `\"valid\"` key will be `False`\n    and the rest of the keys will be `None`.\n    \"\"\"\n    if self.isValid():\n        return {\n            \"valid\": True,\n            \"value\": self.value,\n            \"type\": self.type().to_json(),\n            \"device_type\": self.deviceType().name,\n            \"read_only\": self.isReadOnly(),\n            \"sequenceable\": self.isSequenceable(),\n            \"sequence_max_length\": (\n                self.sequenceMaxLength() if self.isSequenceable() else None\n            ),\n            \"pre_init\": self.isPreInit(),\n            \"range\": self.range() if self.hasLimits() else None,\n            \"allowed_values\": self.allowedValues(),\n        }\n    else:\n        return {\n            \"valid\": False,\n            \"value\": None,\n            \"type\": None,\n            \"device_type\": None,\n            \"read_only\": None,\n            \"sequenceable\": None,\n            \"sequence_max_length\": None,\n            \"pre_init\": None,\n            \"range\": None,\n            \"allowed_values\": None,\n        }\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.fromCache","title":"<code>fromCache() -&gt; Any</code>","text":"<p>Return cached property value.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def fromCache(self) -&gt; Any:\n\"\"\"Return cached property value.\"\"\"\n    return self._mmc.getPropertyFromCache(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.hasLimits","title":"<code>hasLimits() -&gt; bool</code>","text":"<p>Return <code>True</code> if property has limits.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def hasLimits(self) -&gt; bool:\n\"\"\"Return `True` if property has limits.\"\"\"\n    return self._mmc.hasPropertyLimits(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isLoaded","title":"<code>isLoaded() -&gt; bool</code>","text":"<p>Return true if the device name is loaded.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isLoaded(self) -&gt; bool:\n\"\"\"Return true if the device name is loaded.\"\"\"\n    return self._mmc is not None and self.device in self._mmc.getLoadedDevices()\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isPreInit","title":"<code>isPreInit() -&gt; bool</code>","text":"<p>Return <code>True</code> if property must be defined prior to initialization.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isPreInit(self) -&gt; bool:\n\"\"\"Return `True` if property must be defined prior to initialization.\"\"\"\n    return self._mmc.isPropertyPreInit(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isReadOnly","title":"<code>isReadOnly() -&gt; bool</code>","text":"<p>Return <code>True</code> if property is read only.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isReadOnly(self) -&gt; bool:\n\"\"\"Return `True` if property is read only.\"\"\"\n    return self._mmc.isPropertyReadOnly(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isSequenceable","title":"<code>isSequenceable() -&gt; bool</code>","text":"<p>Return <code>True</code> if property can be used in a sequence.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isSequenceable(self) -&gt; bool:\n\"\"\"Return `True` if property can be used in a sequence.\"\"\"\n    return self._mmc.isPropertySequenceable(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.isValid","title":"<code>isValid() -&gt; bool</code>","text":"<p>Return <code>True</code> if device is loaded and has a property by this name.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def isValid(self) -&gt; bool:\n\"\"\"Return `True` if device is loaded and has a property by this name.\"\"\"\n    return self.isLoaded() and self._mmc.hasProperty(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.loadSequence","title":"<code>loadSequence(eventSequence: Sequence[str]) -&gt; None</code>","text":"<p>Transfer a sequence of events/states/whatever to the device.</p> <p>Parameters:</p> Name Type Description Default <code>eventSequence</code> <code>Sequence[str]</code> <p>The sequence of events/states that the device will execute in response to external triggers</p> required Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def loadSequence(self, eventSequence: Sequence[str]) -&gt; None:\n\"\"\"Transfer a sequence of events/states/whatever to the device.\n\n    Parameters\n    ----------\n    eventSequence : Sequence[str]\n        The sequence of events/states that the device will execute in response\n        to external triggers\n    \"\"\"\n    self._mmc.loadPropertySequence(self.device, self.name, eventSequence)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.lowerLimit","title":"<code>lowerLimit() -&gt; float</code>","text":"<p>Return lower limit if property has limits, or 0 otherwise.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def lowerLimit(self) -&gt; float:\n\"\"\"Return lower limit if property has limits, or 0 otherwise.\"\"\"\n    return self._mmc.getPropertyLowerLimit(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.range","title":"<code>range() -&gt; tuple[float, float]</code>","text":"<p>Return (lowerLimit, upperLimit) range tuple.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def range(self) -&gt; tuple[float, float]:\n\"\"\"Return (lowerLimit, upperLimit) range tuple.\"\"\"\n    return (self.lowerLimit(), self.upperLimit())\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.sequenceMaxLength","title":"<code>sequenceMaxLength() -&gt; int</code>","text":"<p>Return maximum number of property events that can be put in a sequence.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def sequenceMaxLength(self) -&gt; int:\n\"\"\"Return maximum number of property events that can be put in a sequence.\"\"\"\n    return self._mmc.getPropertySequenceMaxLength(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.setValue","title":"<code>setValue(val: Any) -&gt; None</code>","text":"<p>Functional alternate to property setter.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def setValue(self, val: Any) -&gt; None:\n\"\"\"Functional alternate to property setter.\"\"\"\n    if self.isReadOnly():\n        import warnings\n\n        warnings.warn(\n            f\"'{self.device}::{self.name}' is a read-only property.\", stacklevel=2\n        )\n    try:\n        self._mmc.setProperty(self.device, self.name, val)\n    except RuntimeError as e:\n        msg = str(e)\n        if allowed := self.allowedValues():\n            msg += f\". Allowed values: {allowed}\"\n        raise RuntimeError(msg) from None\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.startSequence","title":"<code>startSequence() -&gt; None</code>","text":"<p>Start an ongoing sequence of triggered events in a property.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def startSequence(self) -&gt; None:\n\"\"\"Start an ongoing sequence of triggered events in a property.\"\"\"\n    self._mmc.startPropertySequence(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.stopSequence","title":"<code>stopSequence() -&gt; None</code>","text":"<p>Stop an ongoing sequence of triggered events in a property.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def stopSequence(self) -&gt; None:\n\"\"\"Stop an ongoing sequence of triggered events in a property.\"\"\"\n    self._mmc.stopPropertySequence(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.type","title":"<code>type() -&gt; PropertyType</code>","text":"<p>Return <code>PropertyType</code> of this property.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def type(self) -&gt; PropertyType:\n\"\"\"Return `PropertyType` of this property.\"\"\"\n    return self._mmc.getPropertyType(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.upperLimit","title":"<code>upperLimit() -&gt; float</code>","text":"<p>Return upper limit if property has limits, or 0 otherwise.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>def upperLimit(self) -&gt; float:\n\"\"\"Return upper limit if property has limits, or 0 otherwise.\"\"\"\n    return self._mmc.getPropertyUpperLimit(self.device, self.name)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.value","title":"<code>value() -&gt; Any</code>  <code>property</code> <code>writable</code>","text":"<p>Return current property value, cast to appropriate type if applicable.</p> Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>@property\ndef value(self) -&gt; Any:\n\"\"\"Return current property value, cast to appropriate type if applicable.\"\"\"\n    v = self._mmc.getProperty(self.device, self.name)\n    if type_ := self.type().to_python():\n        v = type_(v)\n    return v\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.DeviceProperty.valueChanged","title":"<code>valueChanged() -&gt; _DevicePropValueSignal</code>  <code>cached</code> <code>property</code>","text":"Source code in <code>pymmcore_plus/core/_property.py</code> <pre><code>@cached_property\ndef valueChanged(self) -&gt; _DevicePropValueSignal:\n    return _DevicePropValueSignal(self.device, self.name, self._mmc)\n</code></pre>"},{"location":"api/device/#pymmcore_plus.core._property.InfoDict","title":"<code>pymmcore_plus.core._property.InfoDict</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.allowed_values","title":"<code>allowed_values: tuple[str, ...] | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.device_type","title":"<code>device_type: str | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.pre_init","title":"<code>pre_init: bool | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.range","title":"<code>range: tuple[float, float] | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.read_only","title":"<code>read_only: bool | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.sequence_max_length","title":"<code>sequence_max_length: int | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.sequenceable","title":"<code>sequenceable: bool | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.type","title":"<code>type: str | None</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.valid","title":"<code>valid: bool</code>  <code>class-attribute</code>","text":""},{"location":"api/device/#pymmcore_plus.core._property.InfoDict.value","title":"<code>value: Any | None</code>  <code>class-attribute</code>","text":""},{"location":"api/events/","title":"Events","text":"<p>Both the <code>CMMCorePlus</code> object and the <code>CMMCorePlus.mda</code> (<code>MDARunner</code>) objects have <code>events</code> attributes that can be used to register callbacks for events that occur as the state of the microscope changes, or as an acquisition sequences progresses.</p> <p>These events are defined here.</p>"},{"location":"api/events/#pymmcore_plus.core.events.PCoreSignaler","title":"<code>pymmcore_plus.core.events.PCoreSignaler</code>","text":"<p>Declares the protocol for all signals that will be emitted from CMMCorePlus.</p> <p>The main instance of this interface is available on the <code>CMMCorePlus</code> object at the <code>events</code> attribute. Each signal on <code>events</code> is an object has a <code>connect</code> and a <code>disconnect</code> method that you can use to connect/disconnect your own callback functions.  <code>connect</code> and <code>disconnect</code> accept a single argument, which is a callable that will be called when the signal is emitted. The callable should accept no more positional arguments than the signal emits (noted for each signal below), but may accept fewer.</p> <p>Note</p> <p>These events are a superset of those emitted by MMEventCallback in the MMCore C++ library.  The \"on\" prefix has been removed from the names here and the first letter lower cased.</p> <p>Important</p> <p>In the core C++ library (and in <code>pymmcore</code>), the emission of many of these events is left to the discretion of the device adapter.  In <code>pymmcore_plus</code>, we attempt to emit these events in a more consistent manner (e.g. by checking a particular value before and after calling into the C++ library).  So, the emission of these events is not guaranteed to be 1:1 with the C++ library; however, it should be easier to follow the state of the core when using <code>pymmcore_plus.CMMCorePlus</code>.</p> <p>Examples:</p> <p>To connect to the <code>onExposureChanged</code> event emitted by MMCore, you would connect to the <code>exposureChanged</code> signal on this class:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\n\ndef on_exposure_changed(device: str, new_exposure: float):\n    print(f\"Exposure changed for {device} to {new_exposure}\")\n\ncore.events.exposureChanged.connect(my_callback)\n</code></pre> <p>Events may also be connected as a decorator:</p> <pre><code>@core.events.exposureChanged.connect\ndef on_exposure_changed(device: str, new_exposure: float):\n    ...\n</code></pre>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.SLMExposureChanged","title":"<code>SLMExposureChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, newExposure: float)</code> when the exposure of the SLM device changes.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.XYStagePositionChanged","title":"<code>XYStagePositionChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, xpos: float, ypos: float)</code> when an XY stage position has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.autoShutterSet","title":"<code>autoShutterSet: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(bool)</code> when the auto shutter setting is changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.channelGroupChanged","title":"<code>channelGroupChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(newChannelGroupName: str)</code> when a channel group has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configDefined","title":"<code>configDefined: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, str, str, str, str)</code> when a config is defined.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configDeleted","title":"<code>configDeleted: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, str)</code> when a config is deleted.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configGroupChanged","title":"<code>configGroupChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(groupName: str, newConfigName: str)</code> when a config group has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configGroupDeleted","title":"<code>configGroupDeleted: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str)</code> when a config group is deleted.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.configSet","title":"<code>configSet: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, str)</code> when a config has been set.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.continuousSequenceAcquisitionStarted","title":"<code>continuousSequenceAcquisitionStarted: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits with no arguments when continuous sequence acquisition is started.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.exposureChanged","title":"<code>exposureChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, newExposure: float)</code> when an exposure has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.imageSnapped","title":"<code>imageSnapped: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(np.ndarray)</code> whenever snap is called.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.mdaEngineRegistered","title":"<code>mdaEngineRegistered: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(MDAEngine, MDAEngine)</code> when an MDAEngine is registered.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.pixelSizeAffineChanged","title":"<code>pixelSizeAffineChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(float, float, float, float, float, float)</code> when the pixel size affine has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.pixelSizeChanged","title":"<code>pixelSizeChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(newPixelSizeUm: float)</code> when the pixel size has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.propertiesChanged","title":"<code>propertiesChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits with no arguments when properties have changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.propertyChanged","title":"<code>propertyChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, : propName: str, propValue: str)</code> when a specific property has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.roiSet","title":"<code>roiSet: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, int, int, int, int)</code> when an ROI is set.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.sequenceAcquisitionStarted","title":"<code>sequenceAcquisitionStarted: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str, int, float, bool)</code> when sequence acquisition is started.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.sequenceAcquisitionStopped","title":"<code>sequenceAcquisitionStopped: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(str)</code> when sequence acquisition is stopped.</p> <p> This signal is unique to <code>pymmcore-plus</code>.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.stagePositionChanged","title":"<code>stagePositionChanged: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(name: str, pos: float)</code> when a stage position has changed.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.systemConfigurationLoaded","title":"<code>systemConfigurationLoaded: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits with no arguments when the system configuration has been loaded.</p>"},{"location":"api/events/#pymmcore_plus.core.events._protocol.PCoreSignaler.devicePropertyChanged","title":"<code>devicePropertyChanged(device: str, property: Optional[str] = None) -&gt; PSignalInstance</code>","text":"<p>Return object to connect/disconnect to device/property-specific changes.</p> <p>Note that the callback provided to <code>.connect()</code> must take two parameters (property_name, new_value) if only <code>device</code> is provided, and one parameter (new_value) of both <code>device</code> and <code>property</code> are provided.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>str</code> <p>A device label</p> required <code>property</code> <code>Optional[str]</code> <p>Optional property label.  If not provided, all property changes on <code>device</code> will trigger an event emission. by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>_PropertySignal</code> <p>Object with <code>connect</code> and <code>disconnect</code> methods that attach a callback to the change event of a specific property or device.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; core.events.devicePropertyChanged('Camera', 'Gain').connect(callback)\n&gt;&gt;&gt; core.events.devicePropertyChanged('Camera').connect(callback)\n</code></pre>"},{"location":"api/events/#pymmcore_plus.mda.events.PMDASignaler","title":"<code>pymmcore_plus.mda.events.PMDASignaler</code>","text":"<p>Declares the protocol for all signals that will be emitted from <code>pymmcore_plus.mda.MDARunner</code>.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.frameReady","title":"<code>frameReady: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(img, MDAEvent, metadata)</code> after an image is acquired during an acquisition sequence.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.sequenceCanceled","title":"<code>sequenceCanceled: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(sequence: MDASequence)</code> when an acquisition sequence is canceled.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.sequenceFinished","title":"<code>sequenceFinished: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(sequence: MDASequence)</code> when an acquisition sequence is finished.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.sequencePauseToggled","title":"<code>sequencePauseToggled: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(paused: bool)</code> when an acquisition sequence is paused or unpaused.</p>"},{"location":"api/events/#pymmcore_plus.mda.events._protocol.PMDASignaler.sequenceStarted","title":"<code>sequenceStarted: PSignal</code>  <code>class-attribute</code>","text":"<p>Emits <code>(sequence: MDASequence)</code> when an acquisition sequence is started.</p>"},{"location":"api/mda/","title":"Multi-Dimensional Acquisition","text":"<p>The <code>mda</code> attribute on the <code>CMMCorePlus</code> object provides a high-level interface for running multi-dimensional microscopy experiments.</p>"},{"location":"api/mda/#pymmcore_plus.mda.MDARunner","title":"<code>pymmcore_plus.mda.MDARunner</code>","text":"<p>Object that executes a multi-dimensional experiment using an MDAEngine.</p> <p>This object is available at <code>CMMCorePlus.mda</code>.</p> <p>This is the main object that runs a multi-dimensional experiment; it does so by driving an acquisition engine that implements the <code>PMDAEngine</code> protocol.  It emits signals at specific times during the experiment (see <code>PMDASignaler</code> for details on the signals that are available to connect to and when they are emitted).</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>class MDARunner:\n\"\"\"Object that executes a multi-dimensional experiment using an MDAEngine.\n\n    This object is available at [`CMMCorePlus.mda`][pymmcore_plus.CMMCorePlus.mda].\n\n    This is the main object that runs a multi-dimensional experiment; it does so by\n    driving an acquisition engine that implements the\n    [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] protocol.  It emits signals at specific\n    times during the experiment (see\n    [`PMDASignaler`][pymmcore_plus.mda.events.PMDASignaler] for details on the signals\n    that are available to connect to and when they are emitted).\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._engine: PMDAEngine | None = None\n        self._signals = _get_auto_MDA_callback_class()()\n        self._running = False\n        self._paused = False\n        self._paused_time: float = 0\n        self._pause_interval: float = 0.1  # sec to wait between checking pause state\n\n        self._canceled = False\n        self._sequence: MDASequence | None = None\n        self._reset_timer()\n\n    def set_engine(self, engine: PMDAEngine) -&gt; PMDAEngine | None:\n\"\"\"Set the [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] to use for the MDA run.\"\"\"  # noqa: E501\n        if not isinstance(engine, PMDAEngine):\n            raise TypeError(\"Engine does not conform to the Engine protocol.\")\n\n        if self.is_running():  # pragma: no cover\n            raise RuntimeError(\n                \"Cannot register a new engine when the current engine is running \"\n                \"an acquistion. Please cancel the current engine's acquistion \"\n                \"before registering\"\n            )\n\n        old_engine, self._engine = self._engine, engine\n        return old_engine\n\n    # NOTE:\n    # this return annotation is a lie, since the user can set it to their own engine.\n    # but in MOST cases, this is the engine that will be used by default, so it's\n    # convenient for IDEs to point to this rather than the abstract protocol.\n    @property\n    def engine(self) -&gt; MDAEngine | None:\n\"\"\"The [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] that is currently being used.\"\"\"  # noqa: E501\n        return self._engine  # type: ignore\n\n    @property\n    def events(self) -&gt; PMDASignaler:\n\"\"\"Signals that are emitted during the MDA run.\n\n        See [`PMDASignaler`][pymmcore_plus.mda.PMDASignaler] for details on the\n        signals that are available to connect to.\n        \"\"\"\n        return self._signals\n\n    def is_running(self) -&gt; bool:\n\"\"\"Return True if an acquistion is currently underway.\n\n        This will return True at any point between the emission of the\n        [`sequenceStarted`][pymmcore_plus.mda.PMDASignaler.sequenceStarted] and\n        [`sequenceFinished`][pymmcore_plus.mda.PMDASignaler.sequenceFinished] signals,\n        including when the acquisition is currently paused.\n\n        Returns\n        -------\n        bool\n            Whether an acquistion is underway.\n        \"\"\"\n        return self._running\n\n    def is_paused(self) -&gt; bool:\n\"\"\"Return True if the acquistion is currently paused.\n\n        Use `toggle_pause` to change the paused state.\n\n        Returns\n        -------\n        bool\n            Whether the current acquistion is paused.\n        \"\"\"\n        return self._paused\n\n    def cancel(self) -&gt; None:\n\"\"\"Cancel the currently running acquisition.\n\n        This is a no-op if no acquisition is currently running.\n        If an acquisition is running then this will cancel the acquistion and\n        a sequenceCanceled signal, followed by a sequenceFinished signal will\n        be emitted.\n        \"\"\"\n        self._canceled = True\n        self._paused_time = 0\n\n    def toggle_pause(self) -&gt; None:\n\"\"\"Toggle the paused state of the current acquisition.\n\n        To get whether the acquisition is currently paused use the\n        [`is_paused`][pymmcore_plus.mda.MDARunner.is_paused] method. This method is a\n        no-op if no acquistion is currently underway.\n        \"\"\"\n        if self.is_running():\n            self._paused = not self._paused\n            self._signals.sequencePauseToggled.emit(self._paused)\n\n    def run(self, events: Iterable[MDAEvent]) -&gt; None:\n\"\"\"Run the multi-dimensional acquistion defined by `sequence`.\n\n        Most users should not use this directly as it will block further\n        execution. Instead, use the\n        [`CMMCorePlus.run_mda`][pymmcore_plus.CMMCorePlus.run_mda] method which will\n        run on a thread.\n\n        Parameters\n        ----------\n        events : Iterable[MDAEvent]\n            An iterable of `useq.MDAEvents` objects to execute.\n        \"\"\"\n        error = None\n        sequence = events if isinstance(events, MDASequence) else GeneratorMDASequence()\n        try:\n            engine = self._prepare_to_run(sequence)\n            self._run(engine, events)\n        except Exception as e:\n            error = e\n        with exceptions_logged():\n            self._finish_run(sequence)\n        if error is not None:\n            raise error\n\n    def _run(self, engine: PMDAEngine, events: Iterable[MDAEvent]) -&gt; None:\n\"\"\"Main execution of events, inside the try/except block of `run`.\"\"\"\n        teardown_event = getattr(engine, \"teardown_event\", lambda e: None)\n        event_iterator = getattr(engine, \"event_iterator\", iter)\n        _events: Iterator[MDAEvent] = event_iterator(events)\n\n        for event in _events:\n            # If cancelled break out of the loop\n            if self._wait_until_event(event) or not self._running:\n                break\n\n            logger.info(\"%s\", event)\n            engine.setup_event(event)\n\n            output = engine.exec_event(event) or ()  # in case output is None\n\n            for payload in output:\n                img, event, meta = payload\n                if \"PerfCounter\" in meta:\n                    meta[\"ElapsedTime-ms\"] = (meta[\"PerfCounter\"] - self._t0) * 1000\n                meta[\"Event\"] = event\n                with exceptions_logged():\n                    self._signals.frameReady.emit(img, event, meta)\n\n            teardown_event(event)\n\n    def _prepare_to_run(self, sequence: MDASequence) -&gt; PMDAEngine:\n\"\"\"Set up for the MDA run.\n\n        Parameters\n        ----------\n        sequence : MDASequence\n            The sequence of events to run.\n        \"\"\"\n        if not self._engine:  # pragma: no cover\n            raise RuntimeError(\"No MDAEngine set.\")\n\n        self._running = True\n        self._paused = False\n        self._paused_time = 0.0\n        self._sequence = sequence\n\n        self._engine.setup_sequence(sequence)\n        logger.info(\"MDA Started: %s\", sequence)\n\n        self._signals.sequenceStarted.emit(sequence)\n        self._reset_timer()\n        return self._engine\n\n    def _reset_timer(self) -&gt; None:\n        self._t0 = time.perf_counter()  # reference time, in seconds\n\n    def _time_elapsed(self) -&gt; float:\n        return time.perf_counter() - self._t0\n\n    def _check_canceled(self) -&gt; bool:\n\"\"\"Return True if the cancel method has been called and emit relevant signals.\n\n        If cancelled, this relies on the `self._sequence` being the current sequence\n        in order to emit a `sequenceCanceled` signal.\n\n        Returns\n        -------\n        bool\n            Whether the MDA has been canceled.\n        \"\"\"\n        if self._canceled:\n            logger.warning(\"MDA Canceled: %s\", self._sequence)\n            self._signals.sequenceCanceled.emit(self._sequence)\n            self._canceled = False\n            return True\n        return False\n\n    def _wait_until_event(self, event: MDAEvent) -&gt; bool:\n\"\"\"Wait until the event's min start time, checking for pauses cancellations.\n\n        Parameters\n        ----------\n        event : MDAEvent\n            The event to wait for.\n\n        Returns\n        -------\n        bool\n            Whether the MDA was cancelled while waiting.\n        \"\"\"\n        if not self.is_running():\n            return False  # pragma: no cover\n        if self._check_canceled():\n            return True\n        while self.is_paused() and not self._canceled:\n            self._paused_time += self._pause_interval  # fixme: be more precise\n            time.sleep(self._pause_interval)\n\n            if self._check_canceled():\n                return True\n\n        # FIXME: this is actually the only place where the runner assumes our event is\n        # an MDAevent.  For everything else, the engine is technically the only thing\n        # that cares about the event time.\n        # So this whole method could potentially be moved to the engine.\n        if event.min_start_time:\n            go_at = event.min_start_time + self._paused_time\n            # We need to enter a loop here checking paused and canceled.\n            # otherwise you'll potentially wait a long time to cancel\n            to_go = go_at - self._time_elapsed()\n            while to_go &gt; 0:\n                while self._paused and not self._canceled:\n                    self._paused_time += self._pause_interval  # fixme: be more precise\n                    to_go += self._pause_interval\n                    time.sleep(self._pause_interval)\n\n                if self._canceled:\n                    break\n                time.sleep(min(to_go, 0.5))\n                to_go = go_at - self._time_elapsed()\n\n        # check canceled again in case it was canceled\n        # during the waiting loop\n        return self._check_canceled()\n\n    def _finish_run(self, sequence: MDASequence) -&gt; None:\n\"\"\"To be called at the end of an acquisition.\n\n        Parameters\n        ----------\n        sequence : MDASequence\n            The sequence that was finished.\n        \"\"\"\n        self._running = False\n        self._canceled = False\n\n        if hasattr(self._engine, \"teardown_sequence\"):\n            self._engine.teardown_sequence(sequence)  # type: ignore\n\n        logger.info(\"MDA Finished: %s\", sequence)\n        self._signals.sequenceFinished.emit(sequence)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.cancel","title":"<code>cancel() -&gt; None</code>","text":"<p>Cancel the currently running acquisition.</p> <p>This is a no-op if no acquisition is currently running. If an acquisition is running then this will cancel the acquistion and a sequenceCanceled signal, followed by a sequenceFinished signal will be emitted.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def cancel(self) -&gt; None:\n\"\"\"Cancel the currently running acquisition.\n\n    This is a no-op if no acquisition is currently running.\n    If an acquisition is running then this will cancel the acquistion and\n    a sequenceCanceled signal, followed by a sequenceFinished signal will\n    be emitted.\n    \"\"\"\n    self._canceled = True\n    self._paused_time = 0\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.engine","title":"<code>engine() -&gt; MDAEngine | None</code>  <code>property</code>","text":"<p>The <code>PMDAEngine</code> that is currently being used.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>@property\ndef engine(self) -&gt; MDAEngine | None:\n\"\"\"The [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] that is currently being used.\"\"\"  # noqa: E501\n    return self._engine  # type: ignore\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.events","title":"<code>events() -&gt; PMDASignaler</code>  <code>property</code>","text":"<p>Signals that are emitted during the MDA run.</p> <p>See <code>PMDASignaler</code> for details on the signals that are available to connect to.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>@property\ndef events(self) -&gt; PMDASignaler:\n\"\"\"Signals that are emitted during the MDA run.\n\n    See [`PMDASignaler`][pymmcore_plus.mda.PMDASignaler] for details on the\n    signals that are available to connect to.\n    \"\"\"\n    return self._signals\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.is_paused","title":"<code>is_paused() -&gt; bool</code>","text":"<p>Return True if the acquistion is currently paused.</p> <p>Use <code>toggle_pause</code> to change the paused state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the current acquistion is paused.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def is_paused(self) -&gt; bool:\n\"\"\"Return True if the acquistion is currently paused.\n\n    Use `toggle_pause` to change the paused state.\n\n    Returns\n    -------\n    bool\n        Whether the current acquistion is paused.\n    \"\"\"\n    return self._paused\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.is_running","title":"<code>is_running() -&gt; bool</code>","text":"<p>Return True if an acquistion is currently underway.</p> <p>This will return True at any point between the emission of the <code>sequenceStarted</code> and <code>sequenceFinished</code> signals, including when the acquisition is currently paused.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether an acquistion is underway.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def is_running(self) -&gt; bool:\n\"\"\"Return True if an acquistion is currently underway.\n\n    This will return True at any point between the emission of the\n    [`sequenceStarted`][pymmcore_plus.mda.PMDASignaler.sequenceStarted] and\n    [`sequenceFinished`][pymmcore_plus.mda.PMDASignaler.sequenceFinished] signals,\n    including when the acquisition is currently paused.\n\n    Returns\n    -------\n    bool\n        Whether an acquistion is underway.\n    \"\"\"\n    return self._running\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.run","title":"<code>run(events: Iterable[MDAEvent]) -&gt; None</code>","text":"<p>Run the multi-dimensional acquistion defined by <code>sequence</code>.</p> <p>Most users should not use this directly as it will block further execution. Instead, use the <code>CMMCorePlus.run_mda</code> method which will run on a thread.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>Iterable[MDAEvent]</code> <p>An iterable of <code>useq.MDAEvents</code> objects to execute.</p> required Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def run(self, events: Iterable[MDAEvent]) -&gt; None:\n\"\"\"Run the multi-dimensional acquistion defined by `sequence`.\n\n    Most users should not use this directly as it will block further\n    execution. Instead, use the\n    [`CMMCorePlus.run_mda`][pymmcore_plus.CMMCorePlus.run_mda] method which will\n    run on a thread.\n\n    Parameters\n    ----------\n    events : Iterable[MDAEvent]\n        An iterable of `useq.MDAEvents` objects to execute.\n    \"\"\"\n    error = None\n    sequence = events if isinstance(events, MDASequence) else GeneratorMDASequence()\n    try:\n        engine = self._prepare_to_run(sequence)\n        self._run(engine, events)\n    except Exception as e:\n        error = e\n    with exceptions_logged():\n        self._finish_run(sequence)\n    if error is not None:\n        raise error\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.set_engine","title":"<code>set_engine(engine: PMDAEngine) -&gt; PMDAEngine | None</code>","text":"<p>Set the <code>PMDAEngine</code> to use for the MDA run.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def set_engine(self, engine: PMDAEngine) -&gt; PMDAEngine | None:\n\"\"\"Set the [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] to use for the MDA run.\"\"\"  # noqa: E501\n    if not isinstance(engine, PMDAEngine):\n        raise TypeError(\"Engine does not conform to the Engine protocol.\")\n\n    if self.is_running():  # pragma: no cover\n        raise RuntimeError(\n            \"Cannot register a new engine when the current engine is running \"\n            \"an acquistion. Please cancel the current engine's acquistion \"\n            \"before registering\"\n        )\n\n    old_engine, self._engine = self._engine, engine\n    return old_engine\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._runner.MDARunner.toggle_pause","title":"<code>toggle_pause() -&gt; None</code>","text":"<p>Toggle the paused state of the current acquisition.</p> <p>To get whether the acquisition is currently paused use the <code>is_paused</code> method. This method is a no-op if no acquistion is currently underway.</p> Source code in <code>pymmcore_plus/mda/_runner.py</code> <pre><code>def toggle_pause(self) -&gt; None:\n\"\"\"Toggle the paused state of the current acquisition.\n\n    To get whether the acquisition is currently paused use the\n    [`is_paused`][pymmcore_plus.mda.MDARunner.is_paused] method. This method is a\n    no-op if no acquistion is currently underway.\n    \"\"\"\n    if self.is_running():\n        self._paused = not self._paused\n        self._signals.sequencePauseToggled.emit(self._paused)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda.PMDAEngine","title":"<code>pymmcore_plus.mda.PMDAEngine</code>","text":"<p>Protocol that all MDA engines must implement.</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.event_iterator","title":"<code>event_iterator(events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]</code>","text":"<p>Wrapper on the event iterator.</p> <p>Optional.</p> <p>This can be used to wrap the event iterator to perform any event merging (e.g. if the engine supports HardwareSequencing) or event modification. The default implementation is just <code>iter(events)</code>.</p> <p>Be careful when using this method.  It is powerful and can result in unexpected event iteration if used incorrectly.</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.exec_event","title":"<code>exec_event(event: MDAEvent) -&gt; Sequence[PImagePayload]</code>  <code>abstractmethod</code>","text":"<p>Execute <code>event</code>.</p> <p>This method is called after <code>setup_event</code> and is responsible for executing the event.  The default assumption is to acquire an image, but more elaborate events will be possible.</p> <p>The protocol for the returned object is still under development.  However, if the returned object has an <code>image</code> attribute, then the <code>MDARunner</code> will emit a <code>frameReady</code> signal</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.setup_event","title":"<code>setup_event(event: MDAEvent) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Prepare state of system (hardware, etc.) for <code>event</code>.</p> <p>This method is called before each event in the sequence.  It is responsible for preparing the state of the system for the event. The engine should be in a state where it can call <code>exec_event</code> without any additional preparation.  (This means that the engine should perform any waits or blocks required for system state changes to complete.)</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.setup_sequence","title":"<code>setup_sequence(sequence: MDASequence) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Setup state of system (hardware, etc.) before an MDA is run.</p> <p>This method is called once at the beginning of a sequence.</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.teardown_event","title":"<code>teardown_event(event: MDAEvent) -&gt; None</code>","text":"<p>Teardown state of system (hardware, etc.) after <code>event</code>.</p> <p>Optional.</p> <p>If the engine provides this function, it will be called after <code>exec_event</code> to perform any cleanup or teardown required after the event has been executed.</p>"},{"location":"api/mda/#pymmcore_plus.mda._protocol.PMDAEngine.teardown_sequence","title":"<code>teardown_sequence(sequence: MDASequence) -&gt; None</code>","text":"<p>Perform any teardown required after the sequence has been executed.</p> <p>Optional.</p> <p>If the engine provides this function, it will be called after the last event in the sequence has been executed.</p>"},{"location":"api/mda/#pymmcore_plus.mda.MDAEngine","title":"<code>pymmcore_plus.mda.MDAEngine</code>","text":"<p>The default MDAengine that ships with pymmcore-plus.</p> <p>This implements the <code>PMDAEngine</code> protocol, and uses a <code>CMMCorePlus</code> instance to control the hardware.</p> <p>Attributes:</p> Name Type Description <code>mmcore</code> <code>CMMCorePlus</code> <p>The <code>CMMCorePlus</code> instance to use for hardware control.</p> <code>use_hardware_sequencing</code> <code>bool</code> <p>Whether to use hardware sequencing if possible. If <code>True</code>, the engine will attempt to combine MDAEvents into a single <code>SequencedEvent</code> if <code>core.canSequenceEvents()</code> reports that the events can be sequenced. This can be set after instantiation. By default, this is <code>False</code>, in order to avoid unexpected behavior, particularly in testing and demo scenarios.  But in many \"real world\" scenarios, this can be set to <code>True</code> to improve performance.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>class MDAEngine(PMDAEngine):\n\"\"\"The default MDAengine that ships with pymmcore-plus.\n\n    This implements the [`PMDAEngine`][pymmcore_plus.mda.PMDAEngine] protocol, and\n    uses a [`CMMCorePlus`][pymmcore_plus.CMMCorePlus] instance to control the hardware.\n\n    Attributes\n    ----------\n    mmcore: CMMCorePlus\n        The `CMMCorePlus` instance to use for hardware control.\n    use_hardware_sequencing : bool\n        Whether to use hardware sequencing if possible. If `True`, the engine will\n        attempt to combine MDAEvents into a single `SequencedEvent` if\n        [`core.canSequenceEvents()`][pymmcore_plus.CMMCorePlus.canSequenceEvents]\n        reports that the events can be sequenced. This can be set after instantiation.\n        By default, this is `False`, in order to avoid unexpected behavior, particularly\n        in testing and demo scenarios.  But in many \"real world\" scenarios, this can be\n        set to `True` to improve performance.\n    \"\"\"\n\n    def __init__(self, mmc: CMMCorePlus, use_hardware_sequencing: bool = False) -&gt; None:\n        self._mmc = mmc\n        self.use_hardware_sequencing = use_hardware_sequencing\n\n        # used for one_shot autofocus to store the z correction for each position index.\n        # map of {position_index: z_correction}\n        self._z_correction: dict[int | None, float] = {}\n\n        # This is used to determine whether we need to re-enable autoshutter after\n        # the sequence is done (assuming a event.keep_shutter_open was requested)\n        # Note: getAutoShutter() is True when no config is loaded at all\n        self._autoshutter_was_set: bool = self._mmc.getAutoShutter()\n\n    @property\n    def mmcore(self) -&gt; CMMCorePlus:\n\"\"\"The `CMMCorePlus` instance to use for hardware control.\"\"\"\n        return self._mmc\n\n    # ===================== Protocol Implementation =====================\n\n    def setup_sequence(self, sequence: MDASequence) -&gt; None:\n\"\"\"Setup the hardware for the entire sequence.\n\n        (currently, this does nothing but get the global `CMMCorePlus` singleton\n        if one has not already been provided).\n        \"\"\"\n        if not self._mmc:  # pragma: no cover\n            from pymmcore_plus.core import CMMCorePlus\n\n            self._mmc = CMMCorePlus.instance()\n\n        if px_size := self._mmc.getPixelSizeUm():\n            self._update_grid_fov_sizes(px_size, sequence)\n\n        self._autoshutter_was_set = self._mmc.getAutoShutter()\n\n    def _update_grid_fov_sizes(self, px_size: float, sequence: MDASequence) -&gt; None:\n        *_, x_size, y_size = self._mmc.getROI()\n        fov_width = x_size * px_size\n        fov_height = y_size * px_size\n\n        if sequence.grid_plan:\n            sequence.grid_plan.fov_width = fov_width\n            sequence.grid_plan.fov_height = fov_height\n\n        # set fov to any stage positions sequences\n        for p in sequence.stage_positions:\n            if p.sequence and p.sequence.grid_plan:\n                p.sequence.grid_plan.fov_height = fov_height\n                p.sequence.grid_plan.fov_width = fov_width\n\n    def setup_event(self, event: MDAEvent) -&gt; None:\n\"\"\"Set the system hardware (XY, Z, channel, exposure) as defined in the event.\n\n        Parameters\n        ----------\n        event : MDAEvent\n            The event to use for the Hardware config\n        \"\"\"\n        if isinstance(event, SequencedEvent):\n            self.setup_sequenced_event(event)\n        else:\n            self.setup_single_event(event)\n        self._mmc.waitForSystem()\n\n    def exec_event(self, event: MDAEvent) -&gt; Sequence[PImagePayload]:\n\"\"\"Execute an individual event and return the image data.\"\"\"\n        action = getattr(event, \"action\", None)\n        if isinstance(action, HardwareAutofocus):\n            # skip if no autofocus device is found\n            if not self._mmc.getAutoFocusDevice():\n                logger.warning(\"No autofocus device found. Cannot execute autofocus.\")\n                return ()\n\n            try:\n                # execute hardware autofocus\n                new_correction = self._execute_autofocus(action)\n            except RuntimeError as e:\n                logger.warning(\"Hardware autofocus failed. %s\", e)\n            else:\n                # store correction for this position index\n                p_idx = event.index.get(\"p\", None)\n                self._z_correction[p_idx] = new_correction\n            return ()\n\n        if isinstance(event, SequencedEvent):\n            return self.exec_sequenced_event(event)\n        else:\n            return self.exec_single_event(event)\n\n    def event_iterator(self, events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]:\n\"\"\"Event iterator that merges events for hardware sequencing if possible.\n\n        This wraps `for event in events: ...` inside `MDARunner.run()` and combines\n        sequenceable events into an instance of `SequencedEvent` if\n        `self.use_hardware_sequencing` is `True`.\n        \"\"\"\n        if not self.use_hardware_sequencing:\n            yield from events\n            return\n\n        seq: list[MDAEvent] = []\n        for event in events:\n            # if the sequence is empty or the current event can be sequenced with the\n            # previous event, add it to the sequence\n            if not seq or self._mmc.canSequenceEvents(seq[-1], event, len(seq)):\n                seq.append(event)\n            else:\n                # otherwise, yield a SequencedEvent if the sequence has accumulated\n                # more than one event, otherwise yield the single event\n                yield seq[0] if len(seq) == 1 else SequencedEvent.create(seq)\n                # add this current event and start a new sequence\n                seq = [event]\n        # yield any remaining events\n        if seq:\n            yield seq[0] if len(seq) == 1 else SequencedEvent.create(seq)\n\n    # ===================== Regular Events =====================\n\n    def setup_single_event(self, event: MDAEvent) -&gt; None:\n\"\"\"Setup hardware for a single (non-sequenced) event.\n\n        This method is not part of the PMDAEngine protocol (it is called by\n        `setup_event`, which *is* part of the protocol), but it is made public\n        in case a user wants to subclass this engine and override this method.\n        \"\"\"\n        if event.keep_shutter_open:\n            ...\n\n        if event.x_pos is not None or event.y_pos is not None:\n            self._set_event_position(event)\n        if event.z_pos is not None:\n            self._set_event_z(event)\n\n        if event.channel is not None:\n            try:\n                self._mmc.setConfig(event.channel.group, event.channel.config)\n            except Exception as e:\n                logger.warning(\"Failed to set channel. %s\", e)\n        if event.exposure is not None:\n            try:\n                self._mmc.setExposure(event.exposure)\n            except Exception as e:\n                logger.warning(\"Failed to set exposure. %s\", e)\n\n        if (\n            # (if autoshutter wasn't set at the beginning of the sequence\n            # then it never matters...)\n            self._autoshutter_was_set\n            # if we want to leave the shutter open after this event, and autoshutter\n            # is currently enabled...\n            and event.keep_shutter_open\n            and self._mmc.getAutoShutter()\n        ):\n            # we have to disable autoshutter and open the shutter\n            self._mmc.setAutoShutter(False)\n            self._mmc.setShutterOpen(True)\n\n    def exec_single_event(self, event: MDAEvent) -&gt; Sequence[PImagePayload]:\n\"\"\"Execute a single (non-triggered) event and return the image data.\n\n        This method is not part of the PMDAEngine protocol (it is called by\n        `exec_event`, which *is* part of the protocol), but it is made public\n        in case a user wants to subclass this engine and override this method.\n        \"\"\"\n        try:\n            self._mmc.snapImage()\n        except Exception as e:\n            logger.warning(\"Failed to snap image. %s\", e)\n            return ()\n        if not event.keep_shutter_open:\n            self._mmc.setShutterOpen(False)\n        return ((self._mmc.getImage(), event, self._mmc.getTags()),)\n\n    def teardown_event(self, event: MDAEvent) -&gt; None:\n\"\"\"Teardown state of system (hardware, etc.) after `event`.\"\"\"\n        # autoshutter was set at the beginning of the sequence, and this event\n        # doesn't want to leave the shutter open.  Re-enable autoshutter.\n        if not event.keep_shutter_open and self._autoshutter_was_set:\n            self._mmc.setAutoShutter(True)\n\n    def teardown_sequence(self, sequence: MDASequence) -&gt; None:\n\"\"\"Perform any teardown required after the sequence has been executed.\"\"\"\n        pass\n\n    # ===================== Sequenced Events =====================\n\n    def setup_sequenced_event(self, event: SequencedEvent) -&gt; None:\n\"\"\"Setup hardware for a sequenced (triggered) event.\n\n        This method is not part of the PMDAEngine protocol (it is called by\n        `setup_event`, which *is* part of the protocol), but it is made public\n        in case a user wants to subclass this engine and override this method.\n        \"\"\"\n        core = self._mmc\n        cam_device = self._mmc.getCameraDevice()\n\n        if event.exposure_sequence:\n            core.loadExposureSequence(cam_device, event.exposure_sequence)\n        if event.x_sequence:  # y_sequence is implied and will be the same length\n            stage = core.getXYStageDevice()\n            core.loadXYStageSequence(stage, event.x_sequence, event.y_sequence)\n        if event.z_sequence:\n            zstage = core.getFocusDevice()\n            core.loadStageSequence(zstage, event.z_sequence)\n        if prop_seqs := event.property_sequences(core):\n            for (dev, prop), value_sequence in prop_seqs.items():\n                core.loadPropertySequence(dev, prop, value_sequence)\n\n        # TODO: SLM\n        core.prepareSequenceAcquisition(cam_device)\n\n        # start sequences or set non-sequenced values\n        if event.x_sequence:\n            core.startXYStageSequence(stage)\n        elif event.x_pos is not None or event.y_pos is not None:\n            self._set_event_position(event)\n\n        if event.z_sequence:\n            core.startStageSequence(zstage)\n        elif event.z_pos is not None:\n            self._set_event_z(event)\n\n        if event.exposure_sequence:\n            core.startExposureSequence(cam_device)\n        elif event.exposure is not None:\n            core.setExposure(event.exposure)\n\n        if prop_seqs:\n            for dev, prop in prop_seqs:\n                core.startPropertySequence(dev, prop)\n        elif event.channel is not None:\n            core.setConfig(event.channel.group, event.channel.config)\n\n    def exec_sequenced_event(self, event: SequencedEvent) -&gt; Sequence[PImagePayload]:\n\"\"\"Execute a sequenced (triggered) event and return the image data.\n\n        This method is not part of the PMDAEngine protocol (it is called by\n        `exec_event`, which *is* part of the protocol), but it is made public\n        in case a user wants to subclass this engine and override this method.\n        \"\"\"\n        # TODO: add support for multiple camera devices\n        n_events = len(event.events)\n\n        # Start sequence\n        # Note that the overload of startSequenceAcquisition that takes a camera\n        # label does NOT automatically initialize a circular buffer.  So if this call\n        # is changed to accept the camera in the future, that should be kept in mind.\n        self._mmc.startSequenceAcquisition(\n            n_events,\n            0,  # intervalMS  # TODO: add support for this\n            True,  # stopOnOverflow\n        )\n\n        # block until the sequence is done, popping images in the meantime\n        images: list[TaggedImage] = []\n        while self._mmc.isSequenceRunning():\n            if self._mmc.getRemainingImageCount():\n                images.append(self._mmc.popNextTaggedImage())\n            else:\n                time.sleep(0.001)\n\n        if self._mmc.isBufferOverflowed():  # pragma: no cover\n            raise MemoryError(\"Buffer overflowed\")\n\n        while self._mmc.getRemainingImageCount():\n            images.append(self._mmc.popNextTaggedImage())\n\n        if len(images) != n_events:\n            logger.warning(\n                \"Unexpected number of images returned from sequence. \"\n                \"Expected %s, got %s\",\n                n_events,\n                len(images),\n            )\n\n        return tuple(\n            ImagePayload(img.pix, e, img.tags) for img, e in zip(images, event.events)\n        )\n\n    # ===================== EXTRA =====================\n\n    def _execute_autofocus(self, action: HardwareAutofocus) -&gt; float:\n\"\"\"Perform the hardware autofocus.\n\n        Returns the change in ZPosition that occurred during the autofocus event.\n        \"\"\"\n        # switch off autofocus device if it is on\n        self._mmc.enableContinuousFocus(False)\n\n        # setup the autofocus device\n        self._mmc.setPosition(\n            action.autofocus_device_name,\n            action.autofocus_motor_offset,\n        )\n        self._mmc.waitForSystem()\n\n        @retry(exceptions=RuntimeError, tries=action.max_retries, logger=logger.warning)\n        def _perform_full_focus(previous_z: float) -&gt; float:\n            self._mmc.fullFocus()\n            self._mmc.waitForSystem()\n            return self._mmc.getZPosition() - previous_z\n\n        return _perform_full_focus(self._mmc.getZPosition())\n\n    def _set_event_position(self, event: MDAEvent) -&gt; None:\n        # skip if no XY stage device is found\n        if not self._mmc.getXYStageDevice():\n            logger.warning(\"No XY stage device found. Cannot set XY position.\")\n            return\n\n        x = event.x_pos if event.x_pos is not None else self._mmc.getXPosition()\n        y = event.y_pos if event.y_pos is not None else self._mmc.getYPosition()\n        self._mmc.setXYPosition(x, y)\n\n    def _set_event_z(self, event: MDAEvent) -&gt; None:\n        # skip if no Z stage device is found\n        if not self._mmc.getFocusDevice():\n            logger.warning(\"No Z stage device found. Cannot set Z position.\")\n            return\n\n        p_idx = event.index.get(\"p\", None)\n        correction = self._z_correction.setdefault(p_idx, 0.0)\n        self._mmc.setZPosition(cast(\"float\", event.z_pos) + correction)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.use_hardware_sequencing","title":"<code>use_hardware_sequencing = use_hardware_sequencing</code>  <code>instance-attribute</code>","text":""},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.event_iterator","title":"<code>event_iterator(events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]</code>","text":"<p>Event iterator that merges events for hardware sequencing if possible.</p> <p>This wraps <code>for event in events: ...</code> inside <code>MDARunner.run()</code> and combines sequenceable events into an instance of <code>SequencedEvent</code> if <code>self.use_hardware_sequencing</code> is <code>True</code>.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def event_iterator(self, events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]:\n\"\"\"Event iterator that merges events for hardware sequencing if possible.\n\n    This wraps `for event in events: ...` inside `MDARunner.run()` and combines\n    sequenceable events into an instance of `SequencedEvent` if\n    `self.use_hardware_sequencing` is `True`.\n    \"\"\"\n    if not self.use_hardware_sequencing:\n        yield from events\n        return\n\n    seq: list[MDAEvent] = []\n    for event in events:\n        # if the sequence is empty or the current event can be sequenced with the\n        # previous event, add it to the sequence\n        if not seq or self._mmc.canSequenceEvents(seq[-1], event, len(seq)):\n            seq.append(event)\n        else:\n            # otherwise, yield a SequencedEvent if the sequence has accumulated\n            # more than one event, otherwise yield the single event\n            yield seq[0] if len(seq) == 1 else SequencedEvent.create(seq)\n            # add this current event and start a new sequence\n            seq = [event]\n    # yield any remaining events\n    if seq:\n        yield seq[0] if len(seq) == 1 else SequencedEvent.create(seq)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.exec_event","title":"<code>exec_event(event: MDAEvent) -&gt; Sequence[PImagePayload]</code>","text":"<p>Execute an individual event and return the image data.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def exec_event(self, event: MDAEvent) -&gt; Sequence[PImagePayload]:\n\"\"\"Execute an individual event and return the image data.\"\"\"\n    action = getattr(event, \"action\", None)\n    if isinstance(action, HardwareAutofocus):\n        # skip if no autofocus device is found\n        if not self._mmc.getAutoFocusDevice():\n            logger.warning(\"No autofocus device found. Cannot execute autofocus.\")\n            return ()\n\n        try:\n            # execute hardware autofocus\n            new_correction = self._execute_autofocus(action)\n        except RuntimeError as e:\n            logger.warning(\"Hardware autofocus failed. %s\", e)\n        else:\n            # store correction for this position index\n            p_idx = event.index.get(\"p\", None)\n            self._z_correction[p_idx] = new_correction\n        return ()\n\n    if isinstance(event, SequencedEvent):\n        return self.exec_sequenced_event(event)\n    else:\n        return self.exec_single_event(event)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.exec_sequenced_event","title":"<code>exec_sequenced_event(event: SequencedEvent) -&gt; Sequence[PImagePayload]</code>","text":"<p>Execute a sequenced (triggered) event and return the image data.</p> <p>This method is not part of the PMDAEngine protocol (it is called by <code>exec_event</code>, which is part of the protocol), but it is made public in case a user wants to subclass this engine and override this method.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def exec_sequenced_event(self, event: SequencedEvent) -&gt; Sequence[PImagePayload]:\n\"\"\"Execute a sequenced (triggered) event and return the image data.\n\n    This method is not part of the PMDAEngine protocol (it is called by\n    `exec_event`, which *is* part of the protocol), but it is made public\n    in case a user wants to subclass this engine and override this method.\n    \"\"\"\n    # TODO: add support for multiple camera devices\n    n_events = len(event.events)\n\n    # Start sequence\n    # Note that the overload of startSequenceAcquisition that takes a camera\n    # label does NOT automatically initialize a circular buffer.  So if this call\n    # is changed to accept the camera in the future, that should be kept in mind.\n    self._mmc.startSequenceAcquisition(\n        n_events,\n        0,  # intervalMS  # TODO: add support for this\n        True,  # stopOnOverflow\n    )\n\n    # block until the sequence is done, popping images in the meantime\n    images: list[TaggedImage] = []\n    while self._mmc.isSequenceRunning():\n        if self._mmc.getRemainingImageCount():\n            images.append(self._mmc.popNextTaggedImage())\n        else:\n            time.sleep(0.001)\n\n    if self._mmc.isBufferOverflowed():  # pragma: no cover\n        raise MemoryError(\"Buffer overflowed\")\n\n    while self._mmc.getRemainingImageCount():\n        images.append(self._mmc.popNextTaggedImage())\n\n    if len(images) != n_events:\n        logger.warning(\n            \"Unexpected number of images returned from sequence. \"\n            \"Expected %s, got %s\",\n            n_events,\n            len(images),\n        )\n\n    return tuple(\n        ImagePayload(img.pix, e, img.tags) for img, e in zip(images, event.events)\n    )\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.exec_single_event","title":"<code>exec_single_event(event: MDAEvent) -&gt; Sequence[PImagePayload]</code>","text":"<p>Execute a single (non-triggered) event and return the image data.</p> <p>This method is not part of the PMDAEngine protocol (it is called by <code>exec_event</code>, which is part of the protocol), but it is made public in case a user wants to subclass this engine and override this method.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def exec_single_event(self, event: MDAEvent) -&gt; Sequence[PImagePayload]:\n\"\"\"Execute a single (non-triggered) event and return the image data.\n\n    This method is not part of the PMDAEngine protocol (it is called by\n    `exec_event`, which *is* part of the protocol), but it is made public\n    in case a user wants to subclass this engine and override this method.\n    \"\"\"\n    try:\n        self._mmc.snapImage()\n    except Exception as e:\n        logger.warning(\"Failed to snap image. %s\", e)\n        return ()\n    if not event.keep_shutter_open:\n        self._mmc.setShutterOpen(False)\n    return ((self._mmc.getImage(), event, self._mmc.getTags()),)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.mmcore","title":"<code>mmcore() -&gt; CMMCorePlus</code>  <code>property</code>","text":"<p>The <code>CMMCorePlus</code> instance to use for hardware control.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>@property\ndef mmcore(self) -&gt; CMMCorePlus:\n\"\"\"The `CMMCorePlus` instance to use for hardware control.\"\"\"\n    return self._mmc\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.setup_event","title":"<code>setup_event(event: MDAEvent) -&gt; None</code>","text":"<p>Set the system hardware (XY, Z, channel, exposure) as defined in the event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MDAEvent</code> <p>The event to use for the Hardware config</p> required Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def setup_event(self, event: MDAEvent) -&gt; None:\n\"\"\"Set the system hardware (XY, Z, channel, exposure) as defined in the event.\n\n    Parameters\n    ----------\n    event : MDAEvent\n        The event to use for the Hardware config\n    \"\"\"\n    if isinstance(event, SequencedEvent):\n        self.setup_sequenced_event(event)\n    else:\n        self.setup_single_event(event)\n    self._mmc.waitForSystem()\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.setup_sequence","title":"<code>setup_sequence(sequence: MDASequence) -&gt; None</code>","text":"<p>Setup the hardware for the entire sequence.</p> <p>(currently, this does nothing but get the global <code>CMMCorePlus</code> singleton if one has not already been provided).</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def setup_sequence(self, sequence: MDASequence) -&gt; None:\n\"\"\"Setup the hardware for the entire sequence.\n\n    (currently, this does nothing but get the global `CMMCorePlus` singleton\n    if one has not already been provided).\n    \"\"\"\n    if not self._mmc:  # pragma: no cover\n        from pymmcore_plus.core import CMMCorePlus\n\n        self._mmc = CMMCorePlus.instance()\n\n    if px_size := self._mmc.getPixelSizeUm():\n        self._update_grid_fov_sizes(px_size, sequence)\n\n    self._autoshutter_was_set = self._mmc.getAutoShutter()\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.setup_sequenced_event","title":"<code>setup_sequenced_event(event: SequencedEvent) -&gt; None</code>","text":"<p>Setup hardware for a sequenced (triggered) event.</p> <p>This method is not part of the PMDAEngine protocol (it is called by <code>setup_event</code>, which is part of the protocol), but it is made public in case a user wants to subclass this engine and override this method.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def setup_sequenced_event(self, event: SequencedEvent) -&gt; None:\n\"\"\"Setup hardware for a sequenced (triggered) event.\n\n    This method is not part of the PMDAEngine protocol (it is called by\n    `setup_event`, which *is* part of the protocol), but it is made public\n    in case a user wants to subclass this engine and override this method.\n    \"\"\"\n    core = self._mmc\n    cam_device = self._mmc.getCameraDevice()\n\n    if event.exposure_sequence:\n        core.loadExposureSequence(cam_device, event.exposure_sequence)\n    if event.x_sequence:  # y_sequence is implied and will be the same length\n        stage = core.getXYStageDevice()\n        core.loadXYStageSequence(stage, event.x_sequence, event.y_sequence)\n    if event.z_sequence:\n        zstage = core.getFocusDevice()\n        core.loadStageSequence(zstage, event.z_sequence)\n    if prop_seqs := event.property_sequences(core):\n        for (dev, prop), value_sequence in prop_seqs.items():\n            core.loadPropertySequence(dev, prop, value_sequence)\n\n    # TODO: SLM\n    core.prepareSequenceAcquisition(cam_device)\n\n    # start sequences or set non-sequenced values\n    if event.x_sequence:\n        core.startXYStageSequence(stage)\n    elif event.x_pos is not None or event.y_pos is not None:\n        self._set_event_position(event)\n\n    if event.z_sequence:\n        core.startStageSequence(zstage)\n    elif event.z_pos is not None:\n        self._set_event_z(event)\n\n    if event.exposure_sequence:\n        core.startExposureSequence(cam_device)\n    elif event.exposure is not None:\n        core.setExposure(event.exposure)\n\n    if prop_seqs:\n        for dev, prop in prop_seqs:\n            core.startPropertySequence(dev, prop)\n    elif event.channel is not None:\n        core.setConfig(event.channel.group, event.channel.config)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.setup_single_event","title":"<code>setup_single_event(event: MDAEvent) -&gt; None</code>","text":"<p>Setup hardware for a single (non-sequenced) event.</p> <p>This method is not part of the PMDAEngine protocol (it is called by <code>setup_event</code>, which is part of the protocol), but it is made public in case a user wants to subclass this engine and override this method.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def setup_single_event(self, event: MDAEvent) -&gt; None:\n\"\"\"Setup hardware for a single (non-sequenced) event.\n\n    This method is not part of the PMDAEngine protocol (it is called by\n    `setup_event`, which *is* part of the protocol), but it is made public\n    in case a user wants to subclass this engine and override this method.\n    \"\"\"\n    if event.keep_shutter_open:\n        ...\n\n    if event.x_pos is not None or event.y_pos is not None:\n        self._set_event_position(event)\n    if event.z_pos is not None:\n        self._set_event_z(event)\n\n    if event.channel is not None:\n        try:\n            self._mmc.setConfig(event.channel.group, event.channel.config)\n        except Exception as e:\n            logger.warning(\"Failed to set channel. %s\", e)\n    if event.exposure is not None:\n        try:\n            self._mmc.setExposure(event.exposure)\n        except Exception as e:\n            logger.warning(\"Failed to set exposure. %s\", e)\n\n    if (\n        # (if autoshutter wasn't set at the beginning of the sequence\n        # then it never matters...)\n        self._autoshutter_was_set\n        # if we want to leave the shutter open after this event, and autoshutter\n        # is currently enabled...\n        and event.keep_shutter_open\n        and self._mmc.getAutoShutter()\n    ):\n        # we have to disable autoshutter and open the shutter\n        self._mmc.setAutoShutter(False)\n        self._mmc.setShutterOpen(True)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.teardown_event","title":"<code>teardown_event(event: MDAEvent) -&gt; None</code>","text":"<p>Teardown state of system (hardware, etc.) after <code>event</code>.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def teardown_event(self, event: MDAEvent) -&gt; None:\n\"\"\"Teardown state of system (hardware, etc.) after `event`.\"\"\"\n    # autoshutter was set at the beginning of the sequence, and this event\n    # doesn't want to leave the shutter open.  Re-enable autoshutter.\n    if not event.keep_shutter_open and self._autoshutter_was_set:\n        self._mmc.setAutoShutter(True)\n</code></pre>"},{"location":"api/mda/#pymmcore_plus.mda._engine.MDAEngine.teardown_sequence","title":"<code>teardown_sequence(sequence: MDASequence) -&gt; None</code>","text":"<p>Perform any teardown required after the sequence has been executed.</p> Source code in <code>pymmcore_plus/mda/_engine.py</code> <pre><code>def teardown_sequence(self, sequence: MDASequence) -&gt; None:\n\"\"\"Perform any teardown required after the sequence has been executed.\"\"\"\n    pass\n</code></pre>"},{"location":"api/metadata/","title":"Metadata","text":""},{"location":"api/metadata/#pymmcore_plus.Metadata","title":"<code>pymmcore_plus.Metadata</code>","text":"<p>Subclass of <code>pymmcore.Metadata</code> with a pythonic interface.</p> <p>This subclass fully implements a <code>collections.abc.Mapping</code> interface (i.e. it behaves like a Python <code>dict</code>).  It also adds a <code>json()</code> convenience method to convert to a JSON string.</p>"},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.clear","title":"<code>clear() -&gt; None</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.copy","title":"<code>copy() -&gt; Metadata</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.get","title":"<code>get(name: str, default: Any = _NULL) -&gt; Any</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.items","title":"<code>items() -&gt; ItemsView[str, str]</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.json","title":"<code>json() -&gt; str</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.keys","title":"<code>keys() -&gt; KeysView[str]</code>","text":""},{"location":"api/metadata/#pymmcore_plus.core._metadata.Metadata.values","title":"<code>values() -&gt; ValuesView[str]</code>","text":""},{"location":"api/utils/","title":"Utilities","text":""},{"location":"api/utils/#pymmcore_plus.find_micromanager","title":"<code>pymmcore_plus.find_micromanager(return_first: bool = True) -&gt; str | None | list[str]</code>","text":"<p>Locate a Micro-Manager folder (for device adapters).</p> <p>In order, this will look for:</p> <ol> <li>An environment variable named <code>MICROMANAGER_PATH</code></li> <li> <p>A <code>Micro-Manager*</code> folder in the <code>pymmcore-plus</code> user data directory    (this is the default install location when running <code>mmcore install</code>)</p> <ul> <li>Windows: C:\\Users\\[user]\\AppData\\Local\\pymmcore-plus\\pymmcore-plus</li> <li>macOS: ~/Library/Application Support/pymmcore-plus</li> <li>Linux: ~/.local/share/pymmcore-plus</li> </ul> </li> <li> <p>A <code>Micro-Manager*</code> folder in the <code>pymmcore_plus</code> package directory (this is the    default install location when running <code>python -m pymmcore_plus.install</code>)</p> </li> <li> <p>The default micro-manager install location:</p> <ul> <li>Windows: <code>C:/Program Files/</code></li> <li>macOS: <code>/Applications</code></li> <li>Linux: <code>/usr/local/lib</code></li> </ul> </li> </ol> <p>Note</p> <p>This function is used by <code>pymmcore_plus.CMMCorePlus</code> to locate the micro-manager device adapters.  By default, the output of this function is passed to <code>setDeviceAdapterSearchPaths</code> when creating a new <code>CMMCorePlus</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>return_first</code> <code>bool, optional</code> <p>If True (default), return the first found path.  If False, return a list of all found paths.</p> <code>True</code>"},{"location":"api/utils/#pymmcore_plus.configure_logging","title":"<code>pymmcore_plus.configure_logging(file: str | Path | None = LOG_FILE, stderr_level: int | str = DEFAULT_LOG_LEVEL, file_level: int | str = logging.DEBUG, log_to_stderr: bool = True, file_rotation: int = 40, file_retention: int = 20) -&gt; None</code>","text":"<p>Configure logging for pymmcore-plus.</p> <p>This function is called automatically once when pymmcore-plus is imported, to set up logging to stderr and a log file.  You can call it again to change the logging settings.</p> <p>You may also configure logging using the following environment variables:</p> <ul> <li><code>PYMM_LOG_LEVEL</code> - The log level for <code>stderr</code> logging. By default <code>INFO</code>.</li> <li><code>PYMM_LOG_FILE</code> - The path to the log file.  If set to <code>0</code>, <code>false</code>, <code>no</code>,     or <code>none</code>, logging to file will be disabled.</li> </ul> <p>Note</p> <p>This function will clear all existing logging handlers and replace them with new ones.  So be sure to pass all the settings you want to use each time you call this function.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | None</code> <p>Path to logfile. May also be set with MM_LOG_FILE environment variable. If <code>None</code>, will not log to file.  By default, logs to: Mac OS X:   ~/Library/Application Support/pymmcore-plus/logs Unix:       ~/.local/share/pymmcore-plus/logs Win:        C:\\Users\\\\AppData\\Local\\pymmcore-plus\\pymmcore-plus\\logs <code>LOG_FILE</code> <code>stderr_level</code> <code>int | str</code> <p>Level for stderr logging. One of \"TRACE\", \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\", or 5, 10, 20, 30, 40, or 50, respectively. by default <code>\"INFO\"</code>.</p> <code>DEFAULT_LOG_LEVEL</code> <code>file_level</code> <code>int | str</code> <p>Level for logging to file, by default <code>\"TRACE\"</code></p> <code>logging.DEBUG</code> <code>log_to_stderr</code> <code>bool</code> <p>Whether to log to stderr, by default True</p> <code>True</code> <code>file_rotation</code> <code>int</code> <p>When to rollover to the next log file, in MegaBytes, by default <code>40</code>.</p> <code>40</code> <code>file_retention</code> <code>int</code> <p>Maximum number of log files to retain, by default <code>20</code></p> <code>20</code>"},{"location":"examples/context-set/","title":"Set as a Context","text":"<p>You may want to temporarily set something on core such as <code>core.setAutoShutter(False)</code> when writing an MDA Engine. For this case you can use the convenience method <code>CMMCorePlus.setContext</code>.</p> set_as_context.py<pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus.instance()\n\n# set some state temporarily\nwith core.setContext(autoShutter=False):\n    assert not core.getAutoShutter()\n    # do other stuff\n\nassert core.getAutoShutter()\n</code></pre> <p>This will work for the <code>set</code> methods on the core such as <code>setAutoShutter</code>, <code>setShutterOpen</code>, ...</p>"},{"location":"examples/following_changes_in_core/","title":"Follow changes in MMCore","text":"<p><code>pymmcore-plus</code> implements an enhanced Observer pattern, making it easier to connect callback functions to events that occur in the core.  This is useful for things like updating a GUI when a property changes, or writing and/or processing data as it is acquired.</p> <p>See the Events API documentation for complete details on what events are emitted and how to connect to them.</p> on_prop_changed.py<pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus.instance()\ncore.loadSystemConfiguration()\n\n\n@core.events.propertyChanged.connect\ndef _on_prop_changed(dev, prop, value):\n    # Note that when state devices change either the state or the label\n    # TWO propertyChanged events will be emitted, one for prop 'State'\n    # and one for prop 'Label'. Probably, best to check the property\n    # name and only respond to one of them\n    if dev == \"Objective\" and prop == \"Label\":\n        print(\"new objective is\", value)\n\n\ncore.setState(\"Objective\", 3)\n</code></pre>"},{"location":"examples/integration-with-qt/","title":"Qt Integration","text":"<p>For a complex Qt application based on <code>pymmcore-plus</code> check out napari-micromanager which implements a GUI to control microscopes.</p> <p><code>pymmcore-plus</code> is designed seamlessly integrate with Qt GUIs. It accomplishes this in two ways:</p> <ol> <li><code>pymmcore_plus.CMMCorePlus.run_mda</code> runs in a thread in order to not block the event loop.</li> <li>The <code>events</code> object will preferentially to use QSignals instead of of signals from the psygnal library. This helps keep things from crashing when working with callbacks in multiple threads.</li> </ol> <p>This example requires qtpy and an Qt backend installed in the env:</p> <pre><code>pip install qtpy superqt Pyside2 # or pyqt5\n</code></pre>"},{"location":"examples/integration-with-qt/#avoiding-blocking-the-qt-event-loop","title":"Avoiding blocking the Qt event loop","text":"<p>If you make a blocking call on the thread running the Qt event loop then your GUI will become unresponsive. <code>pymmcore-plus</code> has two options to avoid this. The recommended way is to use threads to call <code>pymmcore_plus.CMMCorePlus.snapImage</code>, and let pymmcore-plus handle the threading when you use <code>pymmcore_plus.CMMCorePlus.run_mda</code>.</p> <p>This example will use the recommended process-local(threads) approach.</p> <p>The simple application will consist of a counter that increments so long as the event loop is not blocked, and two buttons to call the <code>snapImage</code> method. One button will call from a thread and the counter should continue, the other will block and will stop the counter.</p> <p>Key takeaways:</p> <ol> <li>Use <code>CMMCorePlus.instance()</code> to create the core object. This allows another script in the same process to use the same object.</li> <li>Use a thread for blocking operations like <code>snapImage</code>.</li> </ol> <pre><code>import sys\n\nfrom qtpy.QtCore import QTimer\nfrom qtpy.QtWidgets import (\n    QApplication,\n    QLabel,\n    QMainWindow,\n    QPushButton,\n    QVBoxLayout,\n    QWidget,\n)\nfrom superqt.utils import create_worker\n\nfrom pymmcore_plus import CMMCorePlus\n\n\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.mmc = CMMCorePlus.instance()\n        self.mmc.loadSystemConfiguration()\n        self.mmc.setExposure(5000)  # 5 seconds\n\n        self.counter = 0\n\n        layout = QVBoxLayout()\n\n        self.l = QLabel(\"Start\")\n        b_blocking = QPushButton(\"Snap blocking\")\n        b_threaded = QPushButton(\"Snap threaded\")\n        b_blocking.pressed.connect(self.snap_blocking)\n        b_threaded.pressed.connect(self.snap_threaded)\n\n        layout.addWidget(self.l)\n        layout.addWidget(b_blocking)\n        layout.addWidget(b_threaded)\n\n        w = QWidget()\n        w.setLayout(layout)\n        self.setCentralWidget(w)\n        self.show()\n\n        self.timer = QTimer()\n        self.timer.setInterval(1000)\n        self.timer.timeout.connect(self._recurring_timer)\n        self.timer.start()\n\n    def _recurring_timer(self):\n        self.counter += 1\n        self.l.setText(\"Counter: %d\" % self.counter)\n\n    def snap_threaded(self):\n        # alternatively you could use the python threading module\n        # or directly use QThreads\n        create_worker(\n            self._mmc.snapImage,\n            _start_thread=True,\n        )\n\n    def snap_blocking(self):\n        self.mmc.snapImage()\n\n\n\napp = QApplication(sys.argv)\nwindow = MainWindow()\napp.exec_()\n</code></pre>"},{"location":"examples/mda/","title":"Multidimensional Acquisition","text":"<p>Note</p> <p>There is much more extensive documentation on the MDA acquisition engine in the Acquisition Engine guide</p> <p><code>pymmcore-plus</code> includes a basic Multi-dimensional Acquisition (<code>mda</code>) engine <code>CMMCorePlus.run_mda</code> that accepts experimental sequences defined using useq-schema.</p> run_mda.py<pre><code>import numpy as np\nfrom pymmcore_plus import CMMCorePlus\nfrom useq import MDAEvent, MDASequence\n\n# see https://pymmcore-plus.github.io/useq-schema/api/ (1)\nsequence = MDASequence(\n    channels=[\"DAPI\", {\"config\": \"FITC\", \"exposure\": 50}],\n    time_plan={\"interval\": 2, \"loops\": 5},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    axis_order=\"tpcz\",\n)\n\nmmc = CMMCorePlus.instance()  # (2)!\nmmc.loadSystemConfiguration()  #  load demo configuration (3)\n\n\n# connect callback using a decorator (4)\n@mmc.mda.events.frameReady.connect\ndef new_frame(img: np.ndarray, event: MDAEvent):\n    print(img.shape)\n\n\n# or connect callback using a function\ndef on_start(sequence: MDASequence):\n    print(f\"now starting sequence {sequence.uid}!\")\n\n\nmmc.mda.events.sequenceStarted.connect(on_start)\n\n# run the sequence in a separate thread (5)\nmmc.run_mda(sequence)\n</code></pre> <ol> <li><code>pymmcore-plus</code> uses    <code>useq-schema</code> to define    experimental sequences. You can either construct a <code>useq.MDASequence</code>    object manually, or    from a YAML/JSON file.</li> <li>Access global singleton:    <code>CMMCorePlus.instance</code></li> <li>See    <code>CMMCorePlus.loadSystemConfiguration</code></li> <li>For info on all of the signals available to connect to, see the    MDA Events API</li> <li>To avoid blocking further execution,    <code>run_mda</code> runs on a new thread.    (<code>run_mda</code> returns a reference to the thread in case you want to do    something with it, such as wait for it to finish with    threading.Thread.join)</li> </ol>"},{"location":"examples/mda/#cancelling-or-pausing","title":"Cancelling or Pausing","text":"<p>You can pause or cancel the mda with the <code>CMMCorePlus.mda.toggle_pause</code> or <code>CMMCorePlus.mda.cancel</code> methods.</p>"},{"location":"examples/mda/#registering-a-new-mda-engine","title":"Registering a new MDA Engine","text":"<p>By default the built-in <code>MDAEngine</code> will be used to run the MDA. However, you can create a custom acquisition engine and register it use <code>CMMCorePlus.register_mda_engine</code>.</p> <p>Your engine must conform to the engine protocol defined by <code>pymmcore_plus.mda.PMDAEngine</code>. To ensure that your engine conforms you can inherit from the protocol.</p> <p>You can be alerted to the the registering of a new engine with the <code>core.events.mdaEngineRegistered</code> signal.</p> <pre><code>@mmc.events.mdaEngineRegistered\ndef new_engine(new_engine, old_engine):\n    print('new engine registered!\")\n</code></pre>"},{"location":"examples/napari-micromanager/","title":"Using with napari","text":"<p>If you want a nice GUI to interact with in addition to being able to script you can use napari-micromanager which implements a GUI in napari using this library as a backend.</p>"},{"location":"examples/napari-micromanager/#launching-napari-from-a-script","title":"Launching napari from a script","text":"<p>For complex scripting you likely will want to launch napari from a script or a jupyter notebook.</p> napari.py<pre><code>import napari\nfrom pymmcore_plus import CMMCorePlus\n\nv = napari.Viewer()\ndw, main_window = v.window.add_plugin_dock_widget(\"napari-micromanager\")\n\n# quick way to access the same core instance as napari-micromanager\nmmc = CMMCorePlus.instance()\n\n# do any complicated scripting you want here\n...\n\n# start napari\nnapari.run()\n</code></pre>"},{"location":"examples/napari-micromanager/#using-the-integrated-napari-terminal","title":"Using the integrated napari terminal","text":"<p>After launching napari and starting the <code>napari-micromanager</code> plugin you can open the napari terminal and get a reference to the same core object that the plugin uses by running:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\nmmc = CMMCorePlus.instance()\n</code></pre>"},{"location":"examples/pycro-manager-api/","title":"Pycro-manager like API","text":"<p>If you have been using pycro-manager and are familiar with its API, the following example may be useful to see what a pycro-manager-like API would look like implemented on the pymmcore-plus engine.</p> <p>Warning</p> <p>This is not presented as \"suggestion\", but rather as an educational example.  If you are considering pymmcore-plus for a pure-python acquisition workflow, consider using the <code>pymmcore</code> and <code>pymmcore-plus</code> APIs directly.</p> pycro-api.py<pre><code>from __future__ import annotations\n\nimport inspect\nfrom queue import Queue\nfrom typing import TYPE_CHECKING, Any, Callable, Iterable, Iterator, Sequence, cast\n\nfrom pymmcore_plus import CMMCorePlus\nfrom pymmcore_plus.mda import MDAEngine\nfrom useq import MDAEvent\n\n# These types represent what the pycro-manager API expects.\nif TYPE_CHECKING:\n    from collections import deque\n    from typing import TypeAlias\n\n    from numpy.typing import NDArray\n    from pymmcore_plus.mda._engine import EventPayload\n\n    Meta: TypeAlias = dict[str, Any]\n    PycroEvent: TypeAlias = dict[str, Any]\n\n    # Acquisition Hooks\n    EventQueue = Queue[PycroEvent | None]\n    EventHook = Callable[[PycroEvent], PycroEvent | None]\n    EventQueueHook = Callable[[PycroEvent, EventQueue], PycroEvent | None]\n    AcquisitionHook = EventHook | EventQueueHook\n\n    # Processor Hooks\n    ImgHookReturn = tuple[NDArray, Meta] | Sequence[tuple[NDArray, Meta]] | None\n    ImgMetaHook = Callable[[NDArray, Meta], ImgHookReturn]\n    ImgMetaQueueHook = Callable[[NDArray, Meta, EventQueue], ImgHookReturn]\n    ProcessorHook = ImgMetaHook | ImgMetaQueueHook\n\n\nclass Acquisition:\n\"\"\"Pycro-Manager -&gt; pymmcore-plus adaptor.\n\n    This doesn't re-implement file saving, but it gives you an example of how\n    pycromanager hooks would be converted to pymmcore-plus.\n\n    See `__main__` below for example usage.\n    \"\"\"\n\n    def __init__(\n        self,\n        image_process_fn: ProcessorHook | None = None,\n        event_generation_hook_fn: AcquisitionHook | None = None,\n        pre_hardware_hook_fn: AcquisitionHook | None = None,\n        post_hardware_hook_fn: AcquisitionHook | None = None,\n        post_camera_hook_fn: AcquisitionHook | None = None,\n    ):\n        self._core = CMMCorePlus.instance()\n        self._event_queue: EventQueue = Queue()\n        self._engine_cls = _build_engine(\n            self._event_queue,\n            event_generation_hook_fn,\n            pre_hardware_hook_fn,\n            post_hardware_hook_fn,\n            post_camera_hook_fn,\n        )\n        self._engine = self._engine_cls(self._core)\n        self._core.mda.set_engine(self._engine)\n\n        # see https://pymmcore-plus.github.io/pymmcore-plus/guides/event_driven_acquisition/\n        iter_queue = iter(self._event_queue.get, None)\n        self._thread = self._core.run_mda(iter_queue)  # type: ignore\n        # type error because of conversion between MDAEvent and pycromanager dict.\n        # we do the conversion below in the PycroEngine class.\n\n        # we can use `mda.events.frameReady` for the image_process hooks\n        self._image_process_fn = image_process_fn\n        if image_process_fn is not None:\n            sig = inspect.signature(image_process_fn)\n            if len(sig.parameters) == 2:\n                self._core.mda.events.frameReady.connect(self._call_img_hook_2arg)\n            elif len(sig.parameters) == 3:\n                self._core.mda.events.frameReady.connect(self._call_img_hook_3arg)\n            else:\n                raise ValueError(f\"Invalid image processing hook: {sig}\")\n\n    def acquire(self, event_or_events: PycroEvent | list[PycroEvent]) -&gt; None:\n        if isinstance(event_or_events, list):\n            for event in event_or_events:\n                self._event_queue.put(event)\n        else:\n            self._event_queue.put(event_or_events)\n\n    def abort(self, exception: BaseException | None = None) -&gt; None:\n        self._core.mda.cancel()\n        cast(\"deque\", self._event_queue.queue).clear()\n\n    def await_completion(self) -&gt; None:\n        self._thread.join()\n\n    def mark_finished(self) -&gt; None:\n        self._event_queue.put(None)\n\n    def _call_img_hook_2arg(self, img: NDArray, event: MDAEvent) -&gt; None:\n\"\"\"Call a 2-argument image processing hook.\"\"\"\n        hook = cast(\"ImgMetaHook\", self._image_process_fn)\n        hook(img, {})  # todo: meta\n\n    def _call_img_hook_3arg(self, img: NDArray, event: MDAEvent) -&gt; None:\n\"\"\"Call a 3-argument image processing hook.\"\"\"\n        hook = cast(\"ImgMetaQueueHook\", self._image_process_fn)\n        hook(img, {}, self._event_queue)  # todo: meta\n\n    def __enter__(self) -&gt; Acquisition:\n        return self\n\n    def __exit__(self, *args: Any) -&gt; None:\n        self.mark_finished()\n        self.await_completion()\n\n\n# note, this could be improved:\n# we don't need to check signature every time...\ndef _call_acq_hook(\n    hook: AcquisitionHook | None, event: PycroEvent, queue: EventQueue\n) -&gt; PycroEvent | None:\n    if hook is None:\n        return event\n\n    sig = inspect.signature(hook)\n    if len(sig.parameters) == 1:\n        return cast(\"EventHook\", hook)(event)\n    elif len(sig.parameters) == 2:\n        return cast(\"EventQueueHook\", hook)(event, queue)\n    else:\n        raise ValueError(f\"Invalid signature for acquisition hook: {sig}\")\n\n\nPYCRO_KEY = \"pycro_event\"  # where we store the pycro event in the mda event\nSKIP = \"pycro_skip\"  # if we should skip this event\n\n\ndef _build_engine(\n    event_queue: EventQueue,\n    event_generation_hook_fn: AcquisitionHook | None = None,\n    pre_hardware_hook_fn: AcquisitionHook | None = None,\n    post_hardware_hook_fn: AcquisitionHook | None = None,\n    post_camera_hook_fn: AcquisitionHook | None = None,\n) -&gt; type[MDAEngine]:\n\"\"\"Convert pycromanager hooks to a pymmcore-plus style MDAEngine subclass.\"\"\"\n\n    class PycroEngine(MDAEngine):\n        def setup_event(self, event: MDAEvent) -&gt; None:\n            pyc_event = event.metadata[PYCRO_KEY]\n            if pre_hardware_hook_fn is not None:\n                pyc_event = _call_acq_hook(pre_hardware_hook_fn, pyc_event, event_queue)\n                if pyc_event is None:\n                    event.metadata[SKIP] = True\n                    return\n                event = _pycro_to_mda_event(pyc_event)\n\n            super().setup_event(event)\n            pyc_event = _call_acq_hook(post_hardware_hook_fn, pyc_event, event_queue)\n            if pyc_event is None:\n                event.metadata[SKIP] = True\n\n        def exec_event(self, event: MDAEvent) -&gt; EventPayload | None:\n            if event.metadata.get(SKIP):\n                return None\n\n            result = super().exec_event(event)\n            _call_acq_hook(post_camera_hook_fn, event.metadata[PYCRO_KEY], event_queue)\n            return result\n\n        def event_iterator(self, events: Iterable[MDAEvent]) -&gt; Iterator[MDAEvent]:\n            for pycro_event in iter(event_queue.get, None):\n                _event = _call_acq_hook(\n                    event_generation_hook_fn, pycro_event, event_queue\n                )\n                if _event is not None:\n                    yield _pycro_to_mda_event(_event)\n\n    return PycroEngine\n\n\ndef _pycro_to_mda_event(pycro_event: PycroEvent) -&gt; MDAEvent:\n    # This is rough estimation... ideally, useq-schema would be used directly,\n    # and the need to convert pycro-manager events to MDAEvents would be eliminated.\n\n    # TODO: convert row/col to useq grid plan\n    index = {\n        k[0]: v\n        for k, v in pycro_event[\"axes\"].items()\n        if k in [\"z\", \"time\", \"position\"]\n        # TODO: convert channel str to index integer\n    }\n    if cfg := pycro_event.get(\"config_group\", []):\n        channel = {\"group\": cfg[0], \"config\": cfg[1]}\n    else:\n        channel = None\n\n    return MDAEvent(\n        index=index,\n        channel=channel,\n        x_pos=pycro_event.get(\"x\"),\n        y_pos=pycro_event.get(\"y\"),\n        z_pos=pycro_event.get(\"z\"),\n        exposure=pycro_event.get(\"exposure\"),\n        keep_shutter_open=pycro_event.get(\"keep_shutter_open\", False),\n        min_start_time=pycro_event.get(\"min_start_time\"),\n        properties=[tuple(prop) for prop in pycro_event.get(\"properties\", [])],\n        metadata={PYCRO_KEY: pycro_event},  # store original event\n    )\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    from pycromanager import multi_d_acquisition_events\n\n    core = CMMCorePlus.instance()\n    core.loadSystemConfiguration()\n\n    with Acquisition() as acq:\n        # the pymmcore-plus equivalent here is to use MDASequence\n        # https://pymmcore-plus.github.io/pymmcore-plus/guides/mda_engine/\n        events = multi_d_acquisition_events(\n            num_time_points=4,\n            time_interval_s=2,\n            channel_group=\"Channel\",\n            channels=[\"DAPI\", \"FITC\"],\n            z_start=0,\n            z_end=6,\n            z_step=0.4,\n            order=\"tcz\",\n        )\n        acq.acquire(events)\n</code></pre>"},{"location":"guides/custom_engine/","title":"Custom Acquisition Engines","text":"<p>Important</p> <p>This page assumes you have a basic understanding of how the default MDA acquisition engine works to execute a sequence of <code>useq.MDAEvent</code> objects. If you haven't already done so, please read the Acquisition Engine guide first.</p> <p>While the default MDA acquisition engine is sufficient for many common use cases, you may find that you need to customize the acquisition engine to accomplish your goals. Cases where you may need to customize the acquisition engine include:</p> <ul> <li>Driving hardware for which a micro-manager device   adapter does not exist.</li> <li>Conditionally executing arbitrary python code before, during, or after   each acquisition event.</li> <li>Using an alternate high-performance camera   driver</li> <li>Handling user-specific <code>MDAEvent.metadata</code> values.</li> <li> <p>Intercepting and modifying the event sequence<sup>*</sup>.</p> <p><sup>*</sup>Note</p> <p>If all you want to is to modify the event sequence (e.g. to add additional events in a non-deterministic way) but you don't need to modify the behavior of the acquisition engine itself, you likely don't need to customize the acquisition engine. See the guide on Event-Driven Acquisition for details.</p> </li> </ul>"},{"location":"guides/custom_engine/#the-mdarunner-and-mdaengine","title":"The <code>MDARunner</code> and <code>MDAEngine</code>","text":"<p>Let's start by taking a quick look at how the acquisition logic in pymmcore-plus is structured. There are two key classes involved:</p> <ol> <li>An <code>MDARunner</code> instance is    is responsible for receiving a sequence of <code>useq.MDAEvent</code> objects and    driving an <code>MDAEngine</code> to execute them. The <code>MDARunner</code> is the object that    has the actual <code>run()</code> method. It also    emits all the events, such as    <code>frameReady</code>. Users shouldn't    need to subclass or modify <code>MDARunner</code> directly.</li> <li>An <code>MDAEngine</code> instance (anything that implements the    <code>PMDAEngine</code> protocol) is responsible for    actually setting up and executing each event in the sequence. The default    implementation of the <code>PMDAEngine</code> protocol is the    <code>MDAEngine</code> class, but you can register    your own custom engine, using either a subclass of the default engine,    or any other object that implements the <code>PMDAEngine</code> protocol.</li> </ol> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\n\ncore.mda          # &lt;- The MDARunner instance\ncore.mda.engine   # &lt;- The MDAEngine instance\n</code></pre>"},{"location":"guides/custom_engine/#the-mdaengine-protocol","title":"The <code>MDAEngine</code> Protocol","text":"<p><code>pymmcore-plus</code> defines a protocol (a.k.a \"interface\" in the Java world) that all acquisition engines must implement. Formal API docs for the protocol can be found here, but let's discuss the three key methods here.</p> <ol> <li><code>setup_sequence()</code> -    Setup state of system before an MDA is run.</li> <li><code>setup_event()</code> -    Prepare state of system for an event.</li> <li><code>exec_event()</code>    Execute the event.</li> </ol> <p>The <code>PMDAEngine</code> Protocol</p> <pre><code>class MyEngine:\n    def setup_sequence(self, sequence: MDASequence) -&gt; None:\n\"\"\"Setup state of system (hardware, etc.) before an MDA is run.\n\n        This method is called once at the beginning of a sequence.\n        (The sequence object needn't be used here if not necessary)\n        \"\"\"\n\n    def setup_event(self, event: MDAEvent) -&gt; None:\n\"\"\"Prepare state of system (hardware, etc.) for `event`.\n\n        This method is called before each event in the sequence. It is\n        responsible for preparing the state of the system for the event.\n        The engine should be in a state where it can call `exec_event`\n        without any additional preparation.\n        \"\"\"\n\n    def exec_event(self, event: MDAEvent) -&gt; object:\n\"\"\"Execute `event`.\n\n        This method is called after `setup_event` and is responsible for\n        executing the event. The default assumption is to acquire an image,\n        but more elaborate events will be possible.\n        \"\"\"\n</code></pre> <p>The following methods are optional, but will be used if they are defined:</p> <ol> <li><code>event_iterator()</code> -    Optional wrapper on the event iterator. To customize the event sequence.</li> <li><code>teardown_event()</code> -    Called after <code>exec_event()</code>. To clean up after an event.</li> <li><code>teardown_sequence()</code>    Called after the sequence is complete. To clean up after an MDA.</li> </ol>"},{"location":"guides/custom_engine/#the-built-in-mdaengine","title":"The built-in <code>MDAEngine</code>","text":"<p>The default implementation of the <code>PMDAEngine</code> protocol is the <code>MDAEngine</code> class. It can handle microscope setup and image acquisition for a standard <code>MDAEvent</code>, and opportunistically queues hardware-triggered sequences. It also serves as a good base class for custom engines if you want to extend the default behavior. (You may also find the source code for the <code>MDAEngine</code> class helpful as a reference when writing a custom engine.)</p>"},{"location":"guides/custom_engine/#customizing-the-mdaengine","title":"Customizing the <code>MDAEngine</code>","text":"<p>If you want to customize how the instrument sets up or executes each event, the easiest approach is to subclass the default <code>MDAEngine</code> class and override or extend the methods you need to customize, then register your custom engine with the runner's <code>set_engine()</code> method.</p> <pre><code>from pymmcore_plus import CMMCorePlus\nfrom pymmcore_plus.mda import MDAEngine\nimport useq\n\nclass MyEngine(MDAEngine): # (1)!\n    def setup_event(self, event: useq.MDAEvent) -&gt; None:\n\"\"\"Prepare state of system (hardware, etc.) for `event`.\"\"\"\n        # do some custom pre-setup\n        super().setup_event(event)  # (2)!\n        # do some custom post-setup\n\n    def exec_event(self, event: useq.MDAEvent) -&gt; object:\n\"\"\"Prepare state of system (hardware, etc.) for `event`.\"\"\"\n        # do some custom pre-execution\n        result = super().exec_event(event)  # (3)!\n        # do some custom post-execution\n        return result # (4)!\n\ncore = CMMCorePlus.instance()\ncore.loadSystemConfiguration()\n\n# Register the custom engine with the runner\ncore.mda.set_engine(MyEngine(core))  # (5)!\n\n# Run an MDA\ncore.run_mda([])\n</code></pre> <ol> <li>Create a custom engine by subclassing the default engine</li> <li>Note that it's not required to call the <code>super()</code> method here    if you don't want to</li> <li>Note that it's not required to call the <code>super()</code> method here    if you don't want to</li> <li>If the object returned by <code>exec_event()</code> has an <code>image</code> attribute,    it will be used to emit the <code>frameReady</code> event. A simple implementation    might use a named tuple:    <pre><code>class EventPayload(typing.NamedTuple):\n    image: np.ndarray | None = None\n</code></pre></li> <li>Note that <code>MDAEngine.__init__</code> accepts a <code>CMMCorePlus</code> instance    as its first argument, so you'll need to pass that in when    instantiating your custom engine.</li> </ol>"},{"location":"guides/custom_engine/#utilizing-mdaevent-metadata","title":"Utilizing <code>MDAEvent</code> metadata","text":"<p>More often than not, if you are customizing the acquisition engine, it will be because you'd like to do something other than drive the micro-manager core to set up and acquire an image. Perhaps you need to control a micro-fluidic device, or control a DAQ card, or communicate with a remote server, etc.</p> <p>In all of these cases, you will likely need additional parameters (beyond the fields defined in the <code>MDAEvent</code> class) to pass to your control code. For this, the <code>MDAEvent</code> class has a <code>metadata</code> attribute that is explicitly provided for user-defined data.</p> <pre><code>from pymmcore_plus import CMMCorePlus\nfrom pymmcore_plus.mda import MDAEngine\nimport useq\n\nclass MyEngine(MDAEngine):\n    def setup_event(self, event: useq.MDAEvent) -&gt; None:\n        if 'my_key' in event.metadata:  # (1)!\n            self._my_custom_setup(event.metadata)\n        else:\n            super().setup_event(event)\n\n    def _my_custom_setup(self, metadata: dict) -&gt; None:\n        print(f\"Setting up my custom device with {metadata}\")\n\n    def exec_event(self, event: useq.MDAEvent) -&gt; object:\n        if 'my_key' in event.metadata:\n            return self._my_custom_exec(event.metadata)  # (2)!\n        else:\n            return super().exec_event(event)\n\n    def _my_custom_exec(self, metadata: dict) -&gt; object:\n        print(f\"Executing my custom stuff with {metadata}\")\n\ncore = CMMCorePlus.instance()\ncore.loadSystemConfiguration()\n\ncore.mda.set_engine(MyEngine(core))\n\nexperiment = [\n    useq.MDAEvent(),\n    useq.MDAEvent(metadata={'my_key': {'param1': 'val1'}}),  # (3)!\n    useq.MDAEvent(),\n    useq.MDAEvent(metadata={'my_key': {'param1': 'val2'}}),\n]\n\ncore.run_mda(experiment)\n</code></pre> <ol> <li>You can use any characteristics of the <code>MDAEvent</code>, such as the <code>index</code>, or    the presence of a special key in the <code>metadata</code> attribute, to determine    whether you want to do something special for that event.</li> <li>You don't have to return here. If you also want to do the default image    acquisition, you can call <code>super().exec_event(event)</code> as well.</li> <li>Add metadata to the event. You can do this either by constructing your own    sequence of <code>MDAEvent</code> objects, or by using    <code>MDASequence</code> to build    the sequence for you, then editing the <code>metadata</code> attributes as needed.</li> </ol> <p>Example</p> <p>For a real-world example of an <code>MDAEngine</code> subclass that uses <code>MDAEvent.metadata</code> to drive hardware for Raman spectroscopy, see Ian Hunt-Isaak's raman-mda-engine. (engine subclass here)</p>"},{"location":"guides/event_driven_acquisition/","title":"Event-Driven Acquisition","text":"<p>Important</p> <p>This page assumes you have a basic understanding of how the default MDA acquisition engine works to execute a sequence of <code>useq.MDAEvent</code> objects. If you haven't already done so, please read the Acquisition Engine guide first.</p> <p>You may not always know the exact sequence of events that you want to execute ahead of time. For example, you may want to start acquiring images at a certain frequency, but then take a burst of images at a faster frame rate or in a specific region of interest when a specific (possibly rare) event occurs. This is sometimes referred to as event-driven acquisition, or \"smart-microscopy\".</p> <p>In publications</p> <p>For two compelling examples of this type of event-driven microscopy, see:</p> <ol> <li> <p>Mahecic D, Stepp WL, Zhang C, Griffi\u00e9 J, Weigert M, Manley S. Event-driven acquisition for content-enriched microscopy. Nat Methods 19, 1262\u20131267 (2022). https://doi.org/10.1038/s41592-022-01589-x</p> </li> <li> <p>Shi Y, Tabet JS, Milkie DE, Daugird TA, Yang CQ, Giovannucci A, Legant WR. Smart Lattice Light Sheet Microscopy for imaging rare and complex cellular events. bioRxiv. 2023 Mar 9 https://doi.org/10.1101/2023.03.07.531517.</p> </li> </ol> <p>Obviously, in this case, you can't just create a list of <code>useq.MDAEvent</code> objects and pass them to the acquisition engine, since that list needs to change based on the results of previous events.</p> <p>Fortunately, the <code>MDARunner.run()</code> method is designed to handle this case.</p>"},{"location":"guides/event_driven_acquisition/#iterablemdaevent","title":"<code>Iterable[MDAEvent]</code>","text":"<p>The key thing to observe here is the signature of the <code>MDARunner.run()</code> method:</p> <pre><code>from typing import Iterable\nimport useq\n\nclass MDARunner:\n    def run(self, events: Iterable[useq.MDAEvent]) -&gt; None: ...\n</code></pre> <p> The <code>run</code> method expects an iterable of <code>useq.MDAEvent</code> objects. </p> <p>Iterable</p> <p>An <code>Iterable</code> is any object that implements an <code>__iter__()</code> method that returns an iterator object. This includes sequences of known length, like <code>list</code>, <code>tuple</code>, but also many other types of objects, such as generators, <code>deque</code>, and more. Other types such as <code>Queue</code> can easily be converted to an iterator as well, as we'll see below.</p>"},{"location":"guides/event_driven_acquisition/#useful-iterables","title":"Useful Iterables","text":"<p>Many python objects are iterable. Let's look at a few types of iterables that can be used to implement event-driven acquisition in pymmcore-plus.</p>"},{"location":"guides/event_driven_acquisition/#generators","title":"Generators","text":"<p>Generator functions are functions that contain <code>yield</code> statements. When called, they return a generator iterator that can be used to iterate over the values yielded by the generator function. </p> <p>Say what?</p> <p>That may sound a bit confusing, but it's actually quite simple.  It just means that you can use the output of a generator function in a for loop:</p> <pre><code>from typing import Iterator\n\n# a generator function, which contains \"yield\" statements\ndef my_generator_func() -&gt; Iterator[int]:\n    yield 1\n    yield 2\n\n# calling the function returns an iterator\ngen_iterator = my_generator_func()\n\n# which we can iterate over (e.g. in a for loop)\nfor value in gen_iterator:\n    print(value)  # prints 1, then 2\n</code></pre> <p>Let's create a generator that yields <code>useq.MDAEvent</code> objects, but simulate a \"burst\" of events when a certain condition is met:</p> <pre><code>import random\nimport time\nfrom typing import Iterator\n\nimport useq\n\ndef some_condition_is_met() -&gt; bool:\n    # Return True 20% of the time ...\n    # Just an example of some probabilistic condition\n    # This could be anything, the results of analysis, etc.\n    return random.random() &lt; 0.2\n\n# generator function that yields events\ndef my_events() -&gt; Iterator[useq.MDAEvent]:\n    i = 0\n    while True:\n        if some_condition_is_met():\n            # yield a burst of events\n            for _ in range(5):\n                yield useq.MDAEvent(metadata={'bursting': True})\n        elif i &gt; 5:\n            # stop after 5 events\n            # (just an example of some stop condition)\n            return\n        else:\n            # yield a regular single event\n            yield useq.MDAEvent()\n\n        # wait a bit before yielding the next event (1)\n        time.sleep(0.1)\n        i += 1\n</code></pre> <ol> <li>Note, we could also take advantage of the <code>min_start_time</code>    field in MDAEvent, but this demonstrates that the generator    can also control the timing of events.</li> </ol> example output of <code>list(my_events())</code> <p>We can use the <code>list()</code> function to iterate over the generator and collect the yielded events:</p> <pre><code>list(my_events())\n</code></pre> <p>Because of the random condition, the output will be different each time, but it might look something like this:</p> <pre><code>[\n    MDAEvent(),\n    MDAEvent(metadata={'bursting': True}),  # (1)!\n    MDAEvent(metadata={'bursting': True}),\n    MDAEvent(metadata={'bursting': True}),\n    MDAEvent(metadata={'bursting': True}),\n    MDAEvent(metadata={'bursting': True}),\n    MDAEvent(),\n    MDAEvent(),\n    MDAEvent(),\n    MDAEvent() # (2)!\n]\n</code></pre> <ol> <li><code>some_condition_is_met</code> returned <code>True</code> on the second iteration,    so the generator yielded a burst of events.</li> <li>Our \"stop condition\" of <code>i &gt; 5</code> was met, so the generator returned    and stopped yielding events.</li> </ol> <p>To run this \"experiment\" using pymmcore-plus, we can pass the output of the generator to the <code>MDARunner.run()</code> method:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\ncore = CMMCorePlus()\ncore.loadSystemConfiguration()\n\ncore.run_mda(my_events())\n</code></pre>"},{"location":"guides/event_driven_acquisition/#queues","title":"Queues","text":"<p>Python's <code>Queue</code> class is useful for managing and synchronizing data between multiple threads or processes. It ensures orderly execution and prevents race conditions. Generally, a Queue is passed between threads or processes, and one thread or process puts data (such as an <code>MDAEvent</code> to execute) into the queue, while another thread or process gets data out of the queue.</p> <p>A <code>Queue</code> instance itself is not an iterable...</p> <p></p> <pre><code>&gt;&gt;&gt; from queue import Queue\n&gt;&gt;&gt; list(Queue())\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'Queue' object is not iterable\n</code></pre> <p>however, a <code>Queue</code> can be easily converted to an iterator using the two-argument version of the builtin <code>iter()</code> function:</p> <p></p> <pre><code>&gt;&gt;&gt; from queue import Queue\n&gt;&gt;&gt; q = Queue()\n&gt;&gt;&gt; q.put(1)\n&gt;&gt;&gt; q.put(2)\n&gt;&gt;&gt; q.put('STOP')\n&gt;&gt;&gt; iterable_queue = iter(q.get, 'STOP') # !! (1)\n&gt;&gt;&gt; list(iterable_queue)\n[1, 2]\n</code></pre> <ol> <li> Thanks Kyle Douglass for discovering this handy, if obscure, second argument to <code>iter()</code>!</li> </ol> <p>We can use this <code>iter(queue.get, sentinel)</code> pattern to create a queue-backed iterable that can be passed to the <code>run_mda()</code> method. The acquisition engine will then execute events as they get <code>put</code> into the queue, until the stop sentinel is encountered.</p> <pre><code>from queue import Queue\nfrom pymmcore_plus import CMMCorePlus\nfrom useq import MDAEvent\n\ncore = CMMCorePlus()\ncore.loadSystemConfiguration()\n\nq = Queue()                    # create the queue\nSTOP = object()                # any object can serve as the sentinel\nq_iterator = iter(q.get, STOP) # create the queue-backed iterable\n\n# start the acquisition in a separate thread\ncore.run_mda(q_iterator)\n\n# (optional) connect some callback to the imageReady signal\n@core.mda.events.frameReady.connect\ndef on_frame(img, event):\n    print(f'Frame {event.index} received: {img.shape}')\n\n# now we can put events into the queue\n# according to whatever logic we want:\nq.put(MDAEvent(index={'t': 0}, exposure=20))\nq.put(MDAEvent(index={'t': 1}, exposure=40))\n\n# ... and eventually stop the acquisition\nq.put(STOP)\n</code></pre> More complete event-driven acquisition example <p>The following example is modified from this gist by Kyle Douglass.</p> <p>It simulates a typical event-driven acquisition, where an Analyzer object analyzes the results of each image and provides a dict of results. The Controller object then decides whether to continue or stop the acquisition (by placing the <code>STOP_EVENT</code> sentinel in the queue).</p> event_driven_acquisition.py<pre><code>\"\"\"Simple simulator demonstrating event-driven acquisitions with pymmcore-plus.\"\"\"\nimport random\nimport time\nfrom queue import Queue\n\nimport numpy as np\nfrom pymmcore_plus import CMMCorePlus\nfrom useq import MDAEvent\n\n\nclass Analyzer:\n\"\"\"Analyzes images and returns a dict of results.\"\"\"\n\n    def run(self, data) -&gt; dict:\n        # Fake analysis; randomly return a dict with a value of None 10% of the time\n        if random.random() &lt; 0.1:\n            return {\"result\": \"STOP\"}\n        else:\n            return {\"result\": random.random()}\n\n\nclass Controller:\n    STOP_EVENT = object()\n\n    def __init__(self, analyzer: Analyzer, mmc: CMMCorePlus, queue: Queue):\n        self._analyzer = analyzer  # analyzer of images\n        self._queue = queue  # queue of MDAEvents\n        self._results: dict = {}  # results of analysis\n\n        self._mmc = mmc\n        mmc.mda.events.frameReady.connect(self._on_frame_ready)\n\n    def _on_frame_ready(self, img: np.ndarray, event: MDAEvent) -&gt; None:\n        # Analyze the image\n        self._results = self._analyzer.run(img)\n\n    def run(self) -&gt; None:\n        # convert the queue to an iterable\n        queue_sequence = iter(self._queue.get, self.STOP_EVENT)\n\n        # Start the acquisition (run_mda is non-blocking)\n        self._mmc.run_mda(queue_sequence)\n\n        # Queue the first image acquisition\n        self._queue.put(MDAEvent(exposure=10))\n\n        # loop until the analyzer returns \"STOP\"\n        while True:\n            # get the last results from the analyzer\n            result = self._results.pop(\"result\", None)\n\n            # Decide what to do. This is the key part of the reactive loop.\n            if result == \"STOP\":\n                # Do nothing and return\n                print(\"Analyzer returned no results. Stopping...\")\n                self._queue.put(self.STOP_EVENT)\n                break\n            elif result:\n                # Adjust the exposure time based on the results and continue\n                print(\"Analyzer returned results. Continuing...\")\n                next_event = MDAEvent(exposure=10 * result)\n                self._queue.put(next_event)\n            else:\n                # No results yet, wait a bit and check again\n                time.sleep(0.1)\n\n\ndef main():\n    # Setup the MM Core\n    mmc = CMMCorePlus()\n    mmc.loadSystemConfiguration()\n\n    # create the Queue that will hold the MDAEvents\n    q = Queue()\n\n    # Setup the controller and analyzer\n    analyzer = Analyzer()\n    controller = Controller(analyzer, mmc, q)\n\n    # Start the acquisition\n    controller.run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"guides/event_driven_acquisition/#mdasequence","title":"MDASequence","text":"<p>It's worth noting that the <code>MDASequence</code> class is itself an <code>Iterable[MDAEvent]</code>. It implements an <code>__iter__</code> method that yields the events in the sequence, and it can be passed directly to the <code>run_mda()</code> method as we saw in the Acquisition engine guide. It is a deterministic sequence, so it wouldn't be used on its own to implement conditional event sequences; it can, however, be used in conjunction with other iterables to implement more complex sequences.</p> <p>Take this simple sequence as an example:</p> <pre><code>my_sequence = useq.MDASequence(\n    time_plan={'loops': 5, 'interval': 0.1},\n    channels=[\"DAPI\", \"FITC\"]\n)\n</code></pre> <p>In the generator example above, we could yield the events in this sequence when the condition is met (saving us from constructing the events manually)</p> <pre><code># example usage in the\ndef my_events() -&gt; Iterator[useq.MDAEvent]:\n    while True:\n        if some_condition_is_met():\n            yield from my_sequence  # yield the events in the sequence\n        else:\n            ...\n</code></pre> <p>In the <code>Queue</code> example above, we could <code>put</code> the events in the sequence into the queue:</p> <pre><code># ... we can put events into the queue\n# according to whatever logic we want:\nfor event in my_sequence:\n    q.put(event)\n</code></pre>"},{"location":"guides/logging/","title":"Logging","text":"<p>By default, pymmcore-plus logs to the console at the <code>INFO</code> level and to a logfile in the pymmcore-plus application data directory at the <code>DEBUG</code> level. The logfile is named <code>pymmcore_plus.log</code> and is rotated at 40MB, with a maximum retention of 20 logfiles.</p>"},{"location":"guides/logging/#customizing-logging","title":"Customizing logging","text":"<p>The <code>pymmcore_plus.configure_logging</code> function allows you to customize the log level, logfile name, and logfile rotation settings.</p> <p>You may also configure logging using the following environment variables:</p> Variable Default Description PYMM_LOG_LEVEL INFO The log level. PYMM_LOG_FILE <code>pymmcore_plus.log</code> in the pymmcore-plus log directory The logfile location. <p>pymmcore-plus log directory</p> <p>The application data directory is platform-dependent. Here are the log folders for each supported platform:</p> OS Path macOS ~/Library/Application Support/pymmcore-plus/logs Unix ~/.local/share/pymmcore-plus/logs Win C:\\Users\\username\\AppData\\Local\\pymmcore-plus\\pymmcore-plus\\logs <p>You can also use <code>mmcore logs --reveal</code> to open the log directory in your file manager.</p> <p>Note that both pymmcore-plus and the underlying CMMCore object will write to the log file. By default, CMMCorePlus will call <code>setPrimaryLogFile()</code> with the location of the pymmcore-plus logfile upon instantiation.</p>"},{"location":"guides/logging/#managing-logs-with-the-cli","title":"Managing logs with the CLI","text":"<p>The <code>mmcore</code> CLI provides a <code>logs</code> subcommand for managing logs.</p> <pre><code>$ mmcore logs --help\n\u001b[1m                                                                            \u001b[0m\n\u001b[1m \u001b[0m\u001b[1;33mUsage: \u001b[0m\u001b[1mmmcore logs [OPTIONS]\u001b[0m\u001b[1m                                              \u001b[0m\u001b[1m \u001b[0m\n\u001b[1m                                                                            \u001b[0m\n Display recent output from pymmcore-plus log.                              \n\n\u001b[2m\u256d\u2500\u001b[0m\u001b[2m Options \u001b[0m\u001b[2m\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[0m\u001b[2m\u2500\u256e\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-num\u001b[0m     \u001b[1;32m-n\u001b[0m      \u001b[1;33mINTEGER\u001b[0m  Number of lines to display. \u001b[2m[default: None]\u001b[0m   \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-tail\u001b[0m    \u001b[1;32m-t\u001b[0m      \u001b[1;33m       \u001b[0m  Continually stream logs.                      \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-clear\u001b[0m   \u001b[1;32m-c\u001b[0m      \u001b[1;33m       \u001b[0m  Delete all log files.                         \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-reveal\u001b[0m          \u001b[1;33m       \u001b[0m  Reveal log file in Explorer/Finder.           \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2502\u001b[0m \u001b[1;36m-\u001b[0m\u001b[1;36m-help\u001b[0m            \u001b[1;33m       \u001b[0m  Show this message and exit.                   \u001b[2m\u2502\u001b[0m\n\u001b[2m\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\u001b[0m\n</code></pre> <p>A particularly useful command is <code>mmcore logs --tail</code>, which will continually stream the current logfile to the console. This can be started in another process and left running to monitor an experiment in progress.</p> <p>To delete all logfiles, use <code>mmcore logs --clear</code>.</p>"},{"location":"guides/mda_engine/","title":"The Acquisition Engine","text":"<p>Shoulders of giants...</p> <p>The patterns in the acquisition engine are heavily inspired by the previous micro-manager engines.  The first engine was written in clojure by Arthur Edelstein, Nenad Amodaj, and Nico Stuurman. The second engine (AcqEngJ) was written in Java by Henry Pinkard. Thanks to all of them for their fantastic work!</p> <p>One of the key features of pymmcore-plus is the acquisition engine. This allows you to define and execute a sequence of events. The sequence may be a typical multi-dimensional acquisition (MDA), such as a z-stack across multiple channels, stage positions, and time points; or it can be any custom sequence of events that you define. It needn't even be a sequence of known length: you can define an iterable or a <code>queue.Queue</code> of events that reacts to the results of previous events, for event-driven \"smart\" microscopy.</p> <p>The built-in acquisition engine will support many standard use-cases, but you can also subclass and customize it, allowing arbitrary python code to be executed at each step of the acquisition. This makes it possible to incorporate custom hardware control (e.g. to control devices for which micro-manager has no adapters), data analysis, or other logic into the experiment.</p>"},{"location":"guides/mda_engine/#running-a-very-simple-sequence","title":"Running a very simple sequence","text":"<p>To execute a sequence, you must:</p> <ol> <li>Create a <code>CMMCorePlus</code> instance (and probably    load a configuration file)</li> <li>Pass an iterable of <code>useq.MDAEvent</code> objects to the    <code>run_mda()</code> method.</li> </ol> <pre><code>from pymmcore_plus import CMMCorePlus\nfrom useq import MDAEvent\n\n# Create the core instance.\nmmc = CMMCorePlus.instance()  # (1)!\nmmc.loadSystemConfiguration()  # (2)!\n\n# Create a super-simple sequence, with one event\nmda_sequence = [MDAEvent()] # (3)!\n\n# Run it!\nmmc.run_mda(mda_sequence)\n</code></pre> <ol> <li>Here, we use the global    <code>CMMCorePlus.instance</code> singleton.</li> <li>This loads the demo configuration by default. Pass in your own config file.    See    <code>CMMCorePlus.loadSystemConfiguration</code></li> <li>An experiment is just an iterable of <code>useq.MDAEvent</code> objects.</li> </ol> <p>Tip</p> <p><code>CMMCorePlus.run_mda</code> is a convenience method that runs the experiment in a separate thread. If you want to run it in the main thread, use <code>CMMCorePlus.mda.run</code> directly.</p> <pre><code>mmc.mda.run(seq)\n</code></pre> <p>The code above will execute a single, very boring event! It will snap one image (the default action of an <code>MDAEvent</code>) with the current exposure time, channel, stage position, etc... and then stop.</p> <p>Let's make it a little more interesting.</p>"},{"location":"guides/mda_engine/#the-mdaevent-object","title":"The <code>MDAEvent</code> object","text":"<p>The <code>useq.MDAEvent</code> object is the basic building block of an experiment. It is a relatively simple dataclass that defines a single action to be performed. For complete details, see the useq-schema documentation, but some key attributes you might want to set are:</p> <ul> <li>exposure (<code>float</code>): The exposure time (in milliseconds) to use for this   event.</li> <li>channel (<code>str | dict[str, str]</code>): The configuration group to use. If a   <code>dict</code>, it should have two keys: <code>group</code> and <code>config</code> (the configuration group   and preset, respectively). If a <code>str</code>, it is assumed to be the name of a preset in   the <code>Channel</code> group.</li> <li>x_pos, y_pos, z_pos (<code>float</code>): An <code>x</code>, <code>y</code>, and <code>z</code> stage position   to use for this event.</li> <li>min_start_time (<code>float</code>): The minimum time to wait before starting this   event.(in seconds, relative to the start of the experiment)</li> </ul> <p>Example</p> <pre><code>snap_a_dapi = MDAEvent(channel=\"DAPI\", exposure=100, x_pos=1100, y_pos=1240)\n</code></pre> <p>NOTE: The name <code>\"DAPI\"</code> here must be a name of a preset in your micro-manager \"Channel\" configuration group.</p> <p>For any missing keys, the implied meaning is \"use the current setting\". For example, an <code>MDAEvent</code> without an <code>x_pos</code> or a <code>y_pos</code> will use the current stage position.</p> <p>The implied \"action\" of an <code>MDAEvent</code> is to snap an image. But there are ways to customize that, described later.</p>"},{"location":"guides/mda_engine/#a-multi-event-sequence","title":"A multi-event sequence","text":"<p>With our understanding of <code>MDAEvent</code> objects, we can now create a slightly more interesting experiment. This one will snap four images: two channels at two different stage positions.</p> <pre><code>from pymmcore_plus import CMMCorePlus\nfrom useq import MDAEvent\n\n# Create the core instance.\nmmc = CMMCorePlus.instance()\nmmc.loadSystemConfiguration()\n\n# Snap two channels at two positions\nmda_sequence = [\n    MDAEvent(channel={'config': \"DAPI\"}, x_pos=1100, y_pos=1240),\n    MDAEvent(channel={'config': \"FITC\"}, x_pos=1100, y_pos=1240),\n    MDAEvent(channel={'config': \"DAPI\"}, x_pos=1442, y_pos=1099),\n    MDAEvent(channel={'config': \"FITC\"}, x_pos=1442, y_pos=1099),\n]\n\n# Run it!\nmmc.run_mda(mda_sequence)\n</code></pre> <p>Logs</p> <p>If you run the code above, you will see some logs printed to the console that look something like this:</p> <pre><code>2023-08-12 16:37:50,694 - INFO - MDA Started: GeneratorMDASequence()\n2023-08-12 16:37:50,695 - INFO - channel=Channel(config='DAPI') x_pos=1100.0 y_pos=1240.0\n2023-08-12 16:37:50,881 - INFO - channel=Channel(config='FITC') x_pos=1100.0 y_pos=1240.0\n2023-08-12 16:37:50,891 - INFO - channel=Channel(config='DAPI') x_pos=1442.0 y_pos=1099.0\n2023-08-12 16:37:50,947 - INFO - channel=Channel(config='FITC') x_pos=1442.0 y_pos=1099.0\n2023-08-12 16:37:50,958 - INFO - MDA Finished: GeneratorMDASequence()\n</code></pre> <p>See logging for more details on how to configure and review logs.</p> <p>At this point, you might thinking that constructing a sequence by hand is a little tedious. And you'd be right! That's why we have the <code>MDASequence</code> class.</p>"},{"location":"guides/mda_engine/#building-sequences-with-mdasequence","title":"Building sequences with <code>MDASequence</code>","text":"<p>For most standard multi-dimensional experiments, you will want to use <code>useq.MDASequence</code> to construct your sequence of events. It allows you to declare a \"plan\" for each axis in your experiment (channels, time, z, etc...) along with the order in which the axes should be iterated.</p> <p>See the useq-schema documentation for complete details, but let's look at how <code>MDASequence</code> can be used to create a few common experiments.</p>"},{"location":"guides/mda_engine/#a-two-channel-time-series","title":"A two-channel time series","text":"<pre><code>from useq import MDASequence\n\nmda_sequence = MDASequence(\n    time_plan={\"interval\": 2, \"loops\": 6}, # (1)!\n    channels=[\n        {\"config\": \"DAPI\", \"exposure\": 50},\n        {\"config\": \"FITC\", \"exposure\": 80},\n    ]\n)\n</code></pre> <ol> <li>10 loops, with a 2 second interval between each loop. See also, additional    time-plans.</li> </ol> output of <code>list(mda_sequence)</code> <pre><code>[\n    MDAEvent(index={'t': 0, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=0.0),\n    MDAEvent(index={'t': 0, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=0.0),\n    MDAEvent(index={'t': 1, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=2.0),\n    MDAEvent(index={'t': 1, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=2.0),\n    MDAEvent(index={'t': 2, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=4.0),\n    MDAEvent(index={'t': 2, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=4.0),\n    MDAEvent(index={'t': 3, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=6.0),\n    MDAEvent(index={'t': 3, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=6.0),\n    MDAEvent(index={'t': 4, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=8.0),\n    MDAEvent(index={'t': 4, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=8.0),\n    MDAEvent(index={'t': 5, 'c': 0}, channel=Channel(config='DAPI'), exposure=50.0, min_start_time=10.0),\n    MDAEvent(index={'t': 5, 'c': 1}, channel=Channel(config='FITC'), exposure=80.0, min_start_time=10.0),\n]\n</code></pre>"},{"location":"guides/mda_engine/#a-z-stack-at-three-positions","title":"A Z-stack at three positions","text":"<pre><code>from useq import MDASequence, Position\n\nmda_sequence = MDASequence(\n    z_plan={\"range\": 4, \"step\": 0.5},  # (1)!\n    stage_positions=[  # (2)!\n        (10, 10, 20),\n        {'x': 30, 'y': 40, 'z': 50},\n        Position(x=60, y=70, z=80),\n    ]\n)\n</code></pre> <ol> <li>A 4-micron Z-stack with 0.5 micron steps, ranging around each position. See    also, additional    z-plans.</li> <li>These are all valid ways to specify a stage    position.    None of <code>x</code>, <code>y</code>, or <code>z</code> are required.</li> </ol> output of <code>list(mda_sequence)</code> <pre><code>[\n    MDAEvent(index={'p': 0, 'z': 0}, x_pos=10.0, y_pos=10.0, z_pos=18.0),\n    MDAEvent(index={'p': 0, 'z': 1}, x_pos=10.0, y_pos=10.0, z_pos=18.5),\n    MDAEvent(index={'p': 0, 'z': 2}, x_pos=10.0, y_pos=10.0, z_pos=19.0),\n    MDAEvent(index={'p': 0, 'z': 3}, x_pos=10.0, y_pos=10.0, z_pos=19.5),\n    MDAEvent(index={'p': 0, 'z': 4}, x_pos=10.0, y_pos=10.0, z_pos=20.0),\n    MDAEvent(index={'p': 0, 'z': 5}, x_pos=10.0, y_pos=10.0, z_pos=20.5),\n    MDAEvent(index={'p': 0, 'z': 6}, x_pos=10.0, y_pos=10.0, z_pos=21.0),\n    MDAEvent(index={'p': 0, 'z': 7}, x_pos=10.0, y_pos=10.0, z_pos=21.5),\n    MDAEvent(index={'p': 0, 'z': 8}, x_pos=10.0, y_pos=10.0, z_pos=22.0),\n    MDAEvent(index={'p': 1, 'z': 0}, x_pos=30.0, y_pos=40.0, z_pos=48.0),\n    MDAEvent(index={'p': 1, 'z': 1}, x_pos=30.0, y_pos=40.0, z_pos=48.5),\n    MDAEvent(index={'p': 1, 'z': 2}, x_pos=30.0, y_pos=40.0, z_pos=49.0),\n    MDAEvent(index={'p': 1, 'z': 3}, x_pos=30.0, y_pos=40.0, z_pos=49.5),\n    MDAEvent(index={'p': 1, 'z': 4}, x_pos=30.0, y_pos=40.0, z_pos=50.0),\n    MDAEvent(index={'p': 1, 'z': 5}, x_pos=30.0, y_pos=40.0, z_pos=50.5),\n    MDAEvent(index={'p': 1, 'z': 6}, x_pos=30.0, y_pos=40.0, z_pos=51.0),\n    MDAEvent(index={'p': 1, 'z': 7}, x_pos=30.0, y_pos=40.0, z_pos=51.5),\n    MDAEvent(index={'p': 1, 'z': 8}, x_pos=30.0, y_pos=40.0, z_pos=52.0),\n    MDAEvent(index={'p': 2, 'z': 0}, x_pos=60.0, y_pos=70.0, z_pos=78.0),\n    MDAEvent(index={'p': 2, 'z': 1}, x_pos=60.0, y_pos=70.0, z_pos=78.5),\n    MDAEvent(index={'p': 2, 'z': 2}, x_pos=60.0, y_pos=70.0, z_pos=79.0),\n    MDAEvent(index={'p': 2, 'z': 3}, x_pos=60.0, y_pos=70.0, z_pos=79.5),\n    MDAEvent(index={'p': 2, 'z': 4}, x_pos=60.0, y_pos=70.0, z_pos=80.0),\n    MDAEvent(index={'p': 2, 'z': 5}, x_pos=60.0, y_pos=70.0, z_pos=80.5),\n    MDAEvent(index={'p': 2, 'z': 6}, x_pos=60.0, y_pos=70.0, z_pos=81.0),\n    MDAEvent(index={'p': 2, 'z': 7}, x_pos=60.0, y_pos=70.0, z_pos=81.5),\n    MDAEvent(index={'p': 2, 'z': 8}, x_pos=60.0, y_pos=70.0, z_pos=82.0)\n]\n</code></pre>"},{"location":"guides/mda_engine/#a-grid-of-z-stacks","title":"A grid of Z-stacks","text":"<p>Here we use <code>axis_order</code> to declare that we want the full Z-stack to happen at each <code>(row, col)</code> before moving to the next position in the grid.</p> <pre><code>from useq import MDASequence\n\nmda_sequence = MDASequence(\n    stage_positions=[{'x': 100, 'y': 200, 'z': 300}],\n    grid_plan={\"fov_width\": 20, \"fov_height\": 10, \"rows\": 2, \"columns\": 2},\n    z_plan={\"range\": 10, \"step\": 2.5},\n    axis_order=\"pgz\"  # (1)!\n)\n</code></pre> <ol> <li>The \"fastest\" axes come last. By putting <code>z</code> after <code>g</code> in the <code>axis_order</code>,     we're saying \"at each <code>g</code>, do a full <code>z</code> iteration\".</li> </ol> output of <code>list(mda_sequence)</code> <pre><code>[\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 0}, x_pos=90.0, y_pos=205.0, z_pos=295.0),\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 1}, x_pos=90.0, y_pos=205.0, z_pos=297.5),\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 2}, x_pos=90.0, y_pos=205.0, z_pos=300.0),\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 3}, x_pos=90.0, y_pos=205.0, z_pos=302.5),\n    MDAEvent(index={'p': 0, 'g': 0, 'z': 4}, x_pos=90.0, y_pos=205.0, z_pos=305.0),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 0}, x_pos=110.0, y_pos=205.0, z_pos=295.0),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 1}, x_pos=110.0, y_pos=205.0, z_pos=297.5),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 2}, x_pos=110.0, y_pos=205.0, z_pos=300.0),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 3}, x_pos=110.0, y_pos=205.0, z_pos=302.5),\n    MDAEvent(index={'p': 0, 'g': 1, 'z': 4}, x_pos=110.0, y_pos=205.0, z_pos=305.0),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 0}, x_pos=110.0, y_pos=195.0, z_pos=295.0),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 1}, x_pos=110.0, y_pos=195.0, z_pos=297.5),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 2}, x_pos=110.0, y_pos=195.0, z_pos=300.0),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 3}, x_pos=110.0, y_pos=195.0, z_pos=302.5),\n    MDAEvent(index={'p': 0, 'g': 2, 'z': 4}, x_pos=110.0, y_pos=195.0, z_pos=305.0),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 0}, x_pos=90.0, y_pos=195.0, z_pos=295.0),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 1}, x_pos=90.0, y_pos=195.0, z_pos=297.5),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 2}, x_pos=90.0, y_pos=195.0, z_pos=300.0),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 3}, x_pos=90.0, y_pos=195.0, z_pos=302.5),\n    MDAEvent(index={'p': 0, 'g': 3, 'z': 4}, x_pos=90.0, y_pos=195.0, z_pos=305.0)\n]\n</code></pre>"},{"location":"guides/mda_engine/#skip-timepoints-or-z-stacks","title":"Skip timepoints or Z-stacks","text":"<p>The <code>Channel</code> field has a few tricks, such as skipping timepoints or Z-stacks for specific channels. Here we take a fast Z-stack (leaving the shutter open) in the <code>FITC</code> channel only, and a single image in the <code>DIC</code> channel every 3 timepoints:</p> <pre><code>from useq import MDASequence\n\nmda_sequence = MDASequence(\n    z_plan={\"range\": 10, \"step\": 2.5},\n    time_plan={\"interval\": 2, \"loops\": 6},\n    channels=[\n        \"FITC\",\n        {\"config\": \"DIC\", \"acquire_every\": 3, \"do_stack\": False},\n    ],\n    keep_shutter_open_across=['z'],\n)\n</code></pre> output of <code>list(mda_sequence)</code> <pre><code>[\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 0}, channel='FITC', min_start_time=0.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 1}, channel='FITC', min_start_time=0.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 2}, channel='FITC', min_start_time=0.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 3}, channel='FITC', min_start_time=0.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 0, 'c': 0, 'z': 4}, channel='FITC', min_start_time=0.0, z_pos=5.0),\n    MDAEvent(index={'t': 0, 'c': 1, 'z': 2}, channel='DIC', min_start_time=0.0, z_pos=0.0),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 0}, channel='FITC', min_start_time=2.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 1}, channel='FITC', min_start_time=2.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 2}, channel='FITC', min_start_time=2.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 3}, channel='FITC', min_start_time=2.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 1, 'c': 0, 'z': 4}, channel='FITC', min_start_time=2.0, z_pos=5.0),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 0}, channel='FITC', min_start_time=4.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 1}, channel='FITC', min_start_time=4.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 2}, channel='FITC', min_start_time=4.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 3}, channel='FITC', min_start_time=4.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 2, 'c': 0, 'z': 4}, channel='FITC', min_start_time=4.0, z_pos=5.0),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 0}, channel='FITC', min_start_time=6.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 1}, channel='FITC', min_start_time=6.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 2}, channel='FITC', min_start_time=6.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 3}, channel='FITC', min_start_time=6.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 3, 'c': 0, 'z': 4}, channel='FITC', min_start_time=6.0, z_pos=5.0),\n    MDAEvent(index={'t': 3, 'c': 1, 'z': 2}, channel='DIC', min_start_time=6.0, z_pos=0.0),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 0}, channel='FITC', min_start_time=8.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 1}, channel='FITC', min_start_time=8.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 2}, channel='FITC', min_start_time=8.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 3}, channel='FITC', min_start_time=8.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 4, 'c': 0, 'z': 4}, channel='FITC', min_start_time=8.0, z_pos=5.0),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 0}, channel='FITC', min_start_time=10.0, z_pos=-5.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 1}, channel='FITC', min_start_time=10.0, z_pos=-2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 2}, channel='FITC', min_start_time=10.0, z_pos=0.0, keep_shutter_open=True),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 3}, channel='FITC', min_start_time=10.0, z_pos=2.5, keep_shutter_open=True),\n    MDAEvent(index={'t': 5, 'c': 0, 'z': 4}, channel='FITC', min_start_time=10.0, z_pos=5.0)\n]\n</code></pre>"},{"location":"guides/mda_engine/#a-note-on-syntax","title":"A note on syntax","text":"<p>If you prefer, you can use <code>useq</code> objects rather than <code>dicts</code> for all of these fields. This has the advantage of providing type-checking and auto-completion in your IDE.</p> <p>Example</p> <p>The following two sequences are equivalent:</p> <pre><code>import useq\n\nmda_sequence1 = useq.MDASequence(\n    time_plan={\"interval\": 2, \"loops\": 10},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    channels=[\n        {\"config\": \"DAPI\", \"exposure\": 50},\n        {\"config\": \"FITC\", \"exposure\": 80},\n    ]\n)\n\nmda_sequence2 = useq.MDASequence(\n    time_plan=useq.TIntervalLoops(interval=2, loops=10),\n    z_plan=useq.ZRangeAround(range=4, step=0.5),\n    channels=[\n        useq.Channel(config=\"DAPI\", exposure=50),\n        useq.Channel(config=\"FITC\", exposure=80),\n    ]\n)\n\nassert mda_sequence1 == mda_sequence2\n</code></pre>"},{"location":"guides/mda_engine/#running-an-mda-sequence","title":"Running an MDA sequence","text":"<p>You may have noticed above that we could call <code>list()</code> on an instance of <code>MDASequence</code> to get a list of <code>MDAEvent</code> objects. This means that <code>MDASequence</code> is an iterable of <code>MDAEvent</code>... which is exactly what we need to pass to the <code>run_mda()</code> method.</p> <p>So, you can directly pass an instance of <code>MDASequence</code> to <code>run_mda</code>:</p> <pre><code>from pymmcore_plus import CMMCorePlus\nimport useq\n\nmmc = CMMCorePlus.instance()\nmmc.loadSystemConfiguration()\n\n# create a sequence\nmda_sequence = useq.MDASequence(\n    time_plan={\"interval\": 2, \"loops\": 10},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    channels=[\n        {\"config\": \"DAPI\", \"exposure\": 50},\n        {\"config\": \"FITC\", \"exposure\": 20},\n    ]\n)\n\n# Run it!\nmmc.run_mda(mda_sequence)\n</code></pre>"},{"location":"guides/mda_engine/#handling-acquired-data","title":"Handling acquired data","text":"<p>You will almost certainly want to do something with the data that is collected during an MDA . <code>pymmcore-plus</code> is relatively agnostic about how acquired data is handled. There are currently no built-in methods for saving data to disk in any particular format.</p> <p>This is partially because there are so many good existing ways to store array data to disk in Python, including:</p> <ul> <li>zarr</li> <li>tifffile</li> <li>numpy</li> <li>xarray</li> <li>aicsimageio</li> </ul> <p>You will, however, want to know how to connect callbacks to the <code>frameReady</code> event, so that you can handle incoming data as it is acquired:</p> <pre><code>from pymmcore_plus import CMMCorePlus\nimport numpy as np\nimport useq\n\nmmc = CMMCorePlus.instance()\nmmc.loadSystemConfiguration()\n\n@mmc.mda.events.frameReady.connect # (1)!\ndef on_frame(image: np.ndarray, event: useq.MDAEvent):\n    # do what you want with the data\n    print(\n        f\"received frame: {image.shape}, {image.dtype} \"\n        f\"@ index {event.index}, z={event.z_pos}\"\n    )\n\nmda_sequence = useq.MDASequence(\n    time_plan={\"interval\": 0.5, \"loops\": 10},\n    z_plan={\"range\": 4, \"step\": 0.5},\n)\n\nmmc.run_mda(mda_sequence)\n</code></pre> <ol> <li>The <code>frameReady</code> signal accepts a callback with up to two arguments:    the image data as a numpy array, and the <code>MDAEvent</code> that triggered the callback</li> </ol> <p>See also additional events you may also wish to connect to</p>"},{"location":"guides/mda_engine/#cancelling-or-pausing","title":"Cancelling or Pausing","text":"<p>You can pause or cancel the mda with the <code>CMMCorePlus.mda.toggle_pause</code> or <code>CMMCorePlus.mda.cancel</code> methods.</p> <pre><code>mmc.mda.toggle_pause()  # pauses the mda\nmmc.mda.toggle_pause()  # resumes the mda\n\nmmc.mda.cancel()  # cancels the mda\n</code></pre>"},{"location":"guides/mda_engine/#serializing-mda-sequences","title":"Serializing MDA sequences","text":"<p><code>MDASequence</code> objects can be serialized and deserialized to and from JSON or YAML, making it easy to save and load them from file:</p> <pre><code>import useq\nfrom pathlib import Path\n\nmda_sequence = useq.MDASequence(\n    time_plan={\"interval\": 2, \"loops\": 10},\n    z_plan={\"range\": 4, \"step\": 0.5},\n    channels=[\n        {\"config\": \"DAPI\", \"exposure\": 50, \"do_stack\": False},\n        {\"config\": \"FITC\", \"exposure\": 20},\n    ],\n    axis_order=\"tcz\"\n)\n\nPath(\"mda_sequence.yaml\").write_text(mda_sequence.yaml())\n</code></pre> <p>... results in:</p> mda_sequence.yaml<pre><code>axis_order: tcz\nchannels:\n- config: DAPI\ndo_stack: false\nexposure: 50.0\n- config: FITC\nexposure: 20.0\ntime_plan:\ninterval: 0:00:02\nloops: 10\nz_plan:\nrange: 4.0\nstep: 0.5\n</code></pre> <p>... which can be loaded back into a <code>MDASequence</code> object:</p> <pre><code>mda_sequence = useq.MDASequence.from_file(\"mda_sequence.yaml\")\n</code></pre> <p>... or even run directly with the <code>mmcore</code> command line:</p> <pre><code># use --config to specify a config file for your microscope\n$ mmcore run mda_sequence.yaml\n</code></pre>"},{"location":"guides/mda_engine/#hardware-triggered-sequences","title":"Hardware-triggered sequences","text":"<p>Having the computer \"in-the-loop\" for every event in an MDA sequence, can add unwanted overhead that limits performance in rapid acquisition sequences. Because of this, some devices support hardware triggering. This means that the computer can tell the device to queue up and start a sequence of events, and the device will take care of executing the sequence without further input from the computer.</p> <p>Just like micro-manager's acquisition engine, the default acquisition engine in <code>pymmcore-plus</code> can opportunistically use hardware triggering whenever possible. For now, this behavior is off by default (in order to avoid unexpected behavior), but you can enable it by setting <code>CMMCorePlus.mda.engine.use_hardware_sequencing = True</code>:</p> <pre><code>from pymmcore_plus import CMMCorePlus\n\nmmc = CMMCorePlus.instance()\nmmc.loadSystemConfiguration()\n\n# enable hardware triggering\nmmc.mda.engine.use_hardware_sequencing = True\n</code></pre> <p>How does pymmcore-plus know if my device supports hardware triggering?</p> <p>The low-level <code>CMMCore</code> object itself has a number of methods that query whether certain devices are capable of hardware triggering, such as</p> <ul> <li><code>pymmcore.CMMCore.isStageSequenceable</code></li> <li><code>pymmcore.CMMCore.isPropertySequenceable</code></li> <li><code>pymmcore.CMMCore.isXYStageSequenceable</code></li> <li><code>pymmcore.CMMCore.isExposureSequenceable</code></li> </ul> <p>If two <code>MDAEvents</code> in a sequence have different exposure, stage, or other device property values, then <code>pymmcore-plus</code> uses these methods to determine whether the events can be sequenced (see <code>pymmcore_plus.CMMCorePlus.canSequenceEvents</code>). If they can, then the events are grouped together and executed as a single hardware-triggered sequence.</p> <pre><code>from pymmcore_plus import CMMCorePlus\nimport useq\n\nmmc = CMMCorePlus.instance()\n\nmmc.loadSystemConfiguration()\nprint(mmc.canSequenceEvents(useq.MDAEvent(), useq.MDAEvent()))  # True\nprint(mmc.canSequenceEvents(\n    useq.MDAEvent(exposure=50, x_pos=54),\n    useq.MDAEvent(exposure=10, x_pos=40)\n))  # False, unless you have stage and exposure hardware triggering\n</code></pre>"},{"location":"guides/mda_engine/#next-steps","title":"Next steps","text":"<p>Now that you have a basic understanding of how to create and run multi-dimensional acquisition sequences in pymmcore-plus, you may want to take a look at some more advanced features:</p> <ul> <li>customizing the acquisition engine</li> <li>creating non-deterministic sequences for event-driven   acquisition</li> </ul>"}]}